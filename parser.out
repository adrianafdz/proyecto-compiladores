Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } END ;
Rule 2     clases -> clases clase
Rule 3     clases -> empty
Rule 4     clase -> TYPE ID : ID { cvars funciones }
Rule 5     clase -> TYPE ID { cvars funciones }
Rule 6     funciones -> funciones funcion
Rule 7     funciones -> empty
Rule 8     funcion -> FUNC ID ( params ) : tipo { vars estatutos }
Rule 9     funcion -> FUNC ID ( params ) : NOTHING { vars estatutos }
Rule 10    vars -> vars DEF tipo dimension : lista_id ;
Rule 11    vars -> vars DEF ID : lista_id ;
Rule 12    vars -> empty
Rule 13    cvars -> cvars DEF tipo dimension : lista_id ;
Rule 14    cvars -> empty
Rule 15    lista_id -> ID
Rule 16    lista_id -> lista_id , ID
Rule 17    dimension -> [ expresion ]
Rule 18    dimension -> [ expresion ] [ expresion ]
Rule 19    dimension -> empty
Rule 20    tipo -> NUMBER
Rule 21    tipo -> STRING
Rule 22    params -> pparams
Rule 23    params -> empty
Rule 24    pparams -> tipo ID
Rule 25    pparams -> pparams , tipo ID
Rule 26    estatutos -> estatutos estatuto
Rule 27    estatutos -> empty
Rule 28    estatuto -> asignacion
Rule 29    estatuto -> while
Rule 30    estatuto -> for
Rule 31    estatuto -> condicion
Rule 32    estatuto -> CALL call_func ;
Rule 33    call_func -> func
Rule 34    call_func -> input
Rule 35    call_func -> write
Rule 36    call_func -> to_num
Rule 37    call_func -> to_str
Rule 38    call_func -> return
Rule 39    func -> ID ( args )
Rule 40    func -> ID : ID ( args )
Rule 41    args -> args_list
Rule 42    args -> empty
Rule 43    args_list -> expresion
Rule 44    args_list -> args_list , expresion
Rule 45    asignacion -> var = expresion ;
Rule 46    var -> ID : ID dimension
Rule 47    var -> ID dimension
Rule 48    expresion -> exp
Rule 49    expresion -> expresion COMP exp
Rule 50    exp -> term
Rule 51    exp -> exp OPTERM term
Rule 52    term -> fact
Rule 53    term -> term OPFACT fact
Rule 54    fact -> ( expresion )
Rule 55    fact -> var
Rule 56    fact -> NUM
Rule 57    fact -> OPTERM NUM
Rule 58    fact -> CALL call_func
Rule 59    condicion -> IF ( expresion ) THEN { estatutos } condicionp
Rule 60    condicionp -> ELSE { estatutos }
Rule 61    condicionp -> empty
Rule 62    while -> WHILE ( expresion ) DO { estatutos }
Rule 63    for -> FOR expresion TO expresion { estatutos }
Rule 64    to_num -> TO_NUMBER ( STR )
Rule 65    to_num -> TO_NUMBER ( var )
Rule 66    to_str -> TO_STRING ( expresion )
Rule 67    input -> INPUT ( var )
Rule 68    write -> PRINT ( write_list )
Rule 69    write_list -> write_list & write_listp
Rule 70    write_list -> write_listp
Rule 71    write_listp -> STR
Rule 72    write_listp -> var
Rule 73    write_listp -> to_str
Rule 74    return -> RET ( expresion )
Rule 75    empty -> <empty>

Terminals, with rules where they appear

&                    : 69
(                    : 1 8 9 39 40 54 59 62 64 65 66 67 68 74
)                    : 1 8 9 39 40 54 59 62 64 65 66 67 68 74
,                    : 16 25 44
:                    : 4 8 9 10 11 13 40 46
;                    : 1 1 10 11 13 32 45
=                    : 45
CALL                 : 32 58
COMP                 : 49
DEF                  : 10 11 13
DO                   : 62
ELSE                 : 60
END                  : 1
FOR                  : 63
FUNC                 : 8 9
ID                   : 1 4 4 5 8 9 11 15 16 24 25 39 40 40 46 46 47
IF                   : 59
INPUT                : 67
MAIN                 : 1
NOTHING              : 9
NUM                  : 56 57
NUMBER               : 20
OPFACT               : 53
OPTERM               : 51 57
PRINT                : 68
PROGRAM              : 1
RET                  : 74
STR                  : 64 71
STRING               : 21
THEN                 : 59
TO                   : 63
TO_NUMBER            : 64 65
TO_STRING            : 66
TYPE                 : 4 5
WHILE                : 62
[                    : 17 18 18
]                    : 17 18 18
error                : 
{                    : 1 4 5 8 9 59 60 62 63
}                    : 1 4 5 8 9 59 60 62 63

Nonterminals, with rules where they appear

args                 : 39 40
args_list            : 41 44
asignacion           : 28
call_func            : 32 58
clase                : 2
clases               : 1 2
condicion            : 31
condicionp           : 59
cvars                : 4 5 13
dimension            : 10 13 46 47
empty                : 3 7 12 14 19 23 27 42 61
estatuto             : 26
estatutos            : 1 8 9 26 59 60 62 63
exp                  : 48 49 51
expresion            : 17 18 18 43 44 45 49 54 59 62 63 63 66 74
fact                 : 52 53
for                  : 30
func                 : 33
funcion              : 6
funciones            : 1 4 5 6
input                : 34
lista_id             : 10 11 13 16
params               : 8 9
pparams              : 22 25
return               : 38
start                : 0
term                 : 50 51 53
tipo                 : 8 10 13 24 25
to_num               : 36
to_str               : 37 73
var                  : 45 55 65 67 72
vars                 : 1 8 9 10 11
while                : 29
write                : 35
write_list           : 68 69
write_listp          : 69 70

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } END ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . ID ; clases vars funciones MAIN ( ) { estatutos } END ;

    ID              shift and go to state 3


state 3

    (1) start -> PROGRAM ID . ; clases vars funciones MAIN ( ) { estatutos } END ;

    ;               shift and go to state 4


state 4

    (1) start -> PROGRAM ID ; . clases vars funciones MAIN ( ) { estatutos } END ;
    (2) clases -> . clases clase
    (3) clases -> . empty
    (75) empty -> .

    TYPE            reduce using rule 75 (empty -> .)
    DEF             reduce using rule 75 (empty -> .)
    MAIN            reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    clases                         shift and go to state 5
    empty                          shift and go to state 6

state 5

    (1) start -> PROGRAM ID ; clases . vars funciones MAIN ( ) { estatutos } END ;
    (2) clases -> clases . clase
    (10) vars -> . vars DEF tipo dimension : lista_id ;
    (11) vars -> . vars DEF ID : lista_id ;
    (12) vars -> . empty
    (4) clase -> . TYPE ID : ID { cvars funciones }
    (5) clase -> . TYPE ID { cvars funciones }
    (75) empty -> .

    TYPE            shift and go to state 10
    DEF             reduce using rule 75 (empty -> .)
    MAIN            reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    vars                           shift and go to state 7
    clase                          shift and go to state 8
    empty                          shift and go to state 9

state 6

    (3) clases -> empty .

    TYPE            reduce using rule 3 (clases -> empty .)
    DEF             reduce using rule 3 (clases -> empty .)
    MAIN            reduce using rule 3 (clases -> empty .)
    FUNC            reduce using rule 3 (clases -> empty .)


state 7

    (1) start -> PROGRAM ID ; clases vars . funciones MAIN ( ) { estatutos } END ;
    (10) vars -> vars . DEF tipo dimension : lista_id ;
    (11) vars -> vars . DEF ID : lista_id ;
    (6) funciones -> . funciones funcion
    (7) funciones -> . empty
    (75) empty -> .

    DEF             shift and go to state 12
    MAIN            reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    funciones                      shift and go to state 11
    empty                          shift and go to state 13

state 8

    (2) clases -> clases clase .

    TYPE            reduce using rule 2 (clases -> clases clase .)
    DEF             reduce using rule 2 (clases -> clases clase .)
    MAIN            reduce using rule 2 (clases -> clases clase .)
    FUNC            reduce using rule 2 (clases -> clases clase .)


state 9

    (12) vars -> empty .

    DEF             reduce using rule 12 (vars -> empty .)
    MAIN            reduce using rule 12 (vars -> empty .)
    FUNC            reduce using rule 12 (vars -> empty .)
    }               reduce using rule 12 (vars -> empty .)
    CALL            reduce using rule 12 (vars -> empty .)
    WHILE           reduce using rule 12 (vars -> empty .)
    FOR             reduce using rule 12 (vars -> empty .)
    IF              reduce using rule 12 (vars -> empty .)
    ID              reduce using rule 12 (vars -> empty .)


state 10

    (4) clase -> TYPE . ID : ID { cvars funciones }
    (5) clase -> TYPE . ID { cvars funciones }

    ID              shift and go to state 14


state 11

    (1) start -> PROGRAM ID ; clases vars funciones . MAIN ( ) { estatutos } END ;
    (6) funciones -> funciones . funcion
    (8) funcion -> . FUNC ID ( params ) : tipo { vars estatutos }
    (9) funcion -> . FUNC ID ( params ) : NOTHING { vars estatutos }

    MAIN            shift and go to state 15
    FUNC            shift and go to state 17

    funcion                        shift and go to state 16

state 12

    (10) vars -> vars DEF . tipo dimension : lista_id ;
    (11) vars -> vars DEF . ID : lista_id ;
    (20) tipo -> . NUMBER
    (21) tipo -> . STRING

    ID              shift and go to state 19
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21

    tipo                           shift and go to state 18

state 13

    (7) funciones -> empty .

    MAIN            reduce using rule 7 (funciones -> empty .)
    FUNC            reduce using rule 7 (funciones -> empty .)
    }               reduce using rule 7 (funciones -> empty .)


state 14

    (4) clase -> TYPE ID . : ID { cvars funciones }
    (5) clase -> TYPE ID . { cvars funciones }

    :               shift and go to state 22
    {               shift and go to state 23


state 15

    (1) start -> PROGRAM ID ; clases vars funciones MAIN . ( ) { estatutos } END ;

    (               shift and go to state 24


state 16

    (6) funciones -> funciones funcion .

    MAIN            reduce using rule 6 (funciones -> funciones funcion .)
    FUNC            reduce using rule 6 (funciones -> funciones funcion .)
    }               reduce using rule 6 (funciones -> funciones funcion .)


state 17

    (8) funcion -> FUNC . ID ( params ) : tipo { vars estatutos }
    (9) funcion -> FUNC . ID ( params ) : NOTHING { vars estatutos }

    ID              shift and go to state 25


state 18

    (10) vars -> vars DEF tipo . dimension : lista_id ;
    (17) dimension -> . [ expresion ]
    (18) dimension -> . [ expresion ] [ expresion ]
    (19) dimension -> . empty
    (75) empty -> .

    [               shift and go to state 27
    :               reduce using rule 75 (empty -> .)

    dimension                      shift and go to state 26
    empty                          shift and go to state 28

state 19

    (11) vars -> vars DEF ID . : lista_id ;

    :               shift and go to state 29


state 20

    (20) tipo -> NUMBER .

    [               reduce using rule 20 (tipo -> NUMBER .)
    :               reduce using rule 20 (tipo -> NUMBER .)
    ID              reduce using rule 20 (tipo -> NUMBER .)
    {               reduce using rule 20 (tipo -> NUMBER .)


state 21

    (21) tipo -> STRING .

    [               reduce using rule 21 (tipo -> STRING .)
    :               reduce using rule 21 (tipo -> STRING .)
    ID              reduce using rule 21 (tipo -> STRING .)
    {               reduce using rule 21 (tipo -> STRING .)


state 22

    (4) clase -> TYPE ID : . ID { cvars funciones }

    ID              shift and go to state 30


state 23

    (5) clase -> TYPE ID { . cvars funciones }
    (13) cvars -> . cvars DEF tipo dimension : lista_id ;
    (14) cvars -> . empty
    (75) empty -> .

    DEF             reduce using rule 75 (empty -> .)
    }               reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    cvars                          shift and go to state 31
    empty                          shift and go to state 32

state 24

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( . ) { estatutos } END ;

    )               shift and go to state 33


state 25

    (8) funcion -> FUNC ID . ( params ) : tipo { vars estatutos }
    (9) funcion -> FUNC ID . ( params ) : NOTHING { vars estatutos }

    (               shift and go to state 34


state 26

    (10) vars -> vars DEF tipo dimension . : lista_id ;

    :               shift and go to state 35


state 27

    (17) dimension -> [ . expresion ]
    (18) dimension -> [ . expresion ] [ expresion ]
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 36
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 28

    (19) dimension -> empty .

    :               reduce using rule 19 (dimension -> empty .)
    OPFACT          reduce using rule 19 (dimension -> empty .)
    OPTERM          reduce using rule 19 (dimension -> empty .)
    ]               reduce using rule 19 (dimension -> empty .)
    COMP            reduce using rule 19 (dimension -> empty .)
    )               reduce using rule 19 (dimension -> empty .)
    ,               reduce using rule 19 (dimension -> empty .)
    TO              reduce using rule 19 (dimension -> empty .)
    ;               reduce using rule 19 (dimension -> empty .)
    {               reduce using rule 19 (dimension -> empty .)
    =               reduce using rule 19 (dimension -> empty .)
    &               reduce using rule 19 (dimension -> empty .)


state 29

    (11) vars -> vars DEF ID : . lista_id ;
    (15) lista_id -> . ID
    (16) lista_id -> . lista_id , ID

    ID              shift and go to state 46

    lista_id                       shift and go to state 47

state 30

    (4) clase -> TYPE ID : ID . { cvars funciones }

    {               shift and go to state 48


state 31

    (5) clase -> TYPE ID { cvars . funciones }
    (13) cvars -> cvars . DEF tipo dimension : lista_id ;
    (6) funciones -> . funciones funcion
    (7) funciones -> . empty
    (75) empty -> .

    DEF             shift and go to state 50
    }               reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    funciones                      shift and go to state 49
    empty                          shift and go to state 13

state 32

    (14) cvars -> empty .

    DEF             reduce using rule 14 (cvars -> empty .)
    }               reduce using rule 14 (cvars -> empty .)
    FUNC            reduce using rule 14 (cvars -> empty .)


state 33

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) . { estatutos } END ;

    {               shift and go to state 51


state 34

    (8) funcion -> FUNC ID ( . params ) : tipo { vars estatutos }
    (9) funcion -> FUNC ID ( . params ) : NOTHING { vars estatutos }
    (22) params -> . pparams
    (23) params -> . empty
    (24) pparams -> . tipo ID
    (25) pparams -> . pparams , tipo ID
    (75) empty -> .
    (20) tipo -> . NUMBER
    (21) tipo -> . STRING

    )               reduce using rule 75 (empty -> .)
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21

    params                         shift and go to state 52
    tipo                           shift and go to state 53
    pparams                        shift and go to state 54
    empty                          shift and go to state 55

state 35

    (10) vars -> vars DEF tipo dimension : . lista_id ;
    (15) lista_id -> . ID
    (16) lista_id -> . lista_id , ID

    ID              shift and go to state 46

    lista_id                       shift and go to state 56

state 36

    (17) dimension -> [ expresion . ]
    (18) dimension -> [ expresion . ] [ expresion ]
    (49) expresion -> expresion . COMP exp

    ]               shift and go to state 57
    COMP            shift and go to state 58


state 37

    (48) expresion -> exp .
    (51) exp -> exp . OPTERM term

    ]               reduce using rule 48 (expresion -> exp .)
    COMP            reduce using rule 48 (expresion -> exp .)
    )               reduce using rule 48 (expresion -> exp .)
    ,               reduce using rule 48 (expresion -> exp .)
    TO              reduce using rule 48 (expresion -> exp .)
    ;               reduce using rule 48 (expresion -> exp .)
    {               reduce using rule 48 (expresion -> exp .)
    OPTERM          shift and go to state 59


state 38

    (50) exp -> term .
    (53) term -> term . OPFACT fact

    OPTERM          reduce using rule 50 (exp -> term .)
    ]               reduce using rule 50 (exp -> term .)
    COMP            reduce using rule 50 (exp -> term .)
    )               reduce using rule 50 (exp -> term .)
    ,               reduce using rule 50 (exp -> term .)
    TO              reduce using rule 50 (exp -> term .)
    ;               reduce using rule 50 (exp -> term .)
    {               reduce using rule 50 (exp -> term .)
    OPFACT          shift and go to state 60


state 39

    (57) fact -> OPTERM . NUM

    NUM             shift and go to state 61


state 40

    (52) term -> fact .

    OPFACT          reduce using rule 52 (term -> fact .)
    OPTERM          reduce using rule 52 (term -> fact .)
    ]               reduce using rule 52 (term -> fact .)
    COMP            reduce using rule 52 (term -> fact .)
    )               reduce using rule 52 (term -> fact .)
    ,               reduce using rule 52 (term -> fact .)
    TO              reduce using rule 52 (term -> fact .)
    ;               reduce using rule 52 (term -> fact .)
    {               reduce using rule 52 (term -> fact .)


state 41

    (54) fact -> ( . expresion )
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 62
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 42

    (55) fact -> var .

    OPFACT          reduce using rule 55 (fact -> var .)
    OPTERM          reduce using rule 55 (fact -> var .)
    ]               reduce using rule 55 (fact -> var .)
    COMP            reduce using rule 55 (fact -> var .)
    )               reduce using rule 55 (fact -> var .)
    ,               reduce using rule 55 (fact -> var .)
    TO              reduce using rule 55 (fact -> var .)
    ;               reduce using rule 55 (fact -> var .)
    {               reduce using rule 55 (fact -> var .)


state 43

    (56) fact -> NUM .

    OPFACT          reduce using rule 56 (fact -> NUM .)
    OPTERM          reduce using rule 56 (fact -> NUM .)
    ]               reduce using rule 56 (fact -> NUM .)
    COMP            reduce using rule 56 (fact -> NUM .)
    )               reduce using rule 56 (fact -> NUM .)
    ,               reduce using rule 56 (fact -> NUM .)
    TO              reduce using rule 56 (fact -> NUM .)
    ;               reduce using rule 56 (fact -> NUM .)
    {               reduce using rule 56 (fact -> NUM .)


state 44

    (58) fact -> CALL . call_func
    (33) call_func -> . func
    (34) call_func -> . input
    (35) call_func -> . write
    (36) call_func -> . to_num
    (37) call_func -> . to_str
    (38) call_func -> . return
    (39) func -> . ID ( args )
    (40) func -> . ID : ID ( args )
    (67) input -> . INPUT ( var )
    (68) write -> . PRINT ( write_list )
    (64) to_num -> . TO_NUMBER ( STR )
    (65) to_num -> . TO_NUMBER ( var )
    (66) to_str -> . TO_STRING ( expresion )
    (74) return -> . RET ( expresion )

    ID              shift and go to state 70
    INPUT           shift and go to state 71
    PRINT           shift and go to state 72
    TO_NUMBER       shift and go to state 73
    TO_STRING       shift and go to state 74
    RET             shift and go to state 75

    call_func                      shift and go to state 63
    func                           shift and go to state 64
    input                          shift and go to state 65
    write                          shift and go to state 66
    to_num                         shift and go to state 67
    to_str                         shift and go to state 68
    return                         shift and go to state 69

state 45

    (46) var -> ID . : ID dimension
    (47) var -> ID . dimension
    (17) dimension -> . [ expresion ]
    (18) dimension -> . [ expresion ] [ expresion ]
    (19) dimension -> . empty
    (75) empty -> .

    :               shift and go to state 76
    [               shift and go to state 27
    OPFACT          reduce using rule 75 (empty -> .)
    OPTERM          reduce using rule 75 (empty -> .)
    ]               reduce using rule 75 (empty -> .)
    COMP            reduce using rule 75 (empty -> .)
    )               reduce using rule 75 (empty -> .)
    ,               reduce using rule 75 (empty -> .)
    TO              reduce using rule 75 (empty -> .)
    ;               reduce using rule 75 (empty -> .)
    {               reduce using rule 75 (empty -> .)
    =               reduce using rule 75 (empty -> .)
    &               reduce using rule 75 (empty -> .)

    dimension                      shift and go to state 77
    empty                          shift and go to state 28

state 46

    (15) lista_id -> ID .

    ;               reduce using rule 15 (lista_id -> ID .)
    ,               reduce using rule 15 (lista_id -> ID .)


state 47

    (11) vars -> vars DEF ID : lista_id . ;
    (16) lista_id -> lista_id . , ID

    ;               shift and go to state 78
    ,               shift and go to state 79


state 48

    (4) clase -> TYPE ID : ID { . cvars funciones }
    (13) cvars -> . cvars DEF tipo dimension : lista_id ;
    (14) cvars -> . empty
    (75) empty -> .

    DEF             reduce using rule 75 (empty -> .)
    }               reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    cvars                          shift and go to state 80
    empty                          shift and go to state 32

state 49

    (5) clase -> TYPE ID { cvars funciones . }
    (6) funciones -> funciones . funcion
    (8) funcion -> . FUNC ID ( params ) : tipo { vars estatutos }
    (9) funcion -> . FUNC ID ( params ) : NOTHING { vars estatutos }

    }               shift and go to state 81
    FUNC            shift and go to state 17

    funcion                        shift and go to state 16

state 50

    (13) cvars -> cvars DEF . tipo dimension : lista_id ;
    (20) tipo -> . NUMBER
    (21) tipo -> . STRING

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21

    tipo                           shift and go to state 82

state 51

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) { . estatutos } END ;
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 83
    empty                          shift and go to state 84

state 52

    (8) funcion -> FUNC ID ( params . ) : tipo { vars estatutos }
    (9) funcion -> FUNC ID ( params . ) : NOTHING { vars estatutos }

    )               shift and go to state 85


state 53

    (24) pparams -> tipo . ID

    ID              shift and go to state 86


state 54

    (22) params -> pparams .
    (25) pparams -> pparams . , tipo ID

    )               reduce using rule 22 (params -> pparams .)
    ,               shift and go to state 87


state 55

    (23) params -> empty .

    )               reduce using rule 23 (params -> empty .)


state 56

    (10) vars -> vars DEF tipo dimension : lista_id . ;
    (16) lista_id -> lista_id . , ID

    ;               shift and go to state 88
    ,               shift and go to state 79


state 57

    (17) dimension -> [ expresion ] .
    (18) dimension -> [ expresion ] . [ expresion ]

    :               reduce using rule 17 (dimension -> [ expresion ] .)
    OPFACT          reduce using rule 17 (dimension -> [ expresion ] .)
    OPTERM          reduce using rule 17 (dimension -> [ expresion ] .)
    ]               reduce using rule 17 (dimension -> [ expresion ] .)
    COMP            reduce using rule 17 (dimension -> [ expresion ] .)
    )               reduce using rule 17 (dimension -> [ expresion ] .)
    ,               reduce using rule 17 (dimension -> [ expresion ] .)
    TO              reduce using rule 17 (dimension -> [ expresion ] .)
    ;               reduce using rule 17 (dimension -> [ expresion ] .)
    {               reduce using rule 17 (dimension -> [ expresion ] .)
    =               reduce using rule 17 (dimension -> [ expresion ] .)
    &               reduce using rule 17 (dimension -> [ expresion ] .)
    [               shift and go to state 89


state 58

    (49) expresion -> expresion COMP . exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    exp                            shift and go to state 90
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 59

    (51) exp -> exp OPTERM . term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    term                           shift and go to state 91
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 60

    (53) term -> term OPFACT . fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    fact                           shift and go to state 92
    var                            shift and go to state 42

state 61

    (57) fact -> OPTERM NUM .

    OPFACT          reduce using rule 57 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 57 (fact -> OPTERM NUM .)
    ]               reduce using rule 57 (fact -> OPTERM NUM .)
    COMP            reduce using rule 57 (fact -> OPTERM NUM .)
    )               reduce using rule 57 (fact -> OPTERM NUM .)
    ,               reduce using rule 57 (fact -> OPTERM NUM .)
    TO              reduce using rule 57 (fact -> OPTERM NUM .)
    ;               reduce using rule 57 (fact -> OPTERM NUM .)
    {               reduce using rule 57 (fact -> OPTERM NUM .)


state 62

    (54) fact -> ( expresion . )
    (49) expresion -> expresion . COMP exp

    )               shift and go to state 93
    COMP            shift and go to state 58


state 63

    (58) fact -> CALL call_func .

    OPFACT          reduce using rule 58 (fact -> CALL call_func .)
    OPTERM          reduce using rule 58 (fact -> CALL call_func .)
    ]               reduce using rule 58 (fact -> CALL call_func .)
    COMP            reduce using rule 58 (fact -> CALL call_func .)
    )               reduce using rule 58 (fact -> CALL call_func .)
    ,               reduce using rule 58 (fact -> CALL call_func .)
    TO              reduce using rule 58 (fact -> CALL call_func .)
    ;               reduce using rule 58 (fact -> CALL call_func .)
    {               reduce using rule 58 (fact -> CALL call_func .)


state 64

    (33) call_func -> func .

    OPFACT          reduce using rule 33 (call_func -> func .)
    OPTERM          reduce using rule 33 (call_func -> func .)
    ]               reduce using rule 33 (call_func -> func .)
    COMP            reduce using rule 33 (call_func -> func .)
    )               reduce using rule 33 (call_func -> func .)
    ,               reduce using rule 33 (call_func -> func .)
    TO              reduce using rule 33 (call_func -> func .)
    ;               reduce using rule 33 (call_func -> func .)
    {               reduce using rule 33 (call_func -> func .)


state 65

    (34) call_func -> input .

    OPFACT          reduce using rule 34 (call_func -> input .)
    OPTERM          reduce using rule 34 (call_func -> input .)
    ]               reduce using rule 34 (call_func -> input .)
    COMP            reduce using rule 34 (call_func -> input .)
    )               reduce using rule 34 (call_func -> input .)
    ,               reduce using rule 34 (call_func -> input .)
    TO              reduce using rule 34 (call_func -> input .)
    ;               reduce using rule 34 (call_func -> input .)
    {               reduce using rule 34 (call_func -> input .)


state 66

    (35) call_func -> write .

    OPFACT          reduce using rule 35 (call_func -> write .)
    OPTERM          reduce using rule 35 (call_func -> write .)
    ]               reduce using rule 35 (call_func -> write .)
    COMP            reduce using rule 35 (call_func -> write .)
    )               reduce using rule 35 (call_func -> write .)
    ,               reduce using rule 35 (call_func -> write .)
    TO              reduce using rule 35 (call_func -> write .)
    ;               reduce using rule 35 (call_func -> write .)
    {               reduce using rule 35 (call_func -> write .)


state 67

    (36) call_func -> to_num .

    OPFACT          reduce using rule 36 (call_func -> to_num .)
    OPTERM          reduce using rule 36 (call_func -> to_num .)
    ]               reduce using rule 36 (call_func -> to_num .)
    COMP            reduce using rule 36 (call_func -> to_num .)
    )               reduce using rule 36 (call_func -> to_num .)
    ,               reduce using rule 36 (call_func -> to_num .)
    TO              reduce using rule 36 (call_func -> to_num .)
    ;               reduce using rule 36 (call_func -> to_num .)
    {               reduce using rule 36 (call_func -> to_num .)


state 68

    (37) call_func -> to_str .

    OPFACT          reduce using rule 37 (call_func -> to_str .)
    OPTERM          reduce using rule 37 (call_func -> to_str .)
    ]               reduce using rule 37 (call_func -> to_str .)
    COMP            reduce using rule 37 (call_func -> to_str .)
    )               reduce using rule 37 (call_func -> to_str .)
    ,               reduce using rule 37 (call_func -> to_str .)
    TO              reduce using rule 37 (call_func -> to_str .)
    ;               reduce using rule 37 (call_func -> to_str .)
    {               reduce using rule 37 (call_func -> to_str .)


state 69

    (38) call_func -> return .

    OPFACT          reduce using rule 38 (call_func -> return .)
    OPTERM          reduce using rule 38 (call_func -> return .)
    ]               reduce using rule 38 (call_func -> return .)
    COMP            reduce using rule 38 (call_func -> return .)
    )               reduce using rule 38 (call_func -> return .)
    ,               reduce using rule 38 (call_func -> return .)
    TO              reduce using rule 38 (call_func -> return .)
    ;               reduce using rule 38 (call_func -> return .)
    {               reduce using rule 38 (call_func -> return .)


state 70

    (39) func -> ID . ( args )
    (40) func -> ID . : ID ( args )

    (               shift and go to state 94
    :               shift and go to state 95


state 71

    (67) input -> INPUT . ( var )

    (               shift and go to state 96


state 72

    (68) write -> PRINT . ( write_list )

    (               shift and go to state 97


state 73

    (64) to_num -> TO_NUMBER . ( STR )
    (65) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 98


state 74

    (66) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 99


state 75

    (74) return -> RET . ( expresion )

    (               shift and go to state 100


state 76

    (46) var -> ID : . ID dimension

    ID              shift and go to state 101


state 77

    (47) var -> ID dimension .

    OPFACT          reduce using rule 47 (var -> ID dimension .)
    OPTERM          reduce using rule 47 (var -> ID dimension .)
    ]               reduce using rule 47 (var -> ID dimension .)
    COMP            reduce using rule 47 (var -> ID dimension .)
    )               reduce using rule 47 (var -> ID dimension .)
    ,               reduce using rule 47 (var -> ID dimension .)
    TO              reduce using rule 47 (var -> ID dimension .)
    ;               reduce using rule 47 (var -> ID dimension .)
    {               reduce using rule 47 (var -> ID dimension .)
    =               reduce using rule 47 (var -> ID dimension .)
    &               reduce using rule 47 (var -> ID dimension .)


state 78

    (11) vars -> vars DEF ID : lista_id ; .

    DEF             reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    MAIN            reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    FUNC            reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    }               reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    CALL            reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    WHILE           reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    FOR             reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    IF              reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)
    ID              reduce using rule 11 (vars -> vars DEF ID : lista_id ; .)


state 79

    (16) lista_id -> lista_id , . ID

    ID              shift and go to state 102


state 80

    (4) clase -> TYPE ID : ID { cvars . funciones }
    (13) cvars -> cvars . DEF tipo dimension : lista_id ;
    (6) funciones -> . funciones funcion
    (7) funciones -> . empty
    (75) empty -> .

    DEF             shift and go to state 50
    }               reduce using rule 75 (empty -> .)
    FUNC            reduce using rule 75 (empty -> .)

    funciones                      shift and go to state 103
    empty                          shift and go to state 13

state 81

    (5) clase -> TYPE ID { cvars funciones } .

    TYPE            reduce using rule 5 (clase -> TYPE ID { cvars funciones } .)
    DEF             reduce using rule 5 (clase -> TYPE ID { cvars funciones } .)
    MAIN            reduce using rule 5 (clase -> TYPE ID { cvars funciones } .)
    FUNC            reduce using rule 5 (clase -> TYPE ID { cvars funciones } .)


state 82

    (13) cvars -> cvars DEF tipo . dimension : lista_id ;
    (17) dimension -> . [ expresion ]
    (18) dimension -> . [ expresion ] [ expresion ]
    (19) dimension -> . empty
    (75) empty -> .

    [               shift and go to state 27
    :               reduce using rule 75 (empty -> .)

    dimension                      shift and go to state 104
    empty                          shift and go to state 28

state 83

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos . } END ;
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 105
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 84

    (27) estatutos -> empty .

    }               reduce using rule 27 (estatutos -> empty .)
    CALL            reduce using rule 27 (estatutos -> empty .)
    WHILE           reduce using rule 27 (estatutos -> empty .)
    FOR             reduce using rule 27 (estatutos -> empty .)
    IF              reduce using rule 27 (estatutos -> empty .)
    ID              reduce using rule 27 (estatutos -> empty .)


state 85

    (8) funcion -> FUNC ID ( params ) . : tipo { vars estatutos }
    (9) funcion -> FUNC ID ( params ) . : NOTHING { vars estatutos }

    :               shift and go to state 116


state 86

    (24) pparams -> tipo ID .

    ,               reduce using rule 24 (pparams -> tipo ID .)
    )               reduce using rule 24 (pparams -> tipo ID .)


state 87

    (25) pparams -> pparams , . tipo ID
    (20) tipo -> . NUMBER
    (21) tipo -> . STRING

    NUMBER          shift and go to state 20
    STRING          shift and go to state 21

    tipo                           shift and go to state 117

state 88

    (10) vars -> vars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    MAIN            reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    CALL            reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    WHILE           reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    FOR             reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    IF              reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)
    ID              reduce using rule 10 (vars -> vars DEF tipo dimension : lista_id ; .)


state 89

    (18) dimension -> [ expresion ] [ . expresion ]
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 118
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 90

    (49) expresion -> expresion COMP exp .
    (51) exp -> exp . OPTERM term

    ]               reduce using rule 49 (expresion -> expresion COMP exp .)
    COMP            reduce using rule 49 (expresion -> expresion COMP exp .)
    )               reduce using rule 49 (expresion -> expresion COMP exp .)
    ,               reduce using rule 49 (expresion -> expresion COMP exp .)
    TO              reduce using rule 49 (expresion -> expresion COMP exp .)
    ;               reduce using rule 49 (expresion -> expresion COMP exp .)
    {               reduce using rule 49 (expresion -> expresion COMP exp .)
    OPTERM          shift and go to state 59


state 91

    (51) exp -> exp OPTERM term .
    (53) term -> term . OPFACT fact

    OPTERM          reduce using rule 51 (exp -> exp OPTERM term .)
    ]               reduce using rule 51 (exp -> exp OPTERM term .)
    COMP            reduce using rule 51 (exp -> exp OPTERM term .)
    )               reduce using rule 51 (exp -> exp OPTERM term .)
    ,               reduce using rule 51 (exp -> exp OPTERM term .)
    TO              reduce using rule 51 (exp -> exp OPTERM term .)
    ;               reduce using rule 51 (exp -> exp OPTERM term .)
    {               reduce using rule 51 (exp -> exp OPTERM term .)
    OPFACT          shift and go to state 60


state 92

    (53) term -> term OPFACT fact .

    OPFACT          reduce using rule 53 (term -> term OPFACT fact .)
    OPTERM          reduce using rule 53 (term -> term OPFACT fact .)
    ]               reduce using rule 53 (term -> term OPFACT fact .)
    COMP            reduce using rule 53 (term -> term OPFACT fact .)
    )               reduce using rule 53 (term -> term OPFACT fact .)
    ,               reduce using rule 53 (term -> term OPFACT fact .)
    TO              reduce using rule 53 (term -> term OPFACT fact .)
    ;               reduce using rule 53 (term -> term OPFACT fact .)
    {               reduce using rule 53 (term -> term OPFACT fact .)


state 93

    (54) fact -> ( expresion ) .

    OPFACT          reduce using rule 54 (fact -> ( expresion ) .)
    OPTERM          reduce using rule 54 (fact -> ( expresion ) .)
    ]               reduce using rule 54 (fact -> ( expresion ) .)
    COMP            reduce using rule 54 (fact -> ( expresion ) .)
    )               reduce using rule 54 (fact -> ( expresion ) .)
    ,               reduce using rule 54 (fact -> ( expresion ) .)
    TO              reduce using rule 54 (fact -> ( expresion ) .)
    ;               reduce using rule 54 (fact -> ( expresion ) .)
    {               reduce using rule 54 (fact -> ( expresion ) .)


state 94

    (39) func -> ID ( . args )
    (41) args -> . args_list
    (42) args -> . empty
    (43) args_list -> . expresion
    (44) args_list -> . args_list , expresion
    (75) empty -> .
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    )               reduce using rule 75 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 119
    args_list                      shift and go to state 120
    empty                          shift and go to state 121
    expresion                      shift and go to state 122
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 95

    (40) func -> ID : . ID ( args )

    ID              shift and go to state 123


state 96

    (67) input -> INPUT ( . var )
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    ID              shift and go to state 45

    var                            shift and go to state 124

state 97

    (68) write -> PRINT ( . write_list )
    (69) write_list -> . write_list & write_listp
    (70) write_list -> . write_listp
    (71) write_listp -> . STR
    (72) write_listp -> . var
    (73) write_listp -> . to_str
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension
    (66) to_str -> . TO_STRING ( expresion )

    STR             shift and go to state 127
    ID              shift and go to state 45
    TO_STRING       shift and go to state 74

    write_list                     shift and go to state 125
    write_listp                    shift and go to state 126
    var                            shift and go to state 128
    to_str                         shift and go to state 129

state 98

    (64) to_num -> TO_NUMBER ( . STR )
    (65) to_num -> TO_NUMBER ( . var )
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    STR             shift and go to state 130
    ID              shift and go to state 45

    var                            shift and go to state 131

state 99

    (66) to_str -> TO_STRING ( . expresion )
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 132
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 100

    (74) return -> RET ( . expresion )
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 133
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 101

    (46) var -> ID : ID . dimension
    (17) dimension -> . [ expresion ]
    (18) dimension -> . [ expresion ] [ expresion ]
    (19) dimension -> . empty
    (75) empty -> .

    [               shift and go to state 27
    OPFACT          reduce using rule 75 (empty -> .)
    OPTERM          reduce using rule 75 (empty -> .)
    ]               reduce using rule 75 (empty -> .)
    COMP            reduce using rule 75 (empty -> .)
    )               reduce using rule 75 (empty -> .)
    ,               reduce using rule 75 (empty -> .)
    TO              reduce using rule 75 (empty -> .)
    ;               reduce using rule 75 (empty -> .)
    {               reduce using rule 75 (empty -> .)
    =               reduce using rule 75 (empty -> .)
    &               reduce using rule 75 (empty -> .)

    dimension                      shift and go to state 134
    empty                          shift and go to state 28

state 102

    (16) lista_id -> lista_id , ID .

    ;               reduce using rule 16 (lista_id -> lista_id , ID .)
    ,               reduce using rule 16 (lista_id -> lista_id , ID .)


state 103

    (4) clase -> TYPE ID : ID { cvars funciones . }
    (6) funciones -> funciones . funcion
    (8) funcion -> . FUNC ID ( params ) : tipo { vars estatutos }
    (9) funcion -> . FUNC ID ( params ) : NOTHING { vars estatutos }

    }               shift and go to state 135
    FUNC            shift and go to state 17

    funcion                        shift and go to state 16

state 104

    (13) cvars -> cvars DEF tipo dimension . : lista_id ;

    :               shift and go to state 136


state 105

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } . END ;

    END             shift and go to state 137


state 106

    (26) estatutos -> estatutos estatuto .

    }               reduce using rule 26 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 26 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 26 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 26 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 26 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 26 (estatutos -> estatutos estatuto .)


state 107

    (28) estatuto -> asignacion .

    }               reduce using rule 28 (estatuto -> asignacion .)
    CALL            reduce using rule 28 (estatuto -> asignacion .)
    WHILE           reduce using rule 28 (estatuto -> asignacion .)
    FOR             reduce using rule 28 (estatuto -> asignacion .)
    IF              reduce using rule 28 (estatuto -> asignacion .)
    ID              reduce using rule 28 (estatuto -> asignacion .)


state 108

    (29) estatuto -> while .

    }               reduce using rule 29 (estatuto -> while .)
    CALL            reduce using rule 29 (estatuto -> while .)
    WHILE           reduce using rule 29 (estatuto -> while .)
    FOR             reduce using rule 29 (estatuto -> while .)
    IF              reduce using rule 29 (estatuto -> while .)
    ID              reduce using rule 29 (estatuto -> while .)


state 109

    (30) estatuto -> for .

    }               reduce using rule 30 (estatuto -> for .)
    CALL            reduce using rule 30 (estatuto -> for .)
    WHILE           reduce using rule 30 (estatuto -> for .)
    FOR             reduce using rule 30 (estatuto -> for .)
    IF              reduce using rule 30 (estatuto -> for .)
    ID              reduce using rule 30 (estatuto -> for .)


state 110

    (31) estatuto -> condicion .

    }               reduce using rule 31 (estatuto -> condicion .)
    CALL            reduce using rule 31 (estatuto -> condicion .)
    WHILE           reduce using rule 31 (estatuto -> condicion .)
    FOR             reduce using rule 31 (estatuto -> condicion .)
    IF              reduce using rule 31 (estatuto -> condicion .)
    ID              reduce using rule 31 (estatuto -> condicion .)


state 111

    (32) estatuto -> CALL . call_func ;
    (33) call_func -> . func
    (34) call_func -> . input
    (35) call_func -> . write
    (36) call_func -> . to_num
    (37) call_func -> . to_str
    (38) call_func -> . return
    (39) func -> . ID ( args )
    (40) func -> . ID : ID ( args )
    (67) input -> . INPUT ( var )
    (68) write -> . PRINT ( write_list )
    (64) to_num -> . TO_NUMBER ( STR )
    (65) to_num -> . TO_NUMBER ( var )
    (66) to_str -> . TO_STRING ( expresion )
    (74) return -> . RET ( expresion )

    ID              shift and go to state 70
    INPUT           shift and go to state 71
    PRINT           shift and go to state 72
    TO_NUMBER       shift and go to state 73
    TO_STRING       shift and go to state 74
    RET             shift and go to state 75

    call_func                      shift and go to state 138
    func                           shift and go to state 64
    input                          shift and go to state 65
    write                          shift and go to state 66
    to_num                         shift and go to state 67
    to_str                         shift and go to state 68
    return                         shift and go to state 69

state 112

    (45) asignacion -> var . = expresion ;

    =               shift and go to state 139


state 113

    (62) while -> WHILE . ( expresion ) DO { estatutos }

    (               shift and go to state 140


state 114

    (63) for -> FOR . expresion TO expresion { estatutos }
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 141
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 115

    (59) condicion -> IF . ( expresion ) THEN { estatutos } condicionp

    (               shift and go to state 142


state 116

    (8) funcion -> FUNC ID ( params ) : . tipo { vars estatutos }
    (9) funcion -> FUNC ID ( params ) : . NOTHING { vars estatutos }
    (20) tipo -> . NUMBER
    (21) tipo -> . STRING

    NOTHING         shift and go to state 144
    NUMBER          shift and go to state 20
    STRING          shift and go to state 21

    tipo                           shift and go to state 143

state 117

    (25) pparams -> pparams , tipo . ID

    ID              shift and go to state 145


state 118

    (18) dimension -> [ expresion ] [ expresion . ]
    (49) expresion -> expresion . COMP exp

    ]               shift and go to state 146
    COMP            shift and go to state 58


state 119

    (39) func -> ID ( args . )

    )               shift and go to state 147


state 120

    (41) args -> args_list .
    (44) args_list -> args_list . , expresion

    )               reduce using rule 41 (args -> args_list .)
    ,               shift and go to state 148


state 121

    (42) args -> empty .

    )               reduce using rule 42 (args -> empty .)


state 122

    (43) args_list -> expresion .
    (49) expresion -> expresion . COMP exp

    ,               reduce using rule 43 (args_list -> expresion .)
    )               reduce using rule 43 (args_list -> expresion .)
    COMP            shift and go to state 58


state 123

    (40) func -> ID : ID . ( args )

    (               shift and go to state 149


state 124

    (67) input -> INPUT ( var . )

    )               shift and go to state 150


state 125

    (68) write -> PRINT ( write_list . )
    (69) write_list -> write_list . & write_listp

    )               shift and go to state 151
    &               shift and go to state 152


state 126

    (70) write_list -> write_listp .

    )               reduce using rule 70 (write_list -> write_listp .)
    &               reduce using rule 70 (write_list -> write_listp .)


state 127

    (71) write_listp -> STR .

    )               reduce using rule 71 (write_listp -> STR .)
    &               reduce using rule 71 (write_listp -> STR .)


state 128

    (72) write_listp -> var .

    )               reduce using rule 72 (write_listp -> var .)
    &               reduce using rule 72 (write_listp -> var .)


state 129

    (73) write_listp -> to_str .

    )               reduce using rule 73 (write_listp -> to_str .)
    &               reduce using rule 73 (write_listp -> to_str .)


state 130

    (64) to_num -> TO_NUMBER ( STR . )

    )               shift and go to state 153


state 131

    (65) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 154


state 132

    (66) to_str -> TO_STRING ( expresion . )
    (49) expresion -> expresion . COMP exp

    )               shift and go to state 155
    COMP            shift and go to state 58


state 133

    (74) return -> RET ( expresion . )
    (49) expresion -> expresion . COMP exp

    )               shift and go to state 156
    COMP            shift and go to state 58


state 134

    (46) var -> ID : ID dimension .

    OPFACT          reduce using rule 46 (var -> ID : ID dimension .)
    OPTERM          reduce using rule 46 (var -> ID : ID dimension .)
    ]               reduce using rule 46 (var -> ID : ID dimension .)
    COMP            reduce using rule 46 (var -> ID : ID dimension .)
    )               reduce using rule 46 (var -> ID : ID dimension .)
    ,               reduce using rule 46 (var -> ID : ID dimension .)
    TO              reduce using rule 46 (var -> ID : ID dimension .)
    ;               reduce using rule 46 (var -> ID : ID dimension .)
    {               reduce using rule 46 (var -> ID : ID dimension .)
    =               reduce using rule 46 (var -> ID : ID dimension .)
    &               reduce using rule 46 (var -> ID : ID dimension .)


state 135

    (4) clase -> TYPE ID : ID { cvars funciones } .

    TYPE            reduce using rule 4 (clase -> TYPE ID : ID { cvars funciones } .)
    DEF             reduce using rule 4 (clase -> TYPE ID : ID { cvars funciones } .)
    MAIN            reduce using rule 4 (clase -> TYPE ID : ID { cvars funciones } .)
    FUNC            reduce using rule 4 (clase -> TYPE ID : ID { cvars funciones } .)


state 136

    (13) cvars -> cvars DEF tipo dimension : . lista_id ;
    (15) lista_id -> . ID
    (16) lista_id -> . lista_id , ID

    ID              shift and go to state 46

    lista_id                       shift and go to state 157

state 137

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } END . ;

    ;               shift and go to state 158


state 138

    (32) estatuto -> CALL call_func . ;

    ;               shift and go to state 159


state 139

    (45) asignacion -> var = . expresion ;
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 42
    expresion                      shift and go to state 160
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40

state 140

    (62) while -> WHILE ( . expresion ) DO { estatutos }
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 161
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 141

    (63) for -> FOR expresion . TO expresion { estatutos }
    (49) expresion -> expresion . COMP exp

    TO              shift and go to state 162
    COMP            shift and go to state 58


state 142

    (59) condicion -> IF ( . expresion ) THEN { estatutos } condicionp
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 163
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 143

    (8) funcion -> FUNC ID ( params ) : tipo . { vars estatutos }

    {               shift and go to state 164


state 144

    (9) funcion -> FUNC ID ( params ) : NOTHING . { vars estatutos }

    {               shift and go to state 165


state 145

    (25) pparams -> pparams , tipo ID .

    ,               reduce using rule 25 (pparams -> pparams , tipo ID .)
    )               reduce using rule 25 (pparams -> pparams , tipo ID .)


state 146

    (18) dimension -> [ expresion ] [ expresion ] .

    :               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    OPFACT          reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    OPTERM          reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    ]               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    COMP            reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    )               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    ,               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    TO              reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    ;               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    {               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    =               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)
    &               reduce using rule 18 (dimension -> [ expresion ] [ expresion ] .)


state 147

    (39) func -> ID ( args ) .

    OPFACT          reduce using rule 39 (func -> ID ( args ) .)
    OPTERM          reduce using rule 39 (func -> ID ( args ) .)
    ]               reduce using rule 39 (func -> ID ( args ) .)
    COMP            reduce using rule 39 (func -> ID ( args ) .)
    )               reduce using rule 39 (func -> ID ( args ) .)
    ,               reduce using rule 39 (func -> ID ( args ) .)
    TO              reduce using rule 39 (func -> ID ( args ) .)
    ;               reduce using rule 39 (func -> ID ( args ) .)
    {               reduce using rule 39 (func -> ID ( args ) .)


state 148

    (44) args_list -> args_list , . expresion
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 166
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 149

    (40) func -> ID : ID ( . args )
    (41) args -> . args_list
    (42) args -> . empty
    (43) args_list -> . expresion
    (44) args_list -> . args_list , expresion
    (75) empty -> .
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    )               reduce using rule 75 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 167
    args_list                      shift and go to state 120
    empty                          shift and go to state 121
    expresion                      shift and go to state 122
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 150

    (67) input -> INPUT ( var ) .

    OPFACT          reduce using rule 67 (input -> INPUT ( var ) .)
    OPTERM          reduce using rule 67 (input -> INPUT ( var ) .)
    ]               reduce using rule 67 (input -> INPUT ( var ) .)
    COMP            reduce using rule 67 (input -> INPUT ( var ) .)
    )               reduce using rule 67 (input -> INPUT ( var ) .)
    ,               reduce using rule 67 (input -> INPUT ( var ) .)
    TO              reduce using rule 67 (input -> INPUT ( var ) .)
    ;               reduce using rule 67 (input -> INPUT ( var ) .)
    {               reduce using rule 67 (input -> INPUT ( var ) .)


state 151

    (68) write -> PRINT ( write_list ) .

    OPFACT          reduce using rule 68 (write -> PRINT ( write_list ) .)
    OPTERM          reduce using rule 68 (write -> PRINT ( write_list ) .)
    ]               reduce using rule 68 (write -> PRINT ( write_list ) .)
    COMP            reduce using rule 68 (write -> PRINT ( write_list ) .)
    )               reduce using rule 68 (write -> PRINT ( write_list ) .)
    ,               reduce using rule 68 (write -> PRINT ( write_list ) .)
    TO              reduce using rule 68 (write -> PRINT ( write_list ) .)
    ;               reduce using rule 68 (write -> PRINT ( write_list ) .)
    {               reduce using rule 68 (write -> PRINT ( write_list ) .)


state 152

    (69) write_list -> write_list & . write_listp
    (71) write_listp -> . STR
    (72) write_listp -> . var
    (73) write_listp -> . to_str
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension
    (66) to_str -> . TO_STRING ( expresion )

    STR             shift and go to state 127
    ID              shift and go to state 45
    TO_STRING       shift and go to state 74

    write_listp                    shift and go to state 168
    var                            shift and go to state 128
    to_str                         shift and go to state 129

state 153

    (64) to_num -> TO_NUMBER ( STR ) .

    OPFACT          reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    OPTERM          reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    ]               reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    COMP            reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    )               reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    ,               reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    TO              reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    ;               reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)
    {               reduce using rule 64 (to_num -> TO_NUMBER ( STR ) .)


state 154

    (65) to_num -> TO_NUMBER ( var ) .

    OPFACT          reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    ;               reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 65 (to_num -> TO_NUMBER ( var ) .)


state 155

    (66) to_str -> TO_STRING ( expresion ) .

    OPFACT          reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    ;               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)
    &               reduce using rule 66 (to_str -> TO_STRING ( expresion ) .)


state 156

    (74) return -> RET ( expresion ) .

    OPFACT          reduce using rule 74 (return -> RET ( expresion ) .)
    OPTERM          reduce using rule 74 (return -> RET ( expresion ) .)
    ]               reduce using rule 74 (return -> RET ( expresion ) .)
    COMP            reduce using rule 74 (return -> RET ( expresion ) .)
    )               reduce using rule 74 (return -> RET ( expresion ) .)
    ,               reduce using rule 74 (return -> RET ( expresion ) .)
    TO              reduce using rule 74 (return -> RET ( expresion ) .)
    ;               reduce using rule 74 (return -> RET ( expresion ) .)
    {               reduce using rule 74 (return -> RET ( expresion ) .)


state 157

    (13) cvars -> cvars DEF tipo dimension : lista_id . ;
    (16) lista_id -> lista_id . , ID

    ;               shift and go to state 169
    ,               shift and go to state 79


state 158

    (1) start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } END ; .

    $end            reduce using rule 1 (start -> PROGRAM ID ; clases vars funciones MAIN ( ) { estatutos } END ; .)


state 159

    (32) estatuto -> CALL call_func ; .

    }               reduce using rule 32 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 32 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 32 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 32 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 32 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 32 (estatuto -> CALL call_func ; .)


state 160

    (45) asignacion -> var = expresion . ;
    (49) expresion -> expresion . COMP exp

    ;               shift and go to state 170
    COMP            shift and go to state 58


state 161

    (62) while -> WHILE ( expresion . ) DO { estatutos }
    (49) expresion -> expresion . COMP exp

    )               shift and go to state 171
    COMP            shift and go to state 58


state 162

    (63) for -> FOR expresion TO . expresion { estatutos }
    (48) expresion -> . exp
    (49) expresion -> . expresion COMP exp
    (50) exp -> . term
    (51) exp -> . exp OPTERM term
    (52) term -> . fact
    (53) term -> . term OPFACT fact
    (54) fact -> . ( expresion )
    (55) fact -> . var
    (56) fact -> . NUM
    (57) fact -> . OPTERM NUM
    (58) fact -> . CALL call_func
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 172
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 163

    (59) condicion -> IF ( expresion . ) THEN { estatutos } condicionp
    (49) expresion -> expresion . COMP exp

    )               shift and go to state 173
    COMP            shift and go to state 58


state 164

    (8) funcion -> FUNC ID ( params ) : tipo { . vars estatutos }
    (10) vars -> . vars DEF tipo dimension : lista_id ;
    (11) vars -> . vars DEF ID : lista_id ;
    (12) vars -> . empty
    (75) empty -> .

    DEF             reduce using rule 75 (empty -> .)
    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    vars                           shift and go to state 174
    empty                          shift and go to state 9

state 165

    (9) funcion -> FUNC ID ( params ) : NOTHING { . vars estatutos }
    (10) vars -> . vars DEF tipo dimension : lista_id ;
    (11) vars -> . vars DEF ID : lista_id ;
    (12) vars -> . empty
    (75) empty -> .

    DEF             reduce using rule 75 (empty -> .)
    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    vars                           shift and go to state 175
    empty                          shift and go to state 9

state 166

    (44) args_list -> args_list , expresion .
    (49) expresion -> expresion . COMP exp

    ,               reduce using rule 44 (args_list -> args_list , expresion .)
    )               reduce using rule 44 (args_list -> args_list , expresion .)
    COMP            shift and go to state 58


state 167

    (40) func -> ID : ID ( args . )

    )               shift and go to state 176


state 168

    (69) write_list -> write_list & write_listp .

    )               reduce using rule 69 (write_list -> write_list & write_listp .)
    &               reduce using rule 69 (write_list -> write_list & write_listp .)


state 169

    (13) cvars -> cvars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 13 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 13 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 13 (cvars -> cvars DEF tipo dimension : lista_id ; .)


state 170

    (45) asignacion -> var = expresion ; .

    }               reduce using rule 45 (asignacion -> var = expresion ; .)
    CALL            reduce using rule 45 (asignacion -> var = expresion ; .)
    WHILE           reduce using rule 45 (asignacion -> var = expresion ; .)
    FOR             reduce using rule 45 (asignacion -> var = expresion ; .)
    IF              reduce using rule 45 (asignacion -> var = expresion ; .)
    ID              reduce using rule 45 (asignacion -> var = expresion ; .)


state 171

    (62) while -> WHILE ( expresion ) . DO { estatutos }

    DO              shift and go to state 177


state 172

    (63) for -> FOR expresion TO expresion . { estatutos }
    (49) expresion -> expresion . COMP exp

    {               shift and go to state 178
    COMP            shift and go to state 58


state 173

    (59) condicion -> IF ( expresion ) . THEN { estatutos } condicionp

    THEN            shift and go to state 179


state 174

    (8) funcion -> FUNC ID ( params ) : tipo { vars . estatutos }
    (10) vars -> vars . DEF tipo dimension : lista_id ;
    (11) vars -> vars . DEF ID : lista_id ;
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    DEF             shift and go to state 12
    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 180
    empty                          shift and go to state 84

state 175

    (9) funcion -> FUNC ID ( params ) : NOTHING { vars . estatutos }
    (10) vars -> vars . DEF tipo dimension : lista_id ;
    (11) vars -> vars . DEF ID : lista_id ;
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    DEF             shift and go to state 12
    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 181
    empty                          shift and go to state 84

state 176

    (40) func -> ID : ID ( args ) .

    OPFACT          reduce using rule 40 (func -> ID : ID ( args ) .)
    OPTERM          reduce using rule 40 (func -> ID : ID ( args ) .)
    ]               reduce using rule 40 (func -> ID : ID ( args ) .)
    COMP            reduce using rule 40 (func -> ID : ID ( args ) .)
    )               reduce using rule 40 (func -> ID : ID ( args ) .)
    ,               reduce using rule 40 (func -> ID : ID ( args ) .)
    TO              reduce using rule 40 (func -> ID : ID ( args ) .)
    ;               reduce using rule 40 (func -> ID : ID ( args ) .)
    {               reduce using rule 40 (func -> ID : ID ( args ) .)


state 177

    (62) while -> WHILE ( expresion ) DO . { estatutos }

    {               shift and go to state 182


state 178

    (63) for -> FOR expresion TO expresion { . estatutos }
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 183
    empty                          shift and go to state 84

state 179

    (59) condicion -> IF ( expresion ) THEN . { estatutos } condicionp

    {               shift and go to state 184


state 180

    (8) funcion -> FUNC ID ( params ) : tipo { vars estatutos . }
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 185
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 181

    (9) funcion -> FUNC ID ( params ) : NOTHING { vars estatutos . }
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 186
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 182

    (62) while -> WHILE ( expresion ) DO { . estatutos }
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 187
    empty                          shift and go to state 84

state 183

    (63) for -> FOR expresion TO expresion { estatutos . }
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 188
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 184

    (59) condicion -> IF ( expresion ) THEN { . estatutos } condicionp
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 189
    empty                          shift and go to state 84

state 185

    (8) funcion -> FUNC ID ( params ) : tipo { vars estatutos } .

    MAIN            reduce using rule 8 (funcion -> FUNC ID ( params ) : tipo { vars estatutos } .)
    FUNC            reduce using rule 8 (funcion -> FUNC ID ( params ) : tipo { vars estatutos } .)
    }               reduce using rule 8 (funcion -> FUNC ID ( params ) : tipo { vars estatutos } .)


state 186

    (9) funcion -> FUNC ID ( params ) : NOTHING { vars estatutos } .

    MAIN            reduce using rule 9 (funcion -> FUNC ID ( params ) : NOTHING { vars estatutos } .)
    FUNC            reduce using rule 9 (funcion -> FUNC ID ( params ) : NOTHING { vars estatutos } .)
    }               reduce using rule 9 (funcion -> FUNC ID ( params ) : NOTHING { vars estatutos } .)


state 187

    (62) while -> WHILE ( expresion ) DO { estatutos . }
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 190
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 188

    (63) for -> FOR expresion TO expresion { estatutos } .

    }               reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)
    CALL            reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)
    WHILE           reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)
    FOR             reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)
    IF              reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)
    ID              reduce using rule 63 (for -> FOR expresion TO expresion { estatutos } .)


state 189

    (59) condicion -> IF ( expresion ) THEN { estatutos . } condicionp
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 191
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 190

    (62) while -> WHILE ( expresion ) DO { estatutos } .

    }               reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)
    CALL            reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)
    WHILE           reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)
    FOR             reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)
    IF              reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)
    ID              reduce using rule 62 (while -> WHILE ( expresion ) DO { estatutos } .)


state 191

    (59) condicion -> IF ( expresion ) THEN { estatutos } . condicionp
    (60) condicionp -> . ELSE { estatutos }
    (61) condicionp -> . empty
    (75) empty -> .

    ELSE            shift and go to state 193
    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    condicionp                     shift and go to state 192
    empty                          shift and go to state 194

state 192

    (59) condicion -> IF ( expresion ) THEN { estatutos } condicionp .

    }               reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    CALL            reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    WHILE           reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    FOR             reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    IF              reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    ID              reduce using rule 59 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)


state 193

    (60) condicionp -> ELSE . { estatutos }

    {               shift and go to state 195


state 194

    (61) condicionp -> empty .

    }               reduce using rule 61 (condicionp -> empty .)
    CALL            reduce using rule 61 (condicionp -> empty .)
    WHILE           reduce using rule 61 (condicionp -> empty .)
    FOR             reduce using rule 61 (condicionp -> empty .)
    IF              reduce using rule 61 (condicionp -> empty .)
    ID              reduce using rule 61 (condicionp -> empty .)


state 195

    (60) condicionp -> ELSE { . estatutos }
    (26) estatutos -> . estatutos estatuto
    (27) estatutos -> . empty
    (75) empty -> .

    }               reduce using rule 75 (empty -> .)
    CALL            reduce using rule 75 (empty -> .)
    WHILE           reduce using rule 75 (empty -> .)
    FOR             reduce using rule 75 (empty -> .)
    IF              reduce using rule 75 (empty -> .)
    ID              reduce using rule 75 (empty -> .)

    estatutos                      shift and go to state 196
    empty                          shift and go to state 84

state 196

    (60) condicionp -> ELSE { estatutos . }
    (26) estatutos -> estatutos . estatuto
    (28) estatuto -> . asignacion
    (29) estatuto -> . while
    (30) estatuto -> . for
    (31) estatuto -> . condicion
    (32) estatuto -> . CALL call_func ;
    (45) asignacion -> . var = expresion ;
    (62) while -> . WHILE ( expresion ) DO { estatutos }
    (63) for -> . FOR expresion TO expresion { estatutos }
    (59) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (46) var -> . ID : ID dimension
    (47) var -> . ID dimension

    }               shift and go to state 197
    CALL            shift and go to state 111
    WHILE           shift and go to state 113
    FOR             shift and go to state 114
    IF              shift and go to state 115
    ID              shift and go to state 45

    estatuto                       shift and go to state 106
    asignacion                     shift and go to state 107
    while                          shift and go to state 108
    for                            shift and go to state 109
    condicion                      shift and go to state 110
    var                            shift and go to state 112

state 197

    (60) condicionp -> ELSE { estatutos } .

    }               reduce using rule 60 (condicionp -> ELSE { estatutos } .)
    CALL            reduce using rule 60 (condicionp -> ELSE { estatutos } .)
    WHILE           reduce using rule 60 (condicionp -> ELSE { estatutos } .)
    FOR             reduce using rule 60 (condicionp -> ELSE { estatutos } .)
    IF              reduce using rule 60 (condicionp -> ELSE { estatutos } .)
    ID              reduce using rule 60 (condicionp -> ELSE { estatutos } .)

