Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
Rule 2     f_start -> <empty>
Rule 3     f_prog -> <empty>
Rule 4     f_main -> <empty>
Rule 5     f_end -> <empty>
Rule 6     clases -> clases clase
Rule 7     clases -> empty
Rule 8     clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
Rule 9     clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
Rule 10    f_startclass -> <empty>
Rule 11    f_clasepadre -> <empty>
Rule 12    f_cvars -> <empty>
Rule 13    f_endclass -> <empty>
Rule 14    funciones -> funciones funcion
Rule 15    funciones -> empty
Rule 16    funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
Rule 17    funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
Rule 18    f_startfunc -> <empty>
Rule 19    f_nothing -> <empty>
Rule 20    f_tipofunc -> <empty>
Rule 21    f_endfunc -> <empty>
Rule 22    vars -> vars DEF tipo dimension : lista_id ;
Rule 23    vars -> vars DEF ID f_varsobj : lista_id ;
Rule 24    vars -> empty
Rule 25    f_varsobj -> <empty>
Rule 26    cvars -> cvars DEF tipo dimension : lista_id ;
Rule 27    cvars -> empty
Rule 28    lista_id -> ID f_vars
Rule 29    lista_id -> lista_id , ID f_vars
Rule 30    f_vars -> <empty>
Rule 31    dimension -> [ NUM f_dim1 ] f_onedim
Rule 32    dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
Rule 33    dimension -> empty
Rule 34    f_dim1 -> <empty>
Rule 35    f_dim2 -> <empty>
Rule 36    f_onedim -> <empty>
Rule 37    f_twodim -> <empty>
Rule 38    tipo -> NUMBER
Rule 39    tipo -> STRING
Rule 40    params -> pparams
Rule 41    params -> empty
Rule 42    pparams -> tipo ID f_param
Rule 43    pparams -> pparams , tipo ID f_param
Rule 44    f_param -> <empty>
Rule 45    estatutos -> estatutos estatuto
Rule 46    estatutos -> empty
Rule 47    estatuto -> asignacion
Rule 48    estatuto -> while
Rule 49    estatuto -> for
Rule 50    estatuto -> condicion
Rule 51    estatuto -> CALL call_func ;
Rule 52    call_func -> func
Rule 53    call_func -> input
Rule 54    call_func -> write
Rule 55    call_func -> to_num
Rule 56    call_func -> to_str
Rule 57    call_func -> return
Rule 58    func -> ID f_verify_func ( args )
Rule 59    func -> ID f_varobj : ID f_verify_func_composite ( args )
Rule 60    f_verify_func -> <empty>
Rule 61    f_verify_func_composite -> <empty>
Rule 62    args -> args_list
Rule 63    args -> empty
Rule 64    args_list -> expresion
Rule 65    args_list -> args_list , expresion
Rule 66    asignacion -> var = f_oper expresion ;
Rule 67    var -> ID f_varobj : ID f_verify_type_composite indexacion
Rule 68    var -> ID f_verify_type indexacion
Rule 69    indexacion -> [ expresion ]
Rule 70    indexacion -> [ expresion ] [ expresion ]
Rule 71    indexacion -> empty
Rule 72    f_varobj -> <empty>
Rule 73    f_verify_type -> <empty>
Rule 74    f_verify_type_composite -> <empty>
Rule 75    expresion -> exp
Rule 76    expresion -> expresion COMP f_oper exp f_expres
Rule 77    f_expres -> <empty>
Rule 78    exp -> term
Rule 79    exp -> exp OPTERM f_oper term f_exp
Rule 80    f_exp -> <empty>
Rule 81    term -> fact
Rule 82    term -> term OPFACT f_oper fact f_term
Rule 83    f_term -> <empty>
Rule 84    f_oper -> <empty>
Rule 85    fact -> ( lparen expresion ) rparen
Rule 86    fact -> var
Rule 87    fact -> NUM f_fact
Rule 88    fact -> OPTERM NUM
Rule 89    fact -> CALL call_func
Rule 90    lparen -> <empty>
Rule 91    rparen -> <empty>
Rule 92    f_fact -> <empty>
Rule 93    condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
Rule 94    condicionp -> ELSE f_else { estatutos }
Rule 95    condicionp -> empty
Rule 96    f_if -> <empty>
Rule 97    f_endif -> <empty>
Rule 98    f_else -> <empty>
Rule 99    while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
Rule 100   f_while -> <empty>
Rule 101   f_exprwhile -> <empty>
Rule 102   f_endwhile -> <empty>
Rule 103   for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
Rule 104   f_for_start -> <empty>
Rule 105   f_for_to -> <empty>
Rule 106   f_for_end -> <empty>
Rule 107   to_num -> TO_NUMBER ( STR )
Rule 108   to_num -> TO_NUMBER ( var )
Rule 109   to_str -> TO_STRING ( expresion )
Rule 110   input -> INPUT ( var )
Rule 111   write -> PRINT ( write_list )
Rule 112   write_list -> write_list & write_listp
Rule 113   write_list -> write_listp
Rule 114   write_listp -> STR
Rule 115   write_listp -> var
Rule 116   write_listp -> CALL to_str
Rule 117   return -> RET ( expresion )
Rule 118   empty -> <empty>

Terminals, with rules where they appear

&                    : 112
(                    : 1 16 17 58 59 85 93 99 107 108 109 110 111 117
)                    : 1 16 17 58 59 85 93 99 107 108 109 110 111 117
,                    : 29 43 65
:                    : 8 16 17 22 23 26 59 67
;                    : 1 1 22 23 26 51 66
=                    : 66
CALL                 : 51 89 116
COMP                 : 76
DEF                  : 22 23 26
DO                   : 99
ELSE                 : 94
END                  : 1
FOR                  : 103
FUNC                 : 16 17
ID                   : 1 8 8 9 16 17 23 28 29 42 43 58 59 59 67 67 68
IF                   : 93
INPUT                : 110
MAIN                 : 1
NOTHING              : 17
NUM                  : 31 32 32 87 88
NUMBER               : 38
OPFACT               : 82
OPTERM               : 79 88
PRINT                : 111
PROGRAM              : 1
RET                  : 117
STR                  : 107 114
STRING               : 39
THEN                 : 93
TO                   : 103
TO_NUMBER            : 107 108
TO_STRING            : 109
TYPE                 : 8 9
WHILE                : 99
[                    : 31 32 32 69 70 70
]                    : 31 32 32 69 70 70
error                : 
{                    : 1 8 9 16 17 93 94 99 103
}                    : 1 8 9 16 17 93 94 99 103

Nonterminals, with rules where they appear

args                 : 58 59
args_list            : 62 65
asignacion           : 47
call_func            : 51 89
clase                : 6
clases               : 1 6
condicion            : 50
condicionp           : 93
cvars                : 8 9 26
dimension            : 22 26
empty                : 7 15 24 27 33 41 46 63 71 95
estatuto             : 45
estatutos            : 1 16 17 45 93 94 99 103
exp                  : 75 76 79
expresion            : 64 65 66 69 70 70 76 85 93 99 103 103 109 117
f_clasepadre         : 8
f_cvars              : 8 9
f_dim1               : 31 32
f_dim2               : 32
f_else               : 94
f_end                : 1
f_endclass           : 8 9
f_endfunc            : 16 17
f_endif              : 93
f_endwhile           : 99
f_exp                : 79
f_expres             : 76
f_exprwhile          : 99
f_fact               : 87
f_for_end            : 103
f_for_start          : 103
f_for_to             : 103
f_if                 : 93
f_main               : 1
f_nothing            : 17
f_onedim             : 31
f_oper               : 66 76 79 82
f_param              : 42 43
f_prog               : 1
f_start              : 1
f_startclass         : 8 9
f_startfunc          : 16 17
f_term               : 82
f_tipofunc           : 16 17
f_twodim             : 32
f_varobj             : 59 67
f_vars               : 28 29
f_varsobj            : 23
f_verify_func        : 58
f_verify_func_composite : 59
f_verify_type        : 68
f_verify_type_composite : 67
f_while              : 99
fact                 : 81 82
for                  : 49
func                 : 52
funcion              : 14
funciones            : 1 8 9 14
indexacion           : 67 68
input                : 53
lista_id             : 22 23 26 29
lparen               : 85
params               : 16 17
pparams              : 40 43
return               : 57
rparen               : 85
start                : 0
term                 : 78 79 82
tipo                 : 16 22 26 42 43
to_num               : 55
to_str               : 56 116
var                  : 66 86 108 110 115
vars                 : 1 16 17 22 23
while                : 48
write                : 54
write_list           : 111 112
write_listp          : 112 113

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (2) f_start -> .

    ID              reduce using rule 2 (f_start -> .)

    f_start                        shift and go to state 3

state 3

    (1) start -> PROGRAM f_start . ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ID              shift and go to state 4


state 4

    (1) start -> PROGRAM f_start ID . f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (3) f_prog -> .

    ;               reduce using rule 3 (f_prog -> .)

    f_prog                         shift and go to state 5

state 5

    (1) start -> PROGRAM f_start ID f_prog . ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ;               shift and go to state 6


state 6

    (1) start -> PROGRAM f_start ID f_prog ; . clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> . clases clase
    (7) clases -> . empty
    (118) empty -> .

    TYPE            reduce using rule 118 (empty -> .)
    DEF             reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    clases                         shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) start -> PROGRAM f_start ID f_prog ; clases . vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> clases . clase
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (8) clase -> . TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> . TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
    (118) empty -> .

    TYPE            shift and go to state 12
    DEF             reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    vars                           shift and go to state 9
    clase                          shift and go to state 10
    empty                          shift and go to state 11

state 8

    (7) clases -> empty .

    TYPE            reduce using rule 7 (clases -> empty .)
    DEF             reduce using rule 7 (clases -> empty .)
    MAIN            reduce using rule 7 (clases -> empty .)
    FUNC            reduce using rule 7 (clases -> empty .)


state 9

    (1) start -> PROGRAM f_start ID f_prog ; clases vars . funciones MAIN f_main ( ) { estatutos } END f_end ;
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (118) empty -> .

    DEF             shift and go to state 14
    MAIN            reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    funciones                      shift and go to state 13
    empty                          shift and go to state 15

state 10

    (6) clases -> clases clase .

    TYPE            reduce using rule 6 (clases -> clases clase .)
    DEF             reduce using rule 6 (clases -> clases clase .)
    MAIN            reduce using rule 6 (clases -> clases clase .)
    FUNC            reduce using rule 6 (clases -> clases clase .)


state 11

    (24) vars -> empty .

    DEF             reduce using rule 24 (vars -> empty .)
    MAIN            reduce using rule 24 (vars -> empty .)
    FUNC            reduce using rule 24 (vars -> empty .)
    }               reduce using rule 24 (vars -> empty .)
    CALL            reduce using rule 24 (vars -> empty .)
    WHILE           reduce using rule 24 (vars -> empty .)
    FOR             reduce using rule 24 (vars -> empty .)
    IF              reduce using rule 24 (vars -> empty .)
    ID              reduce using rule 24 (vars -> empty .)


state 12

    (8) clase -> TYPE . ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE . ID f_startclass { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 16


state 13

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones . MAIN f_main ( ) { estatutos } END f_end ;
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    MAIN            shift and go to state 17
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 14

    (22) vars -> vars DEF . tipo dimension : lista_id ;
    (23) vars -> vars DEF . ID f_varsobj : lista_id ;
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    ID              shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 20

state 15

    (15) funciones -> empty .

    MAIN            reduce using rule 15 (funciones -> empty .)
    FUNC            reduce using rule 15 (funciones -> empty .)
    }               reduce using rule 15 (funciones -> empty .)


state 16

    (8) clase -> TYPE ID . f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID . f_startclass { cvars f_cvars funciones } f_endclass
    (10) f_startclass -> .

    :               reduce using rule 10 (f_startclass -> .)
    {               reduce using rule 10 (f_startclass -> .)

    f_startclass                   shift and go to state 24

state 17

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN . f_main ( ) { estatutos } END f_end ;
    (4) f_main -> .

    (               reduce using rule 4 (f_main -> .)

    f_main                         shift and go to state 25

state 18

    (14) funciones -> funciones funcion .

    MAIN            reduce using rule 14 (funciones -> funciones funcion .)
    FUNC            reduce using rule 14 (funciones -> funciones funcion .)
    }               reduce using rule 14 (funciones -> funciones funcion .)


state 19

    (16) funcion -> FUNC . ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC . ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    ID              shift and go to state 26


state 20

    (22) vars -> vars DEF tipo . dimension : lista_id ;
    (31) dimension -> . [ NUM f_dim1 ] f_onedim
    (32) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
    (33) dimension -> . empty
    (118) empty -> .

    [               shift and go to state 28
    :               reduce using rule 118 (empty -> .)

    dimension                      shift and go to state 27
    empty                          shift and go to state 29

state 21

    (23) vars -> vars DEF ID . f_varsobj : lista_id ;
    (25) f_varsobj -> .

    :               reduce using rule 25 (f_varsobj -> .)

    f_varsobj                      shift and go to state 30

state 22

    (38) tipo -> NUMBER .

    [               reduce using rule 38 (tipo -> NUMBER .)
    :               reduce using rule 38 (tipo -> NUMBER .)
    ID              reduce using rule 38 (tipo -> NUMBER .)
    {               reduce using rule 38 (tipo -> NUMBER .)


state 23

    (39) tipo -> STRING .

    [               reduce using rule 39 (tipo -> STRING .)
    :               reduce using rule 39 (tipo -> STRING .)
    ID              reduce using rule 39 (tipo -> STRING .)
    {               reduce using rule 39 (tipo -> STRING .)


state 24

    (8) clase -> TYPE ID f_startclass . : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID f_startclass . { cvars f_cvars funciones } f_endclass

    :               shift and go to state 31
    {               shift and go to state 32


state 25

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main . ( ) { estatutos } END f_end ;

    (               shift and go to state 33


state 26

    (16) funcion -> FUNC ID . f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID . f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (18) f_startfunc -> .

    (               reduce using rule 18 (f_startfunc -> .)

    f_startfunc                    shift and go to state 34

state 27

    (22) vars -> vars DEF tipo dimension . : lista_id ;

    :               shift and go to state 35


state 28

    (31) dimension -> [ . NUM f_dim1 ] f_onedim
    (32) dimension -> [ . NUM f_dim1 ] [ NUM f_dim2 ] f_twodim

    NUM             shift and go to state 36


state 29

    (33) dimension -> empty .

    :               reduce using rule 33 (dimension -> empty .)


state 30

    (23) vars -> vars DEF ID f_varsobj . : lista_id ;

    :               shift and go to state 37


state 31

    (8) clase -> TYPE ID f_startclass : . ID f_clasepadre { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 38


state 32

    (9) clase -> TYPE ID f_startclass { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (118) empty -> .

    DEF             reduce using rule 118 (empty -> .)
    }               reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    cvars                          shift and go to state 39
    empty                          shift and go to state 40

state 33

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( . ) { estatutos } END f_end ;

    )               shift and go to state 41


state 34

    (16) funcion -> FUNC ID f_startfunc . ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc . ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    (               shift and go to state 42


state 35

    (22) vars -> vars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 43

state 36

    (31) dimension -> [ NUM . f_dim1 ] f_onedim
    (32) dimension -> [ NUM . f_dim1 ] [ NUM f_dim2 ] f_twodim
    (34) f_dim1 -> .

    ]               reduce using rule 34 (f_dim1 -> .)

    f_dim1                         shift and go to state 45

state 37

    (23) vars -> vars DEF ID f_varsobj : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 46

state 38

    (8) clase -> TYPE ID f_startclass : ID . f_clasepadre { cvars f_cvars funciones } f_endclass
    (11) f_clasepadre -> .

    {               reduce using rule 11 (f_clasepadre -> .)

    f_clasepadre                   shift and go to state 47

state 39

    (9) clase -> TYPE ID f_startclass { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 49
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 48

state 40

    (27) cvars -> empty .

    DEF             reduce using rule 27 (cvars -> empty .)
    }               reduce using rule 27 (cvars -> empty .)
    FUNC            reduce using rule 27 (cvars -> empty .)


state 41

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) . { estatutos } END f_end ;

    {               shift and go to state 50


state 42

    (16) funcion -> FUNC ID f_startfunc ( . params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( . params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (40) params -> . pparams
    (41) params -> . empty
    (42) pparams -> . tipo ID f_param
    (43) pparams -> . pparams , tipo ID f_param
    (118) empty -> .
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    )               reduce using rule 118 (empty -> .)
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    params                         shift and go to state 51
    tipo                           shift and go to state 52
    pparams                        shift and go to state 53
    empty                          shift and go to state 54

state 43

    (22) vars -> vars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 55
    ,               shift and go to state 56


state 44

    (28) lista_id -> ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 57

state 45

    (31) dimension -> [ NUM f_dim1 . ] f_onedim
    (32) dimension -> [ NUM f_dim1 . ] [ NUM f_dim2 ] f_twodim

    ]               shift and go to state 58


state 46

    (23) vars -> vars DEF ID f_varsobj : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 59
    ,               shift and go to state 56


state 47

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre . { cvars f_cvars funciones } f_endclass

    {               shift and go to state 60


state 48

    (9) clase -> TYPE ID f_startclass { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    funciones                      shift and go to state 61
    empty                          shift and go to state 15

state 49

    (26) cvars -> cvars DEF . tipo dimension : lista_id ;
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 62

state 50

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { . estatutos } END f_end ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 63
    empty                          shift and go to state 64

state 51

    (16) funcion -> FUNC ID f_startfunc ( params . ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params . ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    )               shift and go to state 65


state 52

    (42) pparams -> tipo . ID f_param

    ID              shift and go to state 66


state 53

    (40) params -> pparams .
    (43) pparams -> pparams . , tipo ID f_param

    )               reduce using rule 40 (params -> pparams .)
    ,               shift and go to state 67


state 54

    (41) params -> empty .

    )               reduce using rule 41 (params -> empty .)


state 55

    (22) vars -> vars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    MAIN            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    CALL            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    WHILE           reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FOR             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    IF              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    ID              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)


state 56

    (29) lista_id -> lista_id , . ID f_vars

    ID              shift and go to state 68


state 57

    (28) lista_id -> ID f_vars .

    ;               reduce using rule 28 (lista_id -> ID f_vars .)
    ,               reduce using rule 28 (lista_id -> ID f_vars .)


state 58

    (31) dimension -> [ NUM f_dim1 ] . f_onedim
    (32) dimension -> [ NUM f_dim1 ] . [ NUM f_dim2 ] f_twodim
    (36) f_onedim -> .

    [               shift and go to state 69
    :               reduce using rule 36 (f_onedim -> .)

    f_onedim                       shift and go to state 70

state 59

    (23) vars -> vars DEF ID f_varsobj : lista_id ; .

    DEF             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    MAIN            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FUNC            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    }               reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    CALL            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    WHILE           reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FOR             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    IF              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    ID              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)


state 60

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (118) empty -> .

    DEF             reduce using rule 118 (empty -> .)
    }               reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    cvars                          shift and go to state 71
    empty                          shift and go to state 40

state 61

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 72
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 62

    (26) cvars -> cvars DEF tipo . dimension : lista_id ;
    (31) dimension -> . [ NUM f_dim1 ] f_onedim
    (32) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
    (33) dimension -> . empty
    (118) empty -> .

    [               shift and go to state 28
    :               reduce using rule 118 (empty -> .)

    dimension                      shift and go to state 73
    empty                          shift and go to state 29

state 63

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos . } END f_end ;
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 75
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 64

    (46) estatutos -> empty .

    }               reduce using rule 46 (estatutos -> empty .)
    CALL            reduce using rule 46 (estatutos -> empty .)
    WHILE           reduce using rule 46 (estatutos -> empty .)
    FOR             reduce using rule 46 (estatutos -> empty .)
    IF              reduce using rule 46 (estatutos -> empty .)
    ID              reduce using rule 46 (estatutos -> empty .)


state 65

    (16) funcion -> FUNC ID f_startfunc ( params ) . : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) . : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    :               shift and go to state 86


state 66

    (42) pparams -> tipo ID . f_param
    (44) f_param -> .

    ,               reduce using rule 44 (f_param -> .)
    )               reduce using rule 44 (f_param -> .)

    f_param                        shift and go to state 87

state 67

    (43) pparams -> pparams , . tipo ID f_param
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 88

state 68

    (29) lista_id -> lista_id , ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 89

state 69

    (32) dimension -> [ NUM f_dim1 ] [ . NUM f_dim2 ] f_twodim

    NUM             shift and go to state 90


state 70

    (31) dimension -> [ NUM f_dim1 ] f_onedim .

    :               reduce using rule 31 (dimension -> [ NUM f_dim1 ] f_onedim .)


state 71

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 49
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 91

state 72

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 92

state 73

    (26) cvars -> cvars DEF tipo dimension . : lista_id ;

    :               shift and go to state 93


state 74

    (67) var -> ID . f_varobj : ID f_verify_type_composite indexacion
    (68) var -> ID . f_verify_type indexacion
    (72) f_varobj -> .
    (73) f_verify_type -> .

    :               reduce using rule 72 (f_varobj -> .)
    [               reduce using rule 73 (f_verify_type -> .)
    =               reduce using rule 73 (f_verify_type -> .)
    OPFACT          reduce using rule 73 (f_verify_type -> .)
    OPTERM          reduce using rule 73 (f_verify_type -> .)
    COMP            reduce using rule 73 (f_verify_type -> .)
    TO              reduce using rule 73 (f_verify_type -> .)
    )               reduce using rule 73 (f_verify_type -> .)
    ]               reduce using rule 73 (f_verify_type -> .)
    &               reduce using rule 73 (f_verify_type -> .)
    ;               reduce using rule 73 (f_verify_type -> .)
    ,               reduce using rule 73 (f_verify_type -> .)
    {               reduce using rule 73 (f_verify_type -> .)

    f_varobj                       shift and go to state 94
    f_verify_type                  shift and go to state 95

state 75

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } . END f_end ;

    END             shift and go to state 96


state 76

    (45) estatutos -> estatutos estatuto .

    }               reduce using rule 45 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 45 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 45 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 45 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 45 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 45 (estatutos -> estatutos estatuto .)


state 77

    (47) estatuto -> asignacion .

    }               reduce using rule 47 (estatuto -> asignacion .)
    CALL            reduce using rule 47 (estatuto -> asignacion .)
    WHILE           reduce using rule 47 (estatuto -> asignacion .)
    FOR             reduce using rule 47 (estatuto -> asignacion .)
    IF              reduce using rule 47 (estatuto -> asignacion .)
    ID              reduce using rule 47 (estatuto -> asignacion .)


state 78

    (48) estatuto -> while .

    }               reduce using rule 48 (estatuto -> while .)
    CALL            reduce using rule 48 (estatuto -> while .)
    WHILE           reduce using rule 48 (estatuto -> while .)
    FOR             reduce using rule 48 (estatuto -> while .)
    IF              reduce using rule 48 (estatuto -> while .)
    ID              reduce using rule 48 (estatuto -> while .)


state 79

    (49) estatuto -> for .

    }               reduce using rule 49 (estatuto -> for .)
    CALL            reduce using rule 49 (estatuto -> for .)
    WHILE           reduce using rule 49 (estatuto -> for .)
    FOR             reduce using rule 49 (estatuto -> for .)
    IF              reduce using rule 49 (estatuto -> for .)
    ID              reduce using rule 49 (estatuto -> for .)


state 80

    (50) estatuto -> condicion .

    }               reduce using rule 50 (estatuto -> condicion .)
    CALL            reduce using rule 50 (estatuto -> condicion .)
    WHILE           reduce using rule 50 (estatuto -> condicion .)
    FOR             reduce using rule 50 (estatuto -> condicion .)
    IF              reduce using rule 50 (estatuto -> condicion .)
    ID              reduce using rule 50 (estatuto -> condicion .)


state 81

    (51) estatuto -> CALL . call_func ;
    (52) call_func -> . func
    (53) call_func -> . input
    (54) call_func -> . write
    (55) call_func -> . to_num
    (56) call_func -> . to_str
    (57) call_func -> . return
    (58) func -> . ID f_verify_func ( args )
    (59) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (110) input -> . INPUT ( var )
    (111) write -> . PRINT ( write_list )
    (107) to_num -> . TO_NUMBER ( STR )
    (108) to_num -> . TO_NUMBER ( var )
    (109) to_str -> . TO_STRING ( expresion )
    (117) return -> . RET ( expresion )

    ID              shift and go to state 104
    INPUT           shift and go to state 105
    PRINT           shift and go to state 106
    TO_NUMBER       shift and go to state 107
    TO_STRING       shift and go to state 108
    RET             shift and go to state 109

    call_func                      shift and go to state 97
    func                           shift and go to state 98
    input                          shift and go to state 99
    write                          shift and go to state 100
    to_num                         shift and go to state 101
    to_str                         shift and go to state 102
    return                         shift and go to state 103

state 82

    (66) asignacion -> var . = f_oper expresion ;

    =               shift and go to state 110


state 83

    (99) while -> WHILE . f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) f_while -> .

    (               reduce using rule 100 (f_while -> .)

    f_while                        shift and go to state 111

state 84

    (103) for -> FOR . expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 85

    (93) condicion -> IF . ( expresion ) f_if THEN { estatutos } condicionp f_endif

    (               shift and go to state 121


state 86

    (16) funcion -> FUNC ID f_startfunc ( params ) : . tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) : . NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NOTHING         shift and go to state 123
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 122

state 87

    (42) pparams -> tipo ID f_param .

    ,               reduce using rule 42 (pparams -> tipo ID f_param .)
    )               reduce using rule 42 (pparams -> tipo ID f_param .)


state 88

    (43) pparams -> pparams , tipo . ID f_param

    ID              shift and go to state 124


state 89

    (29) lista_id -> lista_id , ID f_vars .

    ;               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)
    ,               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)


state 90

    (32) dimension -> [ NUM f_dim1 ] [ NUM . f_dim2 ] f_twodim
    (35) f_dim2 -> .

    ]               reduce using rule 35 (f_dim2 -> .)

    f_dim2                         shift and go to state 125

state 91

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    FUNC            reduce using rule 118 (empty -> .)

    funciones                      shift and go to state 126
    empty                          shift and go to state 15

state 92

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)


state 93

    (26) cvars -> cvars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 127

state 94

    (67) var -> ID f_varobj . : ID f_verify_type_composite indexacion

    :               shift and go to state 128


state 95

    (68) var -> ID f_verify_type . indexacion
    (69) indexacion -> . [ expresion ]
    (70) indexacion -> . [ expresion ] [ expresion ]
    (71) indexacion -> . empty
    (118) empty -> .

    [               shift and go to state 130
    =               reduce using rule 118 (empty -> .)
    OPFACT          reduce using rule 118 (empty -> .)
    OPTERM          reduce using rule 118 (empty -> .)
    COMP            reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    )               reduce using rule 118 (empty -> .)
    ]               reduce using rule 118 (empty -> .)
    &               reduce using rule 118 (empty -> .)
    ;               reduce using rule 118 (empty -> .)
    ,               reduce using rule 118 (empty -> .)
    {               reduce using rule 118 (empty -> .)

    indexacion                     shift and go to state 129
    empty                          shift and go to state 131

state 96

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END . f_end ;
    (5) f_end -> .

    ;               reduce using rule 5 (f_end -> .)

    f_end                          shift and go to state 132

state 97

    (51) estatuto -> CALL call_func . ;

    ;               shift and go to state 133


state 98

    (52) call_func -> func .

    ;               reduce using rule 52 (call_func -> func .)
    OPFACT          reduce using rule 52 (call_func -> func .)
    OPTERM          reduce using rule 52 (call_func -> func .)
    COMP            reduce using rule 52 (call_func -> func .)
    TO              reduce using rule 52 (call_func -> func .)
    )               reduce using rule 52 (call_func -> func .)
    ]               reduce using rule 52 (call_func -> func .)
    ,               reduce using rule 52 (call_func -> func .)
    {               reduce using rule 52 (call_func -> func .)


state 99

    (53) call_func -> input .

    ;               reduce using rule 53 (call_func -> input .)
    OPFACT          reduce using rule 53 (call_func -> input .)
    OPTERM          reduce using rule 53 (call_func -> input .)
    COMP            reduce using rule 53 (call_func -> input .)
    TO              reduce using rule 53 (call_func -> input .)
    )               reduce using rule 53 (call_func -> input .)
    ]               reduce using rule 53 (call_func -> input .)
    ,               reduce using rule 53 (call_func -> input .)
    {               reduce using rule 53 (call_func -> input .)


state 100

    (54) call_func -> write .

    ;               reduce using rule 54 (call_func -> write .)
    OPFACT          reduce using rule 54 (call_func -> write .)
    OPTERM          reduce using rule 54 (call_func -> write .)
    COMP            reduce using rule 54 (call_func -> write .)
    TO              reduce using rule 54 (call_func -> write .)
    )               reduce using rule 54 (call_func -> write .)
    ]               reduce using rule 54 (call_func -> write .)
    ,               reduce using rule 54 (call_func -> write .)
    {               reduce using rule 54 (call_func -> write .)


state 101

    (55) call_func -> to_num .

    ;               reduce using rule 55 (call_func -> to_num .)
    OPFACT          reduce using rule 55 (call_func -> to_num .)
    OPTERM          reduce using rule 55 (call_func -> to_num .)
    COMP            reduce using rule 55 (call_func -> to_num .)
    TO              reduce using rule 55 (call_func -> to_num .)
    )               reduce using rule 55 (call_func -> to_num .)
    ]               reduce using rule 55 (call_func -> to_num .)
    ,               reduce using rule 55 (call_func -> to_num .)
    {               reduce using rule 55 (call_func -> to_num .)


state 102

    (56) call_func -> to_str .

    ;               reduce using rule 56 (call_func -> to_str .)
    OPFACT          reduce using rule 56 (call_func -> to_str .)
    OPTERM          reduce using rule 56 (call_func -> to_str .)
    COMP            reduce using rule 56 (call_func -> to_str .)
    TO              reduce using rule 56 (call_func -> to_str .)
    )               reduce using rule 56 (call_func -> to_str .)
    ]               reduce using rule 56 (call_func -> to_str .)
    ,               reduce using rule 56 (call_func -> to_str .)
    {               reduce using rule 56 (call_func -> to_str .)


state 103

    (57) call_func -> return .

    ;               reduce using rule 57 (call_func -> return .)
    OPFACT          reduce using rule 57 (call_func -> return .)
    OPTERM          reduce using rule 57 (call_func -> return .)
    COMP            reduce using rule 57 (call_func -> return .)
    TO              reduce using rule 57 (call_func -> return .)
    )               reduce using rule 57 (call_func -> return .)
    ]               reduce using rule 57 (call_func -> return .)
    ,               reduce using rule 57 (call_func -> return .)
    {               reduce using rule 57 (call_func -> return .)


state 104

    (58) func -> ID . f_verify_func ( args )
    (59) func -> ID . f_varobj : ID f_verify_func_composite ( args )
    (60) f_verify_func -> .
    (72) f_varobj -> .

    (               reduce using rule 60 (f_verify_func -> .)
    :               reduce using rule 72 (f_varobj -> .)

    f_verify_func                  shift and go to state 134
    f_varobj                       shift and go to state 135

state 105

    (110) input -> INPUT . ( var )

    (               shift and go to state 136


state 106

    (111) write -> PRINT . ( write_list )

    (               shift and go to state 137


state 107

    (107) to_num -> TO_NUMBER . ( STR )
    (108) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 138


state 108

    (109) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 139


state 109

    (117) return -> RET . ( expresion )

    (               shift and go to state 140


state 110

    (66) asignacion -> var = . f_oper expresion ;
    (84) f_oper -> .

    (               reduce using rule 84 (f_oper -> .)
    NUM             reduce using rule 84 (f_oper -> .)
    OPTERM          reduce using rule 84 (f_oper -> .)
    CALL            reduce using rule 84 (f_oper -> .)
    ID              reduce using rule 84 (f_oper -> .)

    f_oper                         shift and go to state 141

state 111

    (99) while -> WHILE f_while . ( expresion f_exprwhile ) DO { estatutos } f_endwhile

    (               shift and go to state 142


state 112

    (103) for -> FOR expresion . f_for_start TO expresion f_for_to { estatutos } f_for_end
    (76) expresion -> expresion . COMP f_oper exp f_expres
    (104) f_for_start -> .

    COMP            shift and go to state 144
    TO              reduce using rule 104 (f_for_start -> .)

    f_for_start                    shift and go to state 143

state 113

    (75) expresion -> exp .
    (79) exp -> exp . OPTERM f_oper term f_exp

    COMP            reduce using rule 75 (expresion -> exp .)
    TO              reduce using rule 75 (expresion -> exp .)
    )               reduce using rule 75 (expresion -> exp .)
    ]               reduce using rule 75 (expresion -> exp .)
    ;               reduce using rule 75 (expresion -> exp .)
    ,               reduce using rule 75 (expresion -> exp .)
    {               reduce using rule 75 (expresion -> exp .)
    OPTERM          shift and go to state 145


state 114

    (78) exp -> term .
    (82) term -> term . OPFACT f_oper fact f_term

    OPTERM          reduce using rule 78 (exp -> term .)
    COMP            reduce using rule 78 (exp -> term .)
    TO              reduce using rule 78 (exp -> term .)
    )               reduce using rule 78 (exp -> term .)
    ]               reduce using rule 78 (exp -> term .)
    ;               reduce using rule 78 (exp -> term .)
    ,               reduce using rule 78 (exp -> term .)
    {               reduce using rule 78 (exp -> term .)
    OPFACT          shift and go to state 146


state 115

    (88) fact -> OPTERM . NUM

    NUM             shift and go to state 147


state 116

    (81) term -> fact .

    OPFACT          reduce using rule 81 (term -> fact .)
    OPTERM          reduce using rule 81 (term -> fact .)
    COMP            reduce using rule 81 (term -> fact .)
    TO              reduce using rule 81 (term -> fact .)
    )               reduce using rule 81 (term -> fact .)
    ]               reduce using rule 81 (term -> fact .)
    ;               reduce using rule 81 (term -> fact .)
    ,               reduce using rule 81 (term -> fact .)
    {               reduce using rule 81 (term -> fact .)


state 117

    (85) fact -> ( . lparen expresion ) rparen
    (90) lparen -> .

    (               reduce using rule 90 (lparen -> .)
    NUM             reduce using rule 90 (lparen -> .)
    OPTERM          reduce using rule 90 (lparen -> .)
    CALL            reduce using rule 90 (lparen -> .)
    ID              reduce using rule 90 (lparen -> .)

    lparen                         shift and go to state 148

state 118

    (86) fact -> var .

    OPFACT          reduce using rule 86 (fact -> var .)
    OPTERM          reduce using rule 86 (fact -> var .)
    COMP            reduce using rule 86 (fact -> var .)
    TO              reduce using rule 86 (fact -> var .)
    )               reduce using rule 86 (fact -> var .)
    ]               reduce using rule 86 (fact -> var .)
    ;               reduce using rule 86 (fact -> var .)
    ,               reduce using rule 86 (fact -> var .)
    {               reduce using rule 86 (fact -> var .)


state 119

    (87) fact -> NUM . f_fact
    (92) f_fact -> .

    OPFACT          reduce using rule 92 (f_fact -> .)
    OPTERM          reduce using rule 92 (f_fact -> .)
    COMP            reduce using rule 92 (f_fact -> .)
    TO              reduce using rule 92 (f_fact -> .)
    )               reduce using rule 92 (f_fact -> .)
    ]               reduce using rule 92 (f_fact -> .)
    ;               reduce using rule 92 (f_fact -> .)
    ,               reduce using rule 92 (f_fact -> .)
    {               reduce using rule 92 (f_fact -> .)

    f_fact                         shift and go to state 149

state 120

    (89) fact -> CALL . call_func
    (52) call_func -> . func
    (53) call_func -> . input
    (54) call_func -> . write
    (55) call_func -> . to_num
    (56) call_func -> . to_str
    (57) call_func -> . return
    (58) func -> . ID f_verify_func ( args )
    (59) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (110) input -> . INPUT ( var )
    (111) write -> . PRINT ( write_list )
    (107) to_num -> . TO_NUMBER ( STR )
    (108) to_num -> . TO_NUMBER ( var )
    (109) to_str -> . TO_STRING ( expresion )
    (117) return -> . RET ( expresion )

    ID              shift and go to state 104
    INPUT           shift and go to state 105
    PRINT           shift and go to state 106
    TO_NUMBER       shift and go to state 107
    TO_STRING       shift and go to state 108
    RET             shift and go to state 109

    call_func                      shift and go to state 150
    func                           shift and go to state 98
    input                          shift and go to state 99
    write                          shift and go to state 100
    to_num                         shift and go to state 101
    to_str                         shift and go to state 102
    return                         shift and go to state 103

state 121

    (93) condicion -> IF ( . expresion ) f_if THEN { estatutos } condicionp f_endif
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 151
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 122

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 152

state 123

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING . f_nothing f_tipofunc { vars estatutos } f_endfunc
    (19) f_nothing -> .

    {               reduce using rule 19 (f_nothing -> .)

    f_nothing                      shift and go to state 153

state 124

    (43) pparams -> pparams , tipo ID . f_param
    (44) f_param -> .

    ,               reduce using rule 44 (f_param -> .)
    )               reduce using rule 44 (f_param -> .)

    f_param                        shift and go to state 154

state 125

    (32) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 . ] f_twodim

    ]               shift and go to state 155


state 126

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 156
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 127

    (26) cvars -> cvars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 157
    ,               shift and go to state 56


state 128

    (67) var -> ID f_varobj : . ID f_verify_type_composite indexacion

    ID              shift and go to state 158


state 129

    (68) var -> ID f_verify_type indexacion .

    =               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    OPFACT          reduce using rule 68 (var -> ID f_verify_type indexacion .)
    OPTERM          reduce using rule 68 (var -> ID f_verify_type indexacion .)
    COMP            reduce using rule 68 (var -> ID f_verify_type indexacion .)
    TO              reduce using rule 68 (var -> ID f_verify_type indexacion .)
    )               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    ]               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    &               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    ;               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    ,               reduce using rule 68 (var -> ID f_verify_type indexacion .)
    {               reduce using rule 68 (var -> ID f_verify_type indexacion .)


state 130

    (69) indexacion -> [ . expresion ]
    (70) indexacion -> [ . expresion ] [ expresion ]
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 159
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 131

    (71) indexacion -> empty .

    =               reduce using rule 71 (indexacion -> empty .)
    OPFACT          reduce using rule 71 (indexacion -> empty .)
    OPTERM          reduce using rule 71 (indexacion -> empty .)
    COMP            reduce using rule 71 (indexacion -> empty .)
    TO              reduce using rule 71 (indexacion -> empty .)
    )               reduce using rule 71 (indexacion -> empty .)
    ]               reduce using rule 71 (indexacion -> empty .)
    &               reduce using rule 71 (indexacion -> empty .)
    ;               reduce using rule 71 (indexacion -> empty .)
    ,               reduce using rule 71 (indexacion -> empty .)
    {               reduce using rule 71 (indexacion -> empty .)


state 132

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end . ;

    ;               shift and go to state 160


state 133

    (51) estatuto -> CALL call_func ; .

    }               reduce using rule 51 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 51 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 51 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 51 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 51 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 51 (estatuto -> CALL call_func ; .)


state 134

    (58) func -> ID f_verify_func . ( args )

    (               shift and go to state 161


state 135

    (59) func -> ID f_varobj . : ID f_verify_func_composite ( args )

    :               shift and go to state 162


state 136

    (110) input -> INPUT ( . var )
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    ID              shift and go to state 74

    var                            shift and go to state 163

state 137

    (111) write -> PRINT ( . write_list )
    (112) write_list -> . write_list & write_listp
    (113) write_list -> . write_listp
    (114) write_listp -> . STR
    (115) write_listp -> . var
    (116) write_listp -> . CALL to_str
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    STR             shift and go to state 166
    CALL            shift and go to state 168
    ID              shift and go to state 74

    write_list                     shift and go to state 164
    write_listp                    shift and go to state 165
    var                            shift and go to state 167

state 138

    (107) to_num -> TO_NUMBER ( . STR )
    (108) to_num -> TO_NUMBER ( . var )
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    STR             shift and go to state 169
    ID              shift and go to state 74

    var                            shift and go to state 170

state 139

    (109) to_str -> TO_STRING ( . expresion )
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 171
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 140

    (117) return -> RET ( . expresion )
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 172
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 141

    (66) asignacion -> var = f_oper . expresion ;
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    var                            shift and go to state 118
    expresion                      shift and go to state 173
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116

state 142

    (99) while -> WHILE f_while ( . expresion f_exprwhile ) DO { estatutos } f_endwhile
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 174
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 143

    (103) for -> FOR expresion f_for_start . TO expresion f_for_to { estatutos } f_for_end

    TO              shift and go to state 175


state 144

    (76) expresion -> expresion COMP . f_oper exp f_expres
    (84) f_oper -> .

    (               reduce using rule 84 (f_oper -> .)
    NUM             reduce using rule 84 (f_oper -> .)
    OPTERM          reduce using rule 84 (f_oper -> .)
    CALL            reduce using rule 84 (f_oper -> .)
    ID              reduce using rule 84 (f_oper -> .)

    f_oper                         shift and go to state 176

state 145

    (79) exp -> exp OPTERM . f_oper term f_exp
    (84) f_oper -> .

    (               reduce using rule 84 (f_oper -> .)
    NUM             reduce using rule 84 (f_oper -> .)
    OPTERM          reduce using rule 84 (f_oper -> .)
    CALL            reduce using rule 84 (f_oper -> .)
    ID              reduce using rule 84 (f_oper -> .)

    f_oper                         shift and go to state 177

state 146

    (82) term -> term OPFACT . f_oper fact f_term
    (84) f_oper -> .

    (               reduce using rule 84 (f_oper -> .)
    NUM             reduce using rule 84 (f_oper -> .)
    OPTERM          reduce using rule 84 (f_oper -> .)
    CALL            reduce using rule 84 (f_oper -> .)
    ID              reduce using rule 84 (f_oper -> .)

    f_oper                         shift and go to state 178

state 147

    (88) fact -> OPTERM NUM .

    OPFACT          reduce using rule 88 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 88 (fact -> OPTERM NUM .)
    COMP            reduce using rule 88 (fact -> OPTERM NUM .)
    TO              reduce using rule 88 (fact -> OPTERM NUM .)
    )               reduce using rule 88 (fact -> OPTERM NUM .)
    ]               reduce using rule 88 (fact -> OPTERM NUM .)
    ;               reduce using rule 88 (fact -> OPTERM NUM .)
    ,               reduce using rule 88 (fact -> OPTERM NUM .)
    {               reduce using rule 88 (fact -> OPTERM NUM .)


state 148

    (85) fact -> ( lparen . expresion ) rparen
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 179
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 149

    (87) fact -> NUM f_fact .

    OPFACT          reduce using rule 87 (fact -> NUM f_fact .)
    OPTERM          reduce using rule 87 (fact -> NUM f_fact .)
    COMP            reduce using rule 87 (fact -> NUM f_fact .)
    TO              reduce using rule 87 (fact -> NUM f_fact .)
    )               reduce using rule 87 (fact -> NUM f_fact .)
    ]               reduce using rule 87 (fact -> NUM f_fact .)
    ;               reduce using rule 87 (fact -> NUM f_fact .)
    ,               reduce using rule 87 (fact -> NUM f_fact .)
    {               reduce using rule 87 (fact -> NUM f_fact .)


state 150

    (89) fact -> CALL call_func .

    OPFACT          reduce using rule 89 (fact -> CALL call_func .)
    OPTERM          reduce using rule 89 (fact -> CALL call_func .)
    COMP            reduce using rule 89 (fact -> CALL call_func .)
    TO              reduce using rule 89 (fact -> CALL call_func .)
    )               reduce using rule 89 (fact -> CALL call_func .)
    ]               reduce using rule 89 (fact -> CALL call_func .)
    ;               reduce using rule 89 (fact -> CALL call_func .)
    ,               reduce using rule 89 (fact -> CALL call_func .)
    {               reduce using rule 89 (fact -> CALL call_func .)


state 151

    (93) condicion -> IF ( expresion . ) f_if THEN { estatutos } condicionp f_endif
    (76) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 180
    COMP            shift and go to state 144


state 152

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 181


state 153

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 182

state 154

    (43) pparams -> pparams , tipo ID f_param .

    ,               reduce using rule 43 (pparams -> pparams , tipo ID f_param .)
    )               reduce using rule 43 (pparams -> pparams , tipo ID f_param .)


state 155

    (32) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] . f_twodim
    (37) f_twodim -> .

    :               reduce using rule 37 (f_twodim -> .)

    f_twodim                       shift and go to state 183

state 156

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 184

state 157

    (26) cvars -> cvars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)


state 158

    (67) var -> ID f_varobj : ID . f_verify_type_composite indexacion
    (74) f_verify_type_composite -> .

    [               reduce using rule 74 (f_verify_type_composite -> .)
    =               reduce using rule 74 (f_verify_type_composite -> .)
    OPFACT          reduce using rule 74 (f_verify_type_composite -> .)
    OPTERM          reduce using rule 74 (f_verify_type_composite -> .)
    COMP            reduce using rule 74 (f_verify_type_composite -> .)
    TO              reduce using rule 74 (f_verify_type_composite -> .)
    )               reduce using rule 74 (f_verify_type_composite -> .)
    ]               reduce using rule 74 (f_verify_type_composite -> .)
    &               reduce using rule 74 (f_verify_type_composite -> .)
    ;               reduce using rule 74 (f_verify_type_composite -> .)
    ,               reduce using rule 74 (f_verify_type_composite -> .)
    {               reduce using rule 74 (f_verify_type_composite -> .)

    f_verify_type_composite        shift and go to state 185

state 159

    (69) indexacion -> [ expresion . ]
    (70) indexacion -> [ expresion . ] [ expresion ]
    (76) expresion -> expresion . COMP f_oper exp f_expres

    ]               shift and go to state 186
    COMP            shift and go to state 144


state 160

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .

    $end            reduce using rule 1 (start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .)


state 161

    (58) func -> ID f_verify_func ( . args )
    (62) args -> . args_list
    (63) args -> . empty
    (64) args_list -> . expresion
    (65) args_list -> . args_list , expresion
    (118) empty -> .
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    )               reduce using rule 118 (empty -> .)
    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    args                           shift and go to state 187
    args_list                      shift and go to state 188
    empty                          shift and go to state 189
    expresion                      shift and go to state 190
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 162

    (59) func -> ID f_varobj : . ID f_verify_func_composite ( args )

    ID              shift and go to state 191


state 163

    (110) input -> INPUT ( var . )

    )               shift and go to state 192


state 164

    (111) write -> PRINT ( write_list . )
    (112) write_list -> write_list . & write_listp

    )               shift and go to state 193
    &               shift and go to state 194


state 165

    (113) write_list -> write_listp .

    )               reduce using rule 113 (write_list -> write_listp .)
    &               reduce using rule 113 (write_list -> write_listp .)


state 166

    (114) write_listp -> STR .

    )               reduce using rule 114 (write_listp -> STR .)
    &               reduce using rule 114 (write_listp -> STR .)


state 167

    (115) write_listp -> var .

    )               reduce using rule 115 (write_listp -> var .)
    &               reduce using rule 115 (write_listp -> var .)


state 168

    (116) write_listp -> CALL . to_str
    (109) to_str -> . TO_STRING ( expresion )

    TO_STRING       shift and go to state 108

    to_str                         shift and go to state 195

state 169

    (107) to_num -> TO_NUMBER ( STR . )

    )               shift and go to state 196


state 170

    (108) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 197


state 171

    (109) to_str -> TO_STRING ( expresion . )
    (76) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 198
    COMP            shift and go to state 144


state 172

    (117) return -> RET ( expresion . )
    (76) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 199
    COMP            shift and go to state 144


state 173

    (66) asignacion -> var = f_oper expresion . ;
    (76) expresion -> expresion . COMP f_oper exp f_expres

    ;               shift and go to state 200
    COMP            shift and go to state 144


state 174

    (99) while -> WHILE f_while ( expresion . f_exprwhile ) DO { estatutos } f_endwhile
    (76) expresion -> expresion . COMP f_oper exp f_expres
    (101) f_exprwhile -> .

    COMP            shift and go to state 144
    )               reduce using rule 101 (f_exprwhile -> .)

    f_exprwhile                    shift and go to state 201

state 175

    (103) for -> FOR expresion f_for_start TO . expresion f_for_to { estatutos } f_for_end
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 202
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 176

    (76) expresion -> expresion COMP f_oper . exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    exp                            shift and go to state 203
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 177

    (79) exp -> exp OPTERM f_oper . term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    term                           shift and go to state 204
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 178

    (82) term -> term OPFACT f_oper . fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    fact                           shift and go to state 205
    var                            shift and go to state 118

state 179

    (85) fact -> ( lparen expresion . ) rparen
    (76) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 206
    COMP            shift and go to state 144


state 180

    (93) condicion -> IF ( expresion ) . f_if THEN { estatutos } condicionp f_endif
    (96) f_if -> .

    THEN            reduce using rule 96 (f_if -> .)

    f_if                           shift and go to state 207

state 181

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (118) empty -> .

    DEF             reduce using rule 118 (empty -> .)
    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    vars                           shift and go to state 208
    empty                          shift and go to state 11

state 182

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 209


state 183

    (32) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim .

    :               reduce using rule 32 (dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim .)


state 184

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)


state 185

    (67) var -> ID f_varobj : ID f_verify_type_composite . indexacion
    (69) indexacion -> . [ expresion ]
    (70) indexacion -> . [ expresion ] [ expresion ]
    (71) indexacion -> . empty
    (118) empty -> .

    [               shift and go to state 130
    =               reduce using rule 118 (empty -> .)
    OPFACT          reduce using rule 118 (empty -> .)
    OPTERM          reduce using rule 118 (empty -> .)
    COMP            reduce using rule 118 (empty -> .)
    TO              reduce using rule 118 (empty -> .)
    )               reduce using rule 118 (empty -> .)
    ]               reduce using rule 118 (empty -> .)
    &               reduce using rule 118 (empty -> .)
    ;               reduce using rule 118 (empty -> .)
    ,               reduce using rule 118 (empty -> .)
    {               reduce using rule 118 (empty -> .)

    indexacion                     shift and go to state 210
    empty                          shift and go to state 131

state 186

    (69) indexacion -> [ expresion ] .
    (70) indexacion -> [ expresion ] . [ expresion ]

    =               reduce using rule 69 (indexacion -> [ expresion ] .)
    OPFACT          reduce using rule 69 (indexacion -> [ expresion ] .)
    OPTERM          reduce using rule 69 (indexacion -> [ expresion ] .)
    COMP            reduce using rule 69 (indexacion -> [ expresion ] .)
    TO              reduce using rule 69 (indexacion -> [ expresion ] .)
    )               reduce using rule 69 (indexacion -> [ expresion ] .)
    ]               reduce using rule 69 (indexacion -> [ expresion ] .)
    &               reduce using rule 69 (indexacion -> [ expresion ] .)
    ;               reduce using rule 69 (indexacion -> [ expresion ] .)
    ,               reduce using rule 69 (indexacion -> [ expresion ] .)
    {               reduce using rule 69 (indexacion -> [ expresion ] .)
    [               shift and go to state 211


state 187

    (58) func -> ID f_verify_func ( args . )

    )               shift and go to state 212


state 188

    (62) args -> args_list .
    (65) args_list -> args_list . , expresion

    )               reduce using rule 62 (args -> args_list .)
    ,               shift and go to state 213


state 189

    (63) args -> empty .

    )               reduce using rule 63 (args -> empty .)


state 190

    (64) args_list -> expresion .
    (76) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 64 (args_list -> expresion .)
    )               reduce using rule 64 (args_list -> expresion .)
    COMP            shift and go to state 144


state 191

    (59) func -> ID f_varobj : ID . f_verify_func_composite ( args )
    (61) f_verify_func_composite -> .

    (               reduce using rule 61 (f_verify_func_composite -> .)

    f_verify_func_composite        shift and go to state 214

state 192

    (110) input -> INPUT ( var ) .

    ;               reduce using rule 110 (input -> INPUT ( var ) .)
    OPFACT          reduce using rule 110 (input -> INPUT ( var ) .)
    OPTERM          reduce using rule 110 (input -> INPUT ( var ) .)
    COMP            reduce using rule 110 (input -> INPUT ( var ) .)
    TO              reduce using rule 110 (input -> INPUT ( var ) .)
    )               reduce using rule 110 (input -> INPUT ( var ) .)
    ]               reduce using rule 110 (input -> INPUT ( var ) .)
    ,               reduce using rule 110 (input -> INPUT ( var ) .)
    {               reduce using rule 110 (input -> INPUT ( var ) .)


state 193

    (111) write -> PRINT ( write_list ) .

    ;               reduce using rule 111 (write -> PRINT ( write_list ) .)
    OPFACT          reduce using rule 111 (write -> PRINT ( write_list ) .)
    OPTERM          reduce using rule 111 (write -> PRINT ( write_list ) .)
    COMP            reduce using rule 111 (write -> PRINT ( write_list ) .)
    TO              reduce using rule 111 (write -> PRINT ( write_list ) .)
    )               reduce using rule 111 (write -> PRINT ( write_list ) .)
    ]               reduce using rule 111 (write -> PRINT ( write_list ) .)
    ,               reduce using rule 111 (write -> PRINT ( write_list ) .)
    {               reduce using rule 111 (write -> PRINT ( write_list ) .)


state 194

    (112) write_list -> write_list & . write_listp
    (114) write_listp -> . STR
    (115) write_listp -> . var
    (116) write_listp -> . CALL to_str
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    STR             shift and go to state 166
    CALL            shift and go to state 168
    ID              shift and go to state 74

    write_listp                    shift and go to state 215
    var                            shift and go to state 167

state 195

    (116) write_listp -> CALL to_str .

    )               reduce using rule 116 (write_listp -> CALL to_str .)
    &               reduce using rule 116 (write_listp -> CALL to_str .)


state 196

    (107) to_num -> TO_NUMBER ( STR ) .

    ;               reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    OPFACT          reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    OPTERM          reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    COMP            reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    TO              reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    )               reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    ]               reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    ,               reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)
    {               reduce using rule 107 (to_num -> TO_NUMBER ( STR ) .)


state 197

    (108) to_num -> TO_NUMBER ( var ) .

    ;               reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    OPFACT          reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 108 (to_num -> TO_NUMBER ( var ) .)


state 198

    (109) to_str -> TO_STRING ( expresion ) .

    ;               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    OPFACT          reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)
    &               reduce using rule 109 (to_str -> TO_STRING ( expresion ) .)


state 199

    (117) return -> RET ( expresion ) .

    ;               reduce using rule 117 (return -> RET ( expresion ) .)
    OPFACT          reduce using rule 117 (return -> RET ( expresion ) .)
    OPTERM          reduce using rule 117 (return -> RET ( expresion ) .)
    COMP            reduce using rule 117 (return -> RET ( expresion ) .)
    TO              reduce using rule 117 (return -> RET ( expresion ) .)
    )               reduce using rule 117 (return -> RET ( expresion ) .)
    ]               reduce using rule 117 (return -> RET ( expresion ) .)
    ,               reduce using rule 117 (return -> RET ( expresion ) .)
    {               reduce using rule 117 (return -> RET ( expresion ) .)


state 200

    (66) asignacion -> var = f_oper expresion ; .

    }               reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    CALL            reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    WHILE           reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    FOR             reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    IF              reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    ID              reduce using rule 66 (asignacion -> var = f_oper expresion ; .)


state 201

    (99) while -> WHILE f_while ( expresion f_exprwhile . ) DO { estatutos } f_endwhile

    )               shift and go to state 216


state 202

    (103) for -> FOR expresion f_for_start TO expresion . f_for_to { estatutos } f_for_end
    (76) expresion -> expresion . COMP f_oper exp f_expres
    (105) f_for_to -> .

    COMP            shift and go to state 144
    {               reduce using rule 105 (f_for_to -> .)

    f_for_to                       shift and go to state 217

state 203

    (76) expresion -> expresion COMP f_oper exp . f_expres
    (79) exp -> exp . OPTERM f_oper term f_exp
    (77) f_expres -> .

    OPTERM          shift and go to state 145
    COMP            reduce using rule 77 (f_expres -> .)
    TO              reduce using rule 77 (f_expres -> .)
    )               reduce using rule 77 (f_expres -> .)
    ]               reduce using rule 77 (f_expres -> .)
    ;               reduce using rule 77 (f_expres -> .)
    ,               reduce using rule 77 (f_expres -> .)
    {               reduce using rule 77 (f_expres -> .)

    f_expres                       shift and go to state 218

state 204

    (79) exp -> exp OPTERM f_oper term . f_exp
    (82) term -> term . OPFACT f_oper fact f_term
    (80) f_exp -> .

    OPFACT          shift and go to state 146
    OPTERM          reduce using rule 80 (f_exp -> .)
    COMP            reduce using rule 80 (f_exp -> .)
    TO              reduce using rule 80 (f_exp -> .)
    )               reduce using rule 80 (f_exp -> .)
    ]               reduce using rule 80 (f_exp -> .)
    ;               reduce using rule 80 (f_exp -> .)
    ,               reduce using rule 80 (f_exp -> .)
    {               reduce using rule 80 (f_exp -> .)

    f_exp                          shift and go to state 219

state 205

    (82) term -> term OPFACT f_oper fact . f_term
    (83) f_term -> .

    OPFACT          reduce using rule 83 (f_term -> .)
    OPTERM          reduce using rule 83 (f_term -> .)
    COMP            reduce using rule 83 (f_term -> .)
    TO              reduce using rule 83 (f_term -> .)
    )               reduce using rule 83 (f_term -> .)
    ]               reduce using rule 83 (f_term -> .)
    ;               reduce using rule 83 (f_term -> .)
    ,               reduce using rule 83 (f_term -> .)
    {               reduce using rule 83 (f_term -> .)

    f_term                         shift and go to state 220

state 206

    (85) fact -> ( lparen expresion ) . rparen
    (91) rparen -> .

    OPFACT          reduce using rule 91 (rparen -> .)
    OPTERM          reduce using rule 91 (rparen -> .)
    COMP            reduce using rule 91 (rparen -> .)
    TO              reduce using rule 91 (rparen -> .)
    )               reduce using rule 91 (rparen -> .)
    ]               reduce using rule 91 (rparen -> .)
    ;               reduce using rule 91 (rparen -> .)
    ,               reduce using rule 91 (rparen -> .)
    {               reduce using rule 91 (rparen -> .)

    rparen                         shift and go to state 221

state 207

    (93) condicion -> IF ( expresion ) f_if . THEN { estatutos } condicionp f_endif

    THEN            shift and go to state 222


state 208

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 223
    empty                          shift and go to state 64

state 209

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (118) empty -> .

    DEF             reduce using rule 118 (empty -> .)
    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    vars                           shift and go to state 224
    empty                          shift and go to state 11

state 210

    (67) var -> ID f_varobj : ID f_verify_type_composite indexacion .

    =               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    OPFACT          reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    OPTERM          reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    COMP            reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    TO              reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    )               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ]               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    &               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ;               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ,               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    {               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)


state 211

    (70) indexacion -> [ expresion ] [ . expresion ]
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 225
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 212

    (58) func -> ID f_verify_func ( args ) .

    ;               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    OPFACT          reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    OPTERM          reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    COMP            reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    TO              reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    )               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    ]               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    ,               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    {               reduce using rule 58 (func -> ID f_verify_func ( args ) .)


state 213

    (65) args_list -> args_list , . expresion
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    expresion                      shift and go to state 226
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 214

    (59) func -> ID f_varobj : ID f_verify_func_composite . ( args )

    (               shift and go to state 227


state 215

    (112) write_list -> write_list & write_listp .

    )               reduce using rule 112 (write_list -> write_list & write_listp .)
    &               reduce using rule 112 (write_list -> write_list & write_listp .)


state 216

    (99) while -> WHILE f_while ( expresion f_exprwhile ) . DO { estatutos } f_endwhile

    DO              shift and go to state 228


state 217

    (103) for -> FOR expresion f_for_start TO expresion f_for_to . { estatutos } f_for_end

    {               shift and go to state 229


state 218

    (76) expresion -> expresion COMP f_oper exp f_expres .

    COMP            reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    TO              reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    )               reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    ]               reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    ;               reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    ,               reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)
    {               reduce using rule 76 (expresion -> expresion COMP f_oper exp f_expres .)


state 219

    (79) exp -> exp OPTERM f_oper term f_exp .

    OPTERM          reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    COMP            reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    TO              reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    )               reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    ]               reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    ;               reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    ,               reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)
    {               reduce using rule 79 (exp -> exp OPTERM f_oper term f_exp .)


state 220

    (82) term -> term OPFACT f_oper fact f_term .

    OPFACT          reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    OPTERM          reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    COMP            reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    TO              reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    )               reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    ]               reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    ;               reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    ,               reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)
    {               reduce using rule 82 (term -> term OPFACT f_oper fact f_term .)


state 221

    (85) fact -> ( lparen expresion ) rparen .

    OPFACT          reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    OPTERM          reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    COMP            reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    TO              reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    )               reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    ]               reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    ;               reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    ,               reduce using rule 85 (fact -> ( lparen expresion ) rparen .)
    {               reduce using rule 85 (fact -> ( lparen expresion ) rparen .)


state 222

    (93) condicion -> IF ( expresion ) f_if THEN . { estatutos } condicionp f_endif

    {               shift and go to state 230


state 223

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos . } f_endfunc
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 231
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 224

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 232
    empty                          shift and go to state 64

state 225

    (70) indexacion -> [ expresion ] [ expresion . ]
    (76) expresion -> expresion . COMP f_oper exp f_expres

    ]               shift and go to state 233
    COMP            shift and go to state 144


state 226

    (65) args_list -> args_list , expresion .
    (76) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 65 (args_list -> args_list , expresion .)
    )               reduce using rule 65 (args_list -> args_list , expresion .)
    COMP            shift and go to state 144


state 227

    (59) func -> ID f_varobj : ID f_verify_func_composite ( . args )
    (62) args -> . args_list
    (63) args -> . empty
    (64) args_list -> . expresion
    (65) args_list -> . args_list , expresion
    (118) empty -> .
    (75) expresion -> . exp
    (76) expresion -> . expresion COMP f_oper exp f_expres
    (78) exp -> . term
    (79) exp -> . exp OPTERM f_oper term f_exp
    (81) term -> . fact
    (82) term -> . term OPFACT f_oper fact f_term
    (85) fact -> . ( lparen expresion ) rparen
    (86) fact -> . var
    (87) fact -> . NUM f_fact
    (88) fact -> . OPTERM NUM
    (89) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    )               reduce using rule 118 (empty -> .)
    (               shift and go to state 117
    NUM             shift and go to state 119
    OPTERM          shift and go to state 115
    CALL            shift and go to state 120
    ID              shift and go to state 74

    args                           shift and go to state 234
    args_list                      shift and go to state 188
    empty                          shift and go to state 189
    expresion                      shift and go to state 190
    exp                            shift and go to state 113
    term                           shift and go to state 114
    fact                           shift and go to state 116
    var                            shift and go to state 118

state 228

    (99) while -> WHILE f_while ( expresion f_exprwhile ) DO . { estatutos } f_endwhile

    {               shift and go to state 235


state 229

    (103) for -> FOR expresion f_for_start TO expresion f_for_to { . estatutos } f_for_end
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 236
    empty                          shift and go to state 64

state 230

    (93) condicion -> IF ( expresion ) f_if THEN { . estatutos } condicionp f_endif
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 237
    empty                          shift and go to state 64

state 231

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 238

state 232

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos . } f_endfunc
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 239
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 233

    (70) indexacion -> [ expresion ] [ expresion ] .

    =               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    OPFACT          reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    OPTERM          reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    COMP            reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    TO              reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    )               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    ]               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    &               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    ;               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    ,               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)
    {               reduce using rule 70 (indexacion -> [ expresion ] [ expresion ] .)


state 234

    (59) func -> ID f_varobj : ID f_verify_func_composite ( args . )

    )               shift and go to state 240


state 235

    (99) while -> WHILE f_while ( expresion f_exprwhile ) DO { . estatutos } f_endwhile
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 241
    empty                          shift and go to state 64

state 236

    (103) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos . } f_for_end
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 242
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 237

    (93) condicion -> IF ( expresion ) f_if THEN { estatutos . } condicionp f_endif
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 243
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 238

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)


state 239

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 244

state 240

    (59) func -> ID f_varobj : ID f_verify_func_composite ( args ) .

    ;               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPFACT          reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPTERM          reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    COMP            reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    TO              reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    )               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ]               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ,               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    {               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)


state 241

    (99) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos . } f_endwhile
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 245
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 242

    (103) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } . f_for_end
    (106) f_for_end -> .

    }               reduce using rule 106 (f_for_end -> .)
    CALL            reduce using rule 106 (f_for_end -> .)
    WHILE           reduce using rule 106 (f_for_end -> .)
    FOR             reduce using rule 106 (f_for_end -> .)
    IF              reduce using rule 106 (f_for_end -> .)
    ID              reduce using rule 106 (f_for_end -> .)

    f_for_end                      shift and go to state 246

state 243

    (93) condicion -> IF ( expresion ) f_if THEN { estatutos } . condicionp f_endif
    (94) condicionp -> . ELSE f_else { estatutos }
    (95) condicionp -> . empty
    (118) empty -> .

    ELSE            shift and go to state 248
    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    condicionp                     shift and go to state 247
    empty                          shift and go to state 249

state 244

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)


state 245

    (99) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } . f_endwhile
    (102) f_endwhile -> .

    }               reduce using rule 102 (f_endwhile -> .)
    CALL            reduce using rule 102 (f_endwhile -> .)
    WHILE           reduce using rule 102 (f_endwhile -> .)
    FOR             reduce using rule 102 (f_endwhile -> .)
    IF              reduce using rule 102 (f_endwhile -> .)
    ID              reduce using rule 102 (f_endwhile -> .)

    f_endwhile                     shift and go to state 250

state 246

    (103) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .

    }               reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    CALL            reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    WHILE           reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    FOR             reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    IF              reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    ID              reduce using rule 103 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)


state 247

    (93) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp . f_endif
    (97) f_endif -> .

    }               reduce using rule 97 (f_endif -> .)
    CALL            reduce using rule 97 (f_endif -> .)
    WHILE           reduce using rule 97 (f_endif -> .)
    FOR             reduce using rule 97 (f_endif -> .)
    IF              reduce using rule 97 (f_endif -> .)
    ID              reduce using rule 97 (f_endif -> .)

    f_endif                        shift and go to state 251

state 248

    (94) condicionp -> ELSE . f_else { estatutos }
    (98) f_else -> .

    {               reduce using rule 98 (f_else -> .)

    f_else                         shift and go to state 252

state 249

    (95) condicionp -> empty .

    }               reduce using rule 95 (condicionp -> empty .)
    CALL            reduce using rule 95 (condicionp -> empty .)
    WHILE           reduce using rule 95 (condicionp -> empty .)
    FOR             reduce using rule 95 (condicionp -> empty .)
    IF              reduce using rule 95 (condicionp -> empty .)
    ID              reduce using rule 95 (condicionp -> empty .)


state 250

    (99) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .

    }               reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    CALL            reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    WHILE           reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    FOR             reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    IF              reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    ID              reduce using rule 99 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)


state 251

    (93) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .

    }               reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    CALL            reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    WHILE           reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    FOR             reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    IF              reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    ID              reduce using rule 93 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)


state 252

    (94) condicionp -> ELSE f_else . { estatutos }

    {               shift and go to state 253


state 253

    (94) condicionp -> ELSE f_else { . estatutos }
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (118) empty -> .

    }               reduce using rule 118 (empty -> .)
    CALL            reduce using rule 118 (empty -> .)
    WHILE           reduce using rule 118 (empty -> .)
    FOR             reduce using rule 118 (empty -> .)
    IF              reduce using rule 118 (empty -> .)
    ID              reduce using rule 118 (empty -> .)

    estatutos                      shift and go to state 254
    empty                          shift and go to state 64

state 254

    (94) condicionp -> ELSE f_else { estatutos . }
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (99) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (93) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (68) var -> . ID f_verify_type indexacion

    }               shift and go to state 255
    CALL            shift and go to state 81
    WHILE           shift and go to state 83
    FOR             shift and go to state 84
    IF              shift and go to state 85
    ID              shift and go to state 74

    estatuto                       shift and go to state 76
    asignacion                     shift and go to state 77
    while                          shift and go to state 78
    for                            shift and go to state 79
    condicion                      shift and go to state 80
    var                            shift and go to state 82

state 255

    (94) condicionp -> ELSE f_else { estatutos } .

    }               reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)
    CALL            reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)
    WHILE           reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)
    FOR             reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)
    IF              reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)
    ID              reduce using rule 94 (condicionp -> ELSE f_else { estatutos } .)

