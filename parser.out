Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
Rule 2     f_start -> <empty>
Rule 3     f_prog -> <empty>
Rule 4     f_main -> <empty>
Rule 5     f_end -> <empty>
Rule 6     clases -> clases clase
Rule 7     clases -> empty
Rule 8     clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
Rule 9     clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
Rule 10    f_startclass -> <empty>
Rule 11    f_clasepadre -> <empty>
Rule 12    f_cvars -> <empty>
Rule 13    f_endclass -> <empty>
Rule 14    funciones -> funciones funcion
Rule 15    funciones -> empty
Rule 16    funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
Rule 17    funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
Rule 18    f_startfunc -> <empty>
Rule 19    f_nothing -> <empty>
Rule 20    f_tipofunc -> <empty>
Rule 21    f_endfunc -> <empty>
Rule 22    vars -> vars DEF tipo dimension : lista_id ;
Rule 23    vars -> vars DEF ID f_varsobj : lista_id ;
Rule 24    vars -> empty
Rule 25    f_varsobj -> <empty>
Rule 26    cvars -> cvars DEF tipo dimension : lista_id ;
Rule 27    cvars -> empty
Rule 28    lista_id -> ID f_vars
Rule 29    lista_id -> lista_id , ID f_vars
Rule 30    f_vars -> <empty>
Rule 31    dimension -> [ expresion f_dim1 ] f_onedim
Rule 32    dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
Rule 33    dimension -> empty
Rule 34    f_dim1 -> <empty>
Rule 35    f_dim2 -> <empty>
Rule 36    f_onedim -> <empty>
Rule 37    f_twodim -> <empty>
Rule 38    tipo -> NUMBER
Rule 39    tipo -> STRING
Rule 40    params -> pparams
Rule 41    params -> empty
Rule 42    pparams -> tipo ID f_param
Rule 43    pparams -> pparams , tipo ID f_param
Rule 44    f_param -> <empty>
Rule 45    estatutos -> estatutos estatuto
Rule 46    estatutos -> empty
Rule 47    estatuto -> asignacion
Rule 48    estatuto -> while
Rule 49    estatuto -> for
Rule 50    estatuto -> condicion
Rule 51    estatuto -> CALL call_func ;
Rule 52    call_func -> func
Rule 53    call_func -> input
Rule 54    call_func -> write
Rule 55    call_func -> to_num
Rule 56    call_func -> to_str
Rule 57    call_func -> return
Rule 58    func -> ID f_verify_func ( args )
Rule 59    func -> ID f_varobj : ID f_verify_func_composite ( args )
Rule 60    f_verify_func -> <empty>
Rule 61    f_verify_func_composite -> <empty>
Rule 62    args -> args_list
Rule 63    args -> empty
Rule 64    args_list -> expresion
Rule 65    args_list -> args_list , expresion
Rule 66    asignacion -> var = f_oper expresion ;
Rule 67    var -> ID f_varobj : ID f_verify_type_composite dimension
Rule 68    var -> ID f_verify_type dimension
Rule 69    f_varobj -> <empty>
Rule 70    f_verify_type -> <empty>
Rule 71    f_verify_type_composite -> <empty>
Rule 72    expresion -> exp
Rule 73    expresion -> expresion COMP f_oper exp f_expres
Rule 74    f_expres -> <empty>
Rule 75    exp -> term
Rule 76    exp -> exp OPTERM f_oper term f_exp
Rule 77    f_exp -> <empty>
Rule 78    term -> fact
Rule 79    term -> term OPFACT f_oper fact f_term
Rule 80    f_term -> <empty>
Rule 81    f_oper -> <empty>
Rule 82    fact -> ( lparen expresion ) rparen
Rule 83    fact -> var
Rule 84    fact -> NUM f_fact
Rule 85    fact -> OPTERM NUM
Rule 86    fact -> CALL call_func
Rule 87    lparen -> <empty>
Rule 88    rparen -> <empty>
Rule 89    f_fact -> <empty>
Rule 90    condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
Rule 91    condicionp -> ELSE f_else { estatutos }
Rule 92    condicionp -> empty
Rule 93    f_if -> <empty>
Rule 94    f_endif -> <empty>
Rule 95    f_else -> <empty>
Rule 96    while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
Rule 97    f_while -> <empty>
Rule 98    f_exprwhile -> <empty>
Rule 99    f_endwhile -> <empty>
Rule 100   for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
Rule 101   f_for_start -> <empty>
Rule 102   f_for_to -> <empty>
Rule 103   f_for_end -> <empty>
Rule 104   to_num -> TO_NUMBER ( STR )
Rule 105   to_num -> TO_NUMBER ( var )
Rule 106   to_str -> TO_STRING ( expresion )
Rule 107   input -> INPUT ( var )
Rule 108   write -> PRINT ( write_list )
Rule 109   write_list -> write_list & write_listp
Rule 110   write_list -> write_listp
Rule 111   write_listp -> STR
Rule 112   write_listp -> var
Rule 113   write_listp -> CALL to_str
Rule 114   return -> RET ( expresion )
Rule 115   empty -> <empty>

Terminals, with rules where they appear

&                    : 109
(                    : 1 16 17 58 59 82 90 96 104 105 106 107 108 114
)                    : 1 16 17 58 59 82 90 96 104 105 106 107 108 114
,                    : 29 43 65
:                    : 8 16 17 22 23 26 59 67
;                    : 1 1 22 23 26 51 66
=                    : 66
CALL                 : 51 86 113
COMP                 : 73
DEF                  : 22 23 26
DO                   : 96
ELSE                 : 91
END                  : 1
FOR                  : 100
FUNC                 : 16 17
ID                   : 1 8 8 9 16 17 23 28 29 42 43 58 59 59 67 67 68
IF                   : 90
INPUT                : 107
MAIN                 : 1
NOTHING              : 17
NUM                  : 84 85
NUMBER               : 38
OPFACT               : 79
OPTERM               : 76 85
PRINT                : 108
PROGRAM              : 1
RET                  : 114
STR                  : 104 111
STRING               : 39
THEN                 : 90
TO                   : 100
TO_NUMBER            : 104 105
TO_STRING            : 106
TYPE                 : 8 9
WHILE                : 96
[                    : 31 32 32
]                    : 31 32 32
error                : 
{                    : 1 8 9 16 17 90 91 96 100
}                    : 1 8 9 16 17 90 91 96 100

Nonterminals, with rules where they appear

args                 : 58 59
args_list            : 62 65
asignacion           : 47
call_func            : 51 86
clase                : 6
clases               : 1 6
condicion            : 50
condicionp           : 90
cvars                : 8 9 26
dimension            : 22 26 67 68
empty                : 7 15 24 27 33 41 46 63 92
estatuto             : 45
estatutos            : 1 16 17 45 90 91 96 100
exp                  : 72 73 76
expresion            : 31 32 32 64 65 66 73 82 90 96 100 100 106 114
f_clasepadre         : 8
f_cvars              : 8 9
f_dim1               : 31 32
f_dim2               : 32
f_else               : 91
f_end                : 1
f_endclass           : 8 9
f_endfunc            : 16 17
f_endif              : 90
f_endwhile           : 96
f_exp                : 76
f_expres             : 73
f_exprwhile          : 96
f_fact               : 84
f_for_end            : 100
f_for_start          : 100
f_for_to             : 100
f_if                 : 90
f_main               : 1
f_nothing            : 17
f_onedim             : 31
f_oper               : 66 73 76 79
f_param              : 42 43
f_prog               : 1
f_start              : 1
f_startclass         : 8 9
f_startfunc          : 16 17
f_term               : 79
f_tipofunc           : 16 17
f_twodim             : 32
f_varobj             : 59 67
f_vars               : 28 29
f_varsobj            : 23
f_verify_func        : 58
f_verify_func_composite : 59
f_verify_type        : 68
f_verify_type_composite : 67
f_while              : 96
fact                 : 78 79
for                  : 49
func                 : 52
funcion              : 14
funciones            : 1 8 9 14
input                : 53
lista_id             : 22 23 26 29
lparen               : 82
params               : 16 17
pparams              : 40 43
return               : 57
rparen               : 82
start                : 0
term                 : 75 76 79
tipo                 : 16 22 26 42 43
to_num               : 55
to_str               : 56 113
var                  : 66 83 105 107 112
vars                 : 1 16 17 22 23
while                : 48
write                : 54
write_list           : 108 109
write_listp          : 109 110

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (2) f_start -> .

    ID              reduce using rule 2 (f_start -> .)

    f_start                        shift and go to state 3

state 3

    (1) start -> PROGRAM f_start . ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ID              shift and go to state 4


state 4

    (1) start -> PROGRAM f_start ID . f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (3) f_prog -> .

    ;               reduce using rule 3 (f_prog -> .)

    f_prog                         shift and go to state 5

state 5

    (1) start -> PROGRAM f_start ID f_prog . ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ;               shift and go to state 6


state 6

    (1) start -> PROGRAM f_start ID f_prog ; . clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> . clases clase
    (7) clases -> . empty
    (115) empty -> .

    TYPE            reduce using rule 115 (empty -> .)
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    clases                         shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) start -> PROGRAM f_start ID f_prog ; clases . vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> clases . clase
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (8) clase -> . TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> . TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
    (115) empty -> .

    TYPE            shift and go to state 12
    DEF             reduce using rule 115 (empty -> .)
    MAIN            reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    vars                           shift and go to state 9
    clase                          shift and go to state 10
    empty                          shift and go to state 11

state 8

    (7) clases -> empty .

    TYPE            reduce using rule 7 (clases -> empty .)
    DEF             reduce using rule 7 (clases -> empty .)
    MAIN            reduce using rule 7 (clases -> empty .)
    FUNC            reduce using rule 7 (clases -> empty .)


state 9

    (1) start -> PROGRAM f_start ID f_prog ; clases vars . funciones MAIN f_main ( ) { estatutos } END f_end ;
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (115) empty -> .

    DEF             shift and go to state 14
    MAIN            reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    funciones                      shift and go to state 13
    empty                          shift and go to state 15

state 10

    (6) clases -> clases clase .

    TYPE            reduce using rule 6 (clases -> clases clase .)
    DEF             reduce using rule 6 (clases -> clases clase .)
    MAIN            reduce using rule 6 (clases -> clases clase .)
    FUNC            reduce using rule 6 (clases -> clases clase .)


state 11

    (24) vars -> empty .

    DEF             reduce using rule 24 (vars -> empty .)
    MAIN            reduce using rule 24 (vars -> empty .)
    FUNC            reduce using rule 24 (vars -> empty .)
    }               reduce using rule 24 (vars -> empty .)
    CALL            reduce using rule 24 (vars -> empty .)
    WHILE           reduce using rule 24 (vars -> empty .)
    FOR             reduce using rule 24 (vars -> empty .)
    IF              reduce using rule 24 (vars -> empty .)
    ID              reduce using rule 24 (vars -> empty .)


state 12

    (8) clase -> TYPE . ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE . ID f_startclass { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 16


state 13

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones . MAIN f_main ( ) { estatutos } END f_end ;
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    MAIN            shift and go to state 17
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 14

    (22) vars -> vars DEF . tipo dimension : lista_id ;
    (23) vars -> vars DEF . ID f_varsobj : lista_id ;
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    ID              shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 20

state 15

    (15) funciones -> empty .

    MAIN            reduce using rule 15 (funciones -> empty .)
    FUNC            reduce using rule 15 (funciones -> empty .)
    }               reduce using rule 15 (funciones -> empty .)


state 16

    (8) clase -> TYPE ID . f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID . f_startclass { cvars f_cvars funciones } f_endclass
    (10) f_startclass -> .

    :               reduce using rule 10 (f_startclass -> .)
    {               reduce using rule 10 (f_startclass -> .)

    f_startclass                   shift and go to state 24

state 17

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN . f_main ( ) { estatutos } END f_end ;
    (4) f_main -> .

    (               reduce using rule 4 (f_main -> .)

    f_main                         shift and go to state 25

state 18

    (14) funciones -> funciones funcion .

    MAIN            reduce using rule 14 (funciones -> funciones funcion .)
    FUNC            reduce using rule 14 (funciones -> funciones funcion .)
    }               reduce using rule 14 (funciones -> funciones funcion .)


state 19

    (16) funcion -> FUNC . ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC . ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    ID              shift and go to state 26


state 20

    (22) vars -> vars DEF tipo . dimension : lista_id ;
    (31) dimension -> . [ expresion f_dim1 ] f_onedim
    (32) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (33) dimension -> . empty
    (115) empty -> .

    [               shift and go to state 28
    :               reduce using rule 115 (empty -> .)

    dimension                      shift and go to state 27
    empty                          shift and go to state 29

state 21

    (23) vars -> vars DEF ID . f_varsobj : lista_id ;
    (25) f_varsobj -> .

    :               reduce using rule 25 (f_varsobj -> .)

    f_varsobj                      shift and go to state 30

state 22

    (38) tipo -> NUMBER .

    [               reduce using rule 38 (tipo -> NUMBER .)
    :               reduce using rule 38 (tipo -> NUMBER .)
    ID              reduce using rule 38 (tipo -> NUMBER .)
    {               reduce using rule 38 (tipo -> NUMBER .)


state 23

    (39) tipo -> STRING .

    [               reduce using rule 39 (tipo -> STRING .)
    :               reduce using rule 39 (tipo -> STRING .)
    ID              reduce using rule 39 (tipo -> STRING .)
    {               reduce using rule 39 (tipo -> STRING .)


state 24

    (8) clase -> TYPE ID f_startclass . : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID f_startclass . { cvars f_cvars funciones } f_endclass

    :               shift and go to state 31
    {               shift and go to state 32


state 25

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main . ( ) { estatutos } END f_end ;

    (               shift and go to state 33


state 26

    (16) funcion -> FUNC ID . f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID . f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (18) f_startfunc -> .

    (               reduce using rule 18 (f_startfunc -> .)

    f_startfunc                    shift and go to state 34

state 27

    (22) vars -> vars DEF tipo dimension . : lista_id ;

    :               shift and go to state 35


state 28

    (31) dimension -> [ . expresion f_dim1 ] f_onedim
    (32) dimension -> [ . expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 36
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 29

    (33) dimension -> empty .

    :               reduce using rule 33 (dimension -> empty .)
    OPFACT          reduce using rule 33 (dimension -> empty .)
    OPTERM          reduce using rule 33 (dimension -> empty .)
    COMP            reduce using rule 33 (dimension -> empty .)
    ]               reduce using rule 33 (dimension -> empty .)
    )               reduce using rule 33 (dimension -> empty .)
    ,               reduce using rule 33 (dimension -> empty .)
    TO              reduce using rule 33 (dimension -> empty .)
    ;               reduce using rule 33 (dimension -> empty .)
    {               reduce using rule 33 (dimension -> empty .)
    &               reduce using rule 33 (dimension -> empty .)
    =               reduce using rule 33 (dimension -> empty .)


state 30

    (23) vars -> vars DEF ID f_varsobj . : lista_id ;

    :               shift and go to state 46


state 31

    (8) clase -> TYPE ID f_startclass : . ID f_clasepadre { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 47


state 32

    (9) clase -> TYPE ID f_startclass { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (115) empty -> .

    DEF             reduce using rule 115 (empty -> .)
    }               reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    cvars                          shift and go to state 48
    empty                          shift and go to state 49

state 33

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( . ) { estatutos } END f_end ;

    )               shift and go to state 50


state 34

    (16) funcion -> FUNC ID f_startfunc . ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc . ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    (               shift and go to state 51


state 35

    (22) vars -> vars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 52

state 36

    (31) dimension -> [ expresion . f_dim1 ] f_onedim
    (32) dimension -> [ expresion . f_dim1 ] [ expresion f_dim2 ] f_twodim
    (73) expresion -> expresion . COMP f_oper exp f_expres
    (34) f_dim1 -> .

    COMP            shift and go to state 55
    ]               reduce using rule 34 (f_dim1 -> .)

    f_dim1                         shift and go to state 54

state 37

    (72) expresion -> exp .
    (76) exp -> exp . OPTERM f_oper term f_exp

    COMP            reduce using rule 72 (expresion -> exp .)
    ]               reduce using rule 72 (expresion -> exp .)
    )               reduce using rule 72 (expresion -> exp .)
    ,               reduce using rule 72 (expresion -> exp .)
    TO              reduce using rule 72 (expresion -> exp .)
    ;               reduce using rule 72 (expresion -> exp .)
    {               reduce using rule 72 (expresion -> exp .)
    OPTERM          shift and go to state 56


state 38

    (75) exp -> term .
    (79) term -> term . OPFACT f_oper fact f_term

    OPTERM          reduce using rule 75 (exp -> term .)
    COMP            reduce using rule 75 (exp -> term .)
    ]               reduce using rule 75 (exp -> term .)
    )               reduce using rule 75 (exp -> term .)
    ,               reduce using rule 75 (exp -> term .)
    TO              reduce using rule 75 (exp -> term .)
    ;               reduce using rule 75 (exp -> term .)
    {               reduce using rule 75 (exp -> term .)
    OPFACT          shift and go to state 57


state 39

    (85) fact -> OPTERM . NUM

    NUM             shift and go to state 58


state 40

    (78) term -> fact .

    OPFACT          reduce using rule 78 (term -> fact .)
    OPTERM          reduce using rule 78 (term -> fact .)
    COMP            reduce using rule 78 (term -> fact .)
    ]               reduce using rule 78 (term -> fact .)
    )               reduce using rule 78 (term -> fact .)
    ,               reduce using rule 78 (term -> fact .)
    TO              reduce using rule 78 (term -> fact .)
    ;               reduce using rule 78 (term -> fact .)
    {               reduce using rule 78 (term -> fact .)


state 41

    (82) fact -> ( . lparen expresion ) rparen
    (87) lparen -> .

    (               reduce using rule 87 (lparen -> .)
    NUM             reduce using rule 87 (lparen -> .)
    OPTERM          reduce using rule 87 (lparen -> .)
    CALL            reduce using rule 87 (lparen -> .)
    ID              reduce using rule 87 (lparen -> .)

    lparen                         shift and go to state 59

state 42

    (83) fact -> var .

    OPFACT          reduce using rule 83 (fact -> var .)
    OPTERM          reduce using rule 83 (fact -> var .)
    COMP            reduce using rule 83 (fact -> var .)
    ]               reduce using rule 83 (fact -> var .)
    )               reduce using rule 83 (fact -> var .)
    ,               reduce using rule 83 (fact -> var .)
    TO              reduce using rule 83 (fact -> var .)
    ;               reduce using rule 83 (fact -> var .)
    {               reduce using rule 83 (fact -> var .)


state 43

    (84) fact -> NUM . f_fact
    (89) f_fact -> .

    OPFACT          reduce using rule 89 (f_fact -> .)
    OPTERM          reduce using rule 89 (f_fact -> .)
    COMP            reduce using rule 89 (f_fact -> .)
    ]               reduce using rule 89 (f_fact -> .)
    )               reduce using rule 89 (f_fact -> .)
    ,               reduce using rule 89 (f_fact -> .)
    TO              reduce using rule 89 (f_fact -> .)
    ;               reduce using rule 89 (f_fact -> .)
    {               reduce using rule 89 (f_fact -> .)

    f_fact                         shift and go to state 60

state 44

    (86) fact -> CALL . call_func
    (52) call_func -> . func
    (53) call_func -> . input
    (54) call_func -> . write
    (55) call_func -> . to_num
    (56) call_func -> . to_str
    (57) call_func -> . return
    (58) func -> . ID f_verify_func ( args )
    (59) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (107) input -> . INPUT ( var )
    (108) write -> . PRINT ( write_list )
    (104) to_num -> . TO_NUMBER ( STR )
    (105) to_num -> . TO_NUMBER ( var )
    (106) to_str -> . TO_STRING ( expresion )
    (114) return -> . RET ( expresion )

    ID              shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    TO_NUMBER       shift and go to state 71
    TO_STRING       shift and go to state 72
    RET             shift and go to state 73

    call_func                      shift and go to state 61
    func                           shift and go to state 62
    input                          shift and go to state 63
    write                          shift and go to state 64
    to_num                         shift and go to state 65
    to_str                         shift and go to state 66
    return                         shift and go to state 67

state 45

    (67) var -> ID . f_varobj : ID f_verify_type_composite dimension
    (68) var -> ID . f_verify_type dimension
    (69) f_varobj -> .
    (70) f_verify_type -> .

    :               reduce using rule 69 (f_varobj -> .)
    [               reduce using rule 70 (f_verify_type -> .)
    OPFACT          reduce using rule 70 (f_verify_type -> .)
    OPTERM          reduce using rule 70 (f_verify_type -> .)
    COMP            reduce using rule 70 (f_verify_type -> .)
    ]               reduce using rule 70 (f_verify_type -> .)
    )               reduce using rule 70 (f_verify_type -> .)
    ,               reduce using rule 70 (f_verify_type -> .)
    TO              reduce using rule 70 (f_verify_type -> .)
    ;               reduce using rule 70 (f_verify_type -> .)
    {               reduce using rule 70 (f_verify_type -> .)
    &               reduce using rule 70 (f_verify_type -> .)
    =               reduce using rule 70 (f_verify_type -> .)

    f_varobj                       shift and go to state 74
    f_verify_type                  shift and go to state 75

state 46

    (23) vars -> vars DEF ID f_varsobj : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 76

state 47

    (8) clase -> TYPE ID f_startclass : ID . f_clasepadre { cvars f_cvars funciones } f_endclass
    (11) f_clasepadre -> .

    {               reduce using rule 11 (f_clasepadre -> .)

    f_clasepadre                   shift and go to state 77

state 48

    (9) clase -> TYPE ID f_startclass { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 79
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 78

state 49

    (27) cvars -> empty .

    DEF             reduce using rule 27 (cvars -> empty .)
    }               reduce using rule 27 (cvars -> empty .)
    FUNC            reduce using rule 27 (cvars -> empty .)


state 50

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) . { estatutos } END f_end ;

    {               shift and go to state 80


state 51

    (16) funcion -> FUNC ID f_startfunc ( . params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( . params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (40) params -> . pparams
    (41) params -> . empty
    (42) pparams -> . tipo ID f_param
    (43) pparams -> . pparams , tipo ID f_param
    (115) empty -> .
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    )               reduce using rule 115 (empty -> .)
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    params                         shift and go to state 81
    tipo                           shift and go to state 82
    pparams                        shift and go to state 83
    empty                          shift and go to state 84

state 52

    (22) vars -> vars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 85
    ,               shift and go to state 86


state 53

    (28) lista_id -> ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 87

state 54

    (31) dimension -> [ expresion f_dim1 . ] f_onedim
    (32) dimension -> [ expresion f_dim1 . ] [ expresion f_dim2 ] f_twodim

    ]               shift and go to state 88


state 55

    (73) expresion -> expresion COMP . f_oper exp f_expres
    (81) f_oper -> .

    (               reduce using rule 81 (f_oper -> .)
    NUM             reduce using rule 81 (f_oper -> .)
    OPTERM          reduce using rule 81 (f_oper -> .)
    CALL            reduce using rule 81 (f_oper -> .)
    ID              reduce using rule 81 (f_oper -> .)

    f_oper                         shift and go to state 89

state 56

    (76) exp -> exp OPTERM . f_oper term f_exp
    (81) f_oper -> .

    (               reduce using rule 81 (f_oper -> .)
    NUM             reduce using rule 81 (f_oper -> .)
    OPTERM          reduce using rule 81 (f_oper -> .)
    CALL            reduce using rule 81 (f_oper -> .)
    ID              reduce using rule 81 (f_oper -> .)

    f_oper                         shift and go to state 90

state 57

    (79) term -> term OPFACT . f_oper fact f_term
    (81) f_oper -> .

    (               reduce using rule 81 (f_oper -> .)
    NUM             reduce using rule 81 (f_oper -> .)
    OPTERM          reduce using rule 81 (f_oper -> .)
    CALL            reduce using rule 81 (f_oper -> .)
    ID              reduce using rule 81 (f_oper -> .)

    f_oper                         shift and go to state 91

state 58

    (85) fact -> OPTERM NUM .

    OPFACT          reduce using rule 85 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 85 (fact -> OPTERM NUM .)
    COMP            reduce using rule 85 (fact -> OPTERM NUM .)
    ]               reduce using rule 85 (fact -> OPTERM NUM .)
    )               reduce using rule 85 (fact -> OPTERM NUM .)
    ,               reduce using rule 85 (fact -> OPTERM NUM .)
    TO              reduce using rule 85 (fact -> OPTERM NUM .)
    ;               reduce using rule 85 (fact -> OPTERM NUM .)
    {               reduce using rule 85 (fact -> OPTERM NUM .)


state 59

    (82) fact -> ( lparen . expresion ) rparen
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 92
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 60

    (84) fact -> NUM f_fact .

    OPFACT          reduce using rule 84 (fact -> NUM f_fact .)
    OPTERM          reduce using rule 84 (fact -> NUM f_fact .)
    COMP            reduce using rule 84 (fact -> NUM f_fact .)
    ]               reduce using rule 84 (fact -> NUM f_fact .)
    )               reduce using rule 84 (fact -> NUM f_fact .)
    ,               reduce using rule 84 (fact -> NUM f_fact .)
    TO              reduce using rule 84 (fact -> NUM f_fact .)
    ;               reduce using rule 84 (fact -> NUM f_fact .)
    {               reduce using rule 84 (fact -> NUM f_fact .)


state 61

    (86) fact -> CALL call_func .

    OPFACT          reduce using rule 86 (fact -> CALL call_func .)
    OPTERM          reduce using rule 86 (fact -> CALL call_func .)
    COMP            reduce using rule 86 (fact -> CALL call_func .)
    ]               reduce using rule 86 (fact -> CALL call_func .)
    )               reduce using rule 86 (fact -> CALL call_func .)
    ,               reduce using rule 86 (fact -> CALL call_func .)
    TO              reduce using rule 86 (fact -> CALL call_func .)
    ;               reduce using rule 86 (fact -> CALL call_func .)
    {               reduce using rule 86 (fact -> CALL call_func .)


state 62

    (52) call_func -> func .

    OPFACT          reduce using rule 52 (call_func -> func .)
    OPTERM          reduce using rule 52 (call_func -> func .)
    COMP            reduce using rule 52 (call_func -> func .)
    ]               reduce using rule 52 (call_func -> func .)
    )               reduce using rule 52 (call_func -> func .)
    ,               reduce using rule 52 (call_func -> func .)
    TO              reduce using rule 52 (call_func -> func .)
    ;               reduce using rule 52 (call_func -> func .)
    {               reduce using rule 52 (call_func -> func .)


state 63

    (53) call_func -> input .

    OPFACT          reduce using rule 53 (call_func -> input .)
    OPTERM          reduce using rule 53 (call_func -> input .)
    COMP            reduce using rule 53 (call_func -> input .)
    ]               reduce using rule 53 (call_func -> input .)
    )               reduce using rule 53 (call_func -> input .)
    ,               reduce using rule 53 (call_func -> input .)
    TO              reduce using rule 53 (call_func -> input .)
    ;               reduce using rule 53 (call_func -> input .)
    {               reduce using rule 53 (call_func -> input .)


state 64

    (54) call_func -> write .

    OPFACT          reduce using rule 54 (call_func -> write .)
    OPTERM          reduce using rule 54 (call_func -> write .)
    COMP            reduce using rule 54 (call_func -> write .)
    ]               reduce using rule 54 (call_func -> write .)
    )               reduce using rule 54 (call_func -> write .)
    ,               reduce using rule 54 (call_func -> write .)
    TO              reduce using rule 54 (call_func -> write .)
    ;               reduce using rule 54 (call_func -> write .)
    {               reduce using rule 54 (call_func -> write .)


state 65

    (55) call_func -> to_num .

    OPFACT          reduce using rule 55 (call_func -> to_num .)
    OPTERM          reduce using rule 55 (call_func -> to_num .)
    COMP            reduce using rule 55 (call_func -> to_num .)
    ]               reduce using rule 55 (call_func -> to_num .)
    )               reduce using rule 55 (call_func -> to_num .)
    ,               reduce using rule 55 (call_func -> to_num .)
    TO              reduce using rule 55 (call_func -> to_num .)
    ;               reduce using rule 55 (call_func -> to_num .)
    {               reduce using rule 55 (call_func -> to_num .)


state 66

    (56) call_func -> to_str .

    OPFACT          reduce using rule 56 (call_func -> to_str .)
    OPTERM          reduce using rule 56 (call_func -> to_str .)
    COMP            reduce using rule 56 (call_func -> to_str .)
    ]               reduce using rule 56 (call_func -> to_str .)
    )               reduce using rule 56 (call_func -> to_str .)
    ,               reduce using rule 56 (call_func -> to_str .)
    TO              reduce using rule 56 (call_func -> to_str .)
    ;               reduce using rule 56 (call_func -> to_str .)
    {               reduce using rule 56 (call_func -> to_str .)


state 67

    (57) call_func -> return .

    OPFACT          reduce using rule 57 (call_func -> return .)
    OPTERM          reduce using rule 57 (call_func -> return .)
    COMP            reduce using rule 57 (call_func -> return .)
    ]               reduce using rule 57 (call_func -> return .)
    )               reduce using rule 57 (call_func -> return .)
    ,               reduce using rule 57 (call_func -> return .)
    TO              reduce using rule 57 (call_func -> return .)
    ;               reduce using rule 57 (call_func -> return .)
    {               reduce using rule 57 (call_func -> return .)


state 68

    (58) func -> ID . f_verify_func ( args )
    (59) func -> ID . f_varobj : ID f_verify_func_composite ( args )
    (60) f_verify_func -> .
    (69) f_varobj -> .

    (               reduce using rule 60 (f_verify_func -> .)
    :               reduce using rule 69 (f_varobj -> .)

    f_verify_func                  shift and go to state 93
    f_varobj                       shift and go to state 94

state 69

    (107) input -> INPUT . ( var )

    (               shift and go to state 95


state 70

    (108) write -> PRINT . ( write_list )

    (               shift and go to state 96


state 71

    (104) to_num -> TO_NUMBER . ( STR )
    (105) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 97


state 72

    (106) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 98


state 73

    (114) return -> RET . ( expresion )

    (               shift and go to state 99


state 74

    (67) var -> ID f_varobj . : ID f_verify_type_composite dimension

    :               shift and go to state 100


state 75

    (68) var -> ID f_verify_type . dimension
    (31) dimension -> . [ expresion f_dim1 ] f_onedim
    (32) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (33) dimension -> . empty
    (115) empty -> .

    [               shift and go to state 28
    OPFACT          reduce using rule 115 (empty -> .)
    OPTERM          reduce using rule 115 (empty -> .)
    COMP            reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)
    {               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    =               reduce using rule 115 (empty -> .)

    dimension                      shift and go to state 101
    empty                          shift and go to state 29

state 76

    (23) vars -> vars DEF ID f_varsobj : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 102
    ,               shift and go to state 86


state 77

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre . { cvars f_cvars funciones } f_endclass

    {               shift and go to state 103


state 78

    (9) clase -> TYPE ID f_startclass { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    funciones                      shift and go to state 104
    empty                          shift and go to state 15

state 79

    (26) cvars -> cvars DEF . tipo dimension : lista_id ;
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 105

state 80

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { . estatutos } END f_end ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 106
    empty                          shift and go to state 107

state 81

    (16) funcion -> FUNC ID f_startfunc ( params . ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params . ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    )               shift and go to state 108


state 82

    (42) pparams -> tipo . ID f_param

    ID              shift and go to state 109


state 83

    (40) params -> pparams .
    (43) pparams -> pparams . , tipo ID f_param

    )               reduce using rule 40 (params -> pparams .)
    ,               shift and go to state 110


state 84

    (41) params -> empty .

    )               reduce using rule 41 (params -> empty .)


state 85

    (22) vars -> vars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    MAIN            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    CALL            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    WHILE           reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FOR             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    IF              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    ID              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)


state 86

    (29) lista_id -> lista_id , . ID f_vars

    ID              shift and go to state 111


state 87

    (28) lista_id -> ID f_vars .

    ;               reduce using rule 28 (lista_id -> ID f_vars .)
    ,               reduce using rule 28 (lista_id -> ID f_vars .)


state 88

    (31) dimension -> [ expresion f_dim1 ] . f_onedim
    (32) dimension -> [ expresion f_dim1 ] . [ expresion f_dim2 ] f_twodim
    (36) f_onedim -> .

    [               shift and go to state 112
    :               reduce using rule 36 (f_onedim -> .)
    OPFACT          reduce using rule 36 (f_onedim -> .)
    OPTERM          reduce using rule 36 (f_onedim -> .)
    COMP            reduce using rule 36 (f_onedim -> .)
    ]               reduce using rule 36 (f_onedim -> .)
    )               reduce using rule 36 (f_onedim -> .)
    ,               reduce using rule 36 (f_onedim -> .)
    TO              reduce using rule 36 (f_onedim -> .)
    ;               reduce using rule 36 (f_onedim -> .)
    {               reduce using rule 36 (f_onedim -> .)
    &               reduce using rule 36 (f_onedim -> .)
    =               reduce using rule 36 (f_onedim -> .)

    f_onedim                       shift and go to state 113

state 89

    (73) expresion -> expresion COMP f_oper . exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    exp                            shift and go to state 114
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 90

    (76) exp -> exp OPTERM f_oper . term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    term                           shift and go to state 115
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 91

    (79) term -> term OPFACT f_oper . fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    fact                           shift and go to state 116
    var                            shift and go to state 42

state 92

    (82) fact -> ( lparen expresion . ) rparen
    (73) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 117
    COMP            shift and go to state 55


state 93

    (58) func -> ID f_verify_func . ( args )

    (               shift and go to state 118


state 94

    (59) func -> ID f_varobj . : ID f_verify_func_composite ( args )

    :               shift and go to state 119


state 95

    (107) input -> INPUT ( . var )
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    ID              shift and go to state 45

    var                            shift and go to state 120

state 96

    (108) write -> PRINT ( . write_list )
    (109) write_list -> . write_list & write_listp
    (110) write_list -> . write_listp
    (111) write_listp -> . STR
    (112) write_listp -> . var
    (113) write_listp -> . CALL to_str
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    STR             shift and go to state 123
    CALL            shift and go to state 125
    ID              shift and go to state 45

    write_list                     shift and go to state 121
    write_listp                    shift and go to state 122
    var                            shift and go to state 124

state 97

    (104) to_num -> TO_NUMBER ( . STR )
    (105) to_num -> TO_NUMBER ( . var )
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    STR             shift and go to state 126
    ID              shift and go to state 45

    var                            shift and go to state 127

state 98

    (106) to_str -> TO_STRING ( . expresion )
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 128
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 99

    (114) return -> RET ( . expresion )
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 129
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 100

    (67) var -> ID f_varobj : . ID f_verify_type_composite dimension

    ID              shift and go to state 130


state 101

    (68) var -> ID f_verify_type dimension .

    OPFACT          reduce using rule 68 (var -> ID f_verify_type dimension .)
    OPTERM          reduce using rule 68 (var -> ID f_verify_type dimension .)
    COMP            reduce using rule 68 (var -> ID f_verify_type dimension .)
    ]               reduce using rule 68 (var -> ID f_verify_type dimension .)
    )               reduce using rule 68 (var -> ID f_verify_type dimension .)
    ,               reduce using rule 68 (var -> ID f_verify_type dimension .)
    TO              reduce using rule 68 (var -> ID f_verify_type dimension .)
    ;               reduce using rule 68 (var -> ID f_verify_type dimension .)
    {               reduce using rule 68 (var -> ID f_verify_type dimension .)
    &               reduce using rule 68 (var -> ID f_verify_type dimension .)
    =               reduce using rule 68 (var -> ID f_verify_type dimension .)


state 102

    (23) vars -> vars DEF ID f_varsobj : lista_id ; .

    DEF             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    MAIN            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FUNC            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    }               reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    CALL            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    WHILE           reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FOR             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    IF              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    ID              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id ; .)


state 103

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (115) empty -> .

    DEF             reduce using rule 115 (empty -> .)
    }               reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    cvars                          shift and go to state 131
    empty                          shift and go to state 49

state 104

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 132
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 105

    (26) cvars -> cvars DEF tipo . dimension : lista_id ;
    (31) dimension -> . [ expresion f_dim1 ] f_onedim
    (32) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (33) dimension -> . empty
    (115) empty -> .

    [               shift and go to state 28
    :               reduce using rule 115 (empty -> .)

    dimension                      shift and go to state 133
    empty                          shift and go to state 29

state 106

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos . } END f_end ;
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 134
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 107

    (46) estatutos -> empty .

    }               reduce using rule 46 (estatutos -> empty .)
    CALL            reduce using rule 46 (estatutos -> empty .)
    WHILE           reduce using rule 46 (estatutos -> empty .)
    FOR             reduce using rule 46 (estatutos -> empty .)
    IF              reduce using rule 46 (estatutos -> empty .)
    ID              reduce using rule 46 (estatutos -> empty .)


state 108

    (16) funcion -> FUNC ID f_startfunc ( params ) . : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) . : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    :               shift and go to state 145


state 109

    (42) pparams -> tipo ID . f_param
    (44) f_param -> .

    ,               reduce using rule 44 (f_param -> .)
    )               reduce using rule 44 (f_param -> .)

    f_param                        shift and go to state 146

state 110

    (43) pparams -> pparams , . tipo ID f_param
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 147

state 111

    (29) lista_id -> lista_id , ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 148

state 112

    (32) dimension -> [ expresion f_dim1 ] [ . expresion f_dim2 ] f_twodim
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 149
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 113

    (31) dimension -> [ expresion f_dim1 ] f_onedim .

    :               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    OPFACT          reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    OPTERM          reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    COMP            reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ]               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    )               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ,               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    TO              reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ;               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    {               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    &               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)
    =               reduce using rule 31 (dimension -> [ expresion f_dim1 ] f_onedim .)


state 114

    (73) expresion -> expresion COMP f_oper exp . f_expres
    (76) exp -> exp . OPTERM f_oper term f_exp
    (74) f_expres -> .

    OPTERM          shift and go to state 56
    COMP            reduce using rule 74 (f_expres -> .)
    ]               reduce using rule 74 (f_expres -> .)
    )               reduce using rule 74 (f_expres -> .)
    ,               reduce using rule 74 (f_expres -> .)
    TO              reduce using rule 74 (f_expres -> .)
    ;               reduce using rule 74 (f_expres -> .)
    {               reduce using rule 74 (f_expres -> .)

    f_expres                       shift and go to state 150

state 115

    (76) exp -> exp OPTERM f_oper term . f_exp
    (79) term -> term . OPFACT f_oper fact f_term
    (77) f_exp -> .

    OPFACT          shift and go to state 57
    OPTERM          reduce using rule 77 (f_exp -> .)
    COMP            reduce using rule 77 (f_exp -> .)
    ]               reduce using rule 77 (f_exp -> .)
    )               reduce using rule 77 (f_exp -> .)
    ,               reduce using rule 77 (f_exp -> .)
    TO              reduce using rule 77 (f_exp -> .)
    ;               reduce using rule 77 (f_exp -> .)
    {               reduce using rule 77 (f_exp -> .)

    f_exp                          shift and go to state 151

state 116

    (79) term -> term OPFACT f_oper fact . f_term
    (80) f_term -> .

    OPFACT          reduce using rule 80 (f_term -> .)
    OPTERM          reduce using rule 80 (f_term -> .)
    COMP            reduce using rule 80 (f_term -> .)
    ]               reduce using rule 80 (f_term -> .)
    )               reduce using rule 80 (f_term -> .)
    ,               reduce using rule 80 (f_term -> .)
    TO              reduce using rule 80 (f_term -> .)
    ;               reduce using rule 80 (f_term -> .)
    {               reduce using rule 80 (f_term -> .)

    f_term                         shift and go to state 152

state 117

    (82) fact -> ( lparen expresion ) . rparen
    (88) rparen -> .

    OPFACT          reduce using rule 88 (rparen -> .)
    OPTERM          reduce using rule 88 (rparen -> .)
    COMP            reduce using rule 88 (rparen -> .)
    ]               reduce using rule 88 (rparen -> .)
    )               reduce using rule 88 (rparen -> .)
    ,               reduce using rule 88 (rparen -> .)
    TO              reduce using rule 88 (rparen -> .)
    ;               reduce using rule 88 (rparen -> .)
    {               reduce using rule 88 (rparen -> .)

    rparen                         shift and go to state 153

state 118

    (58) func -> ID f_verify_func ( . args )
    (62) args -> . args_list
    (63) args -> . empty
    (64) args_list -> . expresion
    (65) args_list -> . args_list , expresion
    (115) empty -> .
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    )               reduce using rule 115 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 154
    args_list                      shift and go to state 155
    empty                          shift and go to state 156
    expresion                      shift and go to state 157
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 119

    (59) func -> ID f_varobj : . ID f_verify_func_composite ( args )

    ID              shift and go to state 158


state 120

    (107) input -> INPUT ( var . )

    )               shift and go to state 159


state 121

    (108) write -> PRINT ( write_list . )
    (109) write_list -> write_list . & write_listp

    )               shift and go to state 160
    &               shift and go to state 161


state 122

    (110) write_list -> write_listp .

    )               reduce using rule 110 (write_list -> write_listp .)
    &               reduce using rule 110 (write_list -> write_listp .)


state 123

    (111) write_listp -> STR .

    )               reduce using rule 111 (write_listp -> STR .)
    &               reduce using rule 111 (write_listp -> STR .)


state 124

    (112) write_listp -> var .

    )               reduce using rule 112 (write_listp -> var .)
    &               reduce using rule 112 (write_listp -> var .)


state 125

    (113) write_listp -> CALL . to_str
    (106) to_str -> . TO_STRING ( expresion )

    TO_STRING       shift and go to state 72

    to_str                         shift and go to state 162

state 126

    (104) to_num -> TO_NUMBER ( STR . )

    )               shift and go to state 163


state 127

    (105) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 164


state 128

    (106) to_str -> TO_STRING ( expresion . )
    (73) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 165
    COMP            shift and go to state 55


state 129

    (114) return -> RET ( expresion . )
    (73) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 166
    COMP            shift and go to state 55


state 130

    (67) var -> ID f_varobj : ID . f_verify_type_composite dimension
    (71) f_verify_type_composite -> .

    [               reduce using rule 71 (f_verify_type_composite -> .)
    OPFACT          reduce using rule 71 (f_verify_type_composite -> .)
    OPTERM          reduce using rule 71 (f_verify_type_composite -> .)
    COMP            reduce using rule 71 (f_verify_type_composite -> .)
    ]               reduce using rule 71 (f_verify_type_composite -> .)
    )               reduce using rule 71 (f_verify_type_composite -> .)
    ,               reduce using rule 71 (f_verify_type_composite -> .)
    TO              reduce using rule 71 (f_verify_type_composite -> .)
    ;               reduce using rule 71 (f_verify_type_composite -> .)
    {               reduce using rule 71 (f_verify_type_composite -> .)
    &               reduce using rule 71 (f_verify_type_composite -> .)
    =               reduce using rule 71 (f_verify_type_composite -> .)

    f_verify_type_composite        shift and go to state 167

state 131

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 79
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 168

state 132

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 169

state 133

    (26) cvars -> cvars DEF tipo dimension . : lista_id ;

    :               shift and go to state 170


state 134

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } . END f_end ;

    END             shift and go to state 171


state 135

    (45) estatutos -> estatutos estatuto .

    }               reduce using rule 45 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 45 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 45 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 45 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 45 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 45 (estatutos -> estatutos estatuto .)


state 136

    (47) estatuto -> asignacion .

    }               reduce using rule 47 (estatuto -> asignacion .)
    CALL            reduce using rule 47 (estatuto -> asignacion .)
    WHILE           reduce using rule 47 (estatuto -> asignacion .)
    FOR             reduce using rule 47 (estatuto -> asignacion .)
    IF              reduce using rule 47 (estatuto -> asignacion .)
    ID              reduce using rule 47 (estatuto -> asignacion .)


state 137

    (48) estatuto -> while .

    }               reduce using rule 48 (estatuto -> while .)
    CALL            reduce using rule 48 (estatuto -> while .)
    WHILE           reduce using rule 48 (estatuto -> while .)
    FOR             reduce using rule 48 (estatuto -> while .)
    IF              reduce using rule 48 (estatuto -> while .)
    ID              reduce using rule 48 (estatuto -> while .)


state 138

    (49) estatuto -> for .

    }               reduce using rule 49 (estatuto -> for .)
    CALL            reduce using rule 49 (estatuto -> for .)
    WHILE           reduce using rule 49 (estatuto -> for .)
    FOR             reduce using rule 49 (estatuto -> for .)
    IF              reduce using rule 49 (estatuto -> for .)
    ID              reduce using rule 49 (estatuto -> for .)


state 139

    (50) estatuto -> condicion .

    }               reduce using rule 50 (estatuto -> condicion .)
    CALL            reduce using rule 50 (estatuto -> condicion .)
    WHILE           reduce using rule 50 (estatuto -> condicion .)
    FOR             reduce using rule 50 (estatuto -> condicion .)
    IF              reduce using rule 50 (estatuto -> condicion .)
    ID              reduce using rule 50 (estatuto -> condicion .)


state 140

    (51) estatuto -> CALL . call_func ;
    (52) call_func -> . func
    (53) call_func -> . input
    (54) call_func -> . write
    (55) call_func -> . to_num
    (56) call_func -> . to_str
    (57) call_func -> . return
    (58) func -> . ID f_verify_func ( args )
    (59) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (107) input -> . INPUT ( var )
    (108) write -> . PRINT ( write_list )
    (104) to_num -> . TO_NUMBER ( STR )
    (105) to_num -> . TO_NUMBER ( var )
    (106) to_str -> . TO_STRING ( expresion )
    (114) return -> . RET ( expresion )

    ID              shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    TO_NUMBER       shift and go to state 71
    TO_STRING       shift and go to state 72
    RET             shift and go to state 73

    call_func                      shift and go to state 172
    func                           shift and go to state 62
    input                          shift and go to state 63
    write                          shift and go to state 64
    to_num                         shift and go to state 65
    to_str                         shift and go to state 66
    return                         shift and go to state 67

state 141

    (66) asignacion -> var . = f_oper expresion ;

    =               shift and go to state 173


state 142

    (96) while -> WHILE . f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (97) f_while -> .

    (               reduce using rule 97 (f_while -> .)

    f_while                        shift and go to state 174

state 143

    (100) for -> FOR . expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 175
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 144

    (90) condicion -> IF . ( expresion ) f_if THEN { estatutos } condicionp f_endif

    (               shift and go to state 176


state 145

    (16) funcion -> FUNC ID f_startfunc ( params ) : . tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) : . NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (38) tipo -> . NUMBER
    (39) tipo -> . STRING

    NOTHING         shift and go to state 178
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 177

state 146

    (42) pparams -> tipo ID f_param .

    ,               reduce using rule 42 (pparams -> tipo ID f_param .)
    )               reduce using rule 42 (pparams -> tipo ID f_param .)


state 147

    (43) pparams -> pparams , tipo . ID f_param

    ID              shift and go to state 179


state 148

    (29) lista_id -> lista_id , ID f_vars .

    ;               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)
    ,               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)


state 149

    (32) dimension -> [ expresion f_dim1 ] [ expresion . f_dim2 ] f_twodim
    (73) expresion -> expresion . COMP f_oper exp f_expres
    (35) f_dim2 -> .

    COMP            shift and go to state 55
    ]               reduce using rule 35 (f_dim2 -> .)

    f_dim2                         shift and go to state 180

state 150

    (73) expresion -> expresion COMP f_oper exp f_expres .

    COMP            reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    ]               reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    )               reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    ,               reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    TO              reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    ;               reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)
    {               reduce using rule 73 (expresion -> expresion COMP f_oper exp f_expres .)


state 151

    (76) exp -> exp OPTERM f_oper term f_exp .

    OPTERM          reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    COMP            reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    ]               reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    )               reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    ,               reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    TO              reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    ;               reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)
    {               reduce using rule 76 (exp -> exp OPTERM f_oper term f_exp .)


state 152

    (79) term -> term OPFACT f_oper fact f_term .

    OPFACT          reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    OPTERM          reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    COMP            reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    ]               reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    )               reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    ,               reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    TO              reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    ;               reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)
    {               reduce using rule 79 (term -> term OPFACT f_oper fact f_term .)


state 153

    (82) fact -> ( lparen expresion ) rparen .

    OPFACT          reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    OPTERM          reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    COMP            reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    ]               reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    )               reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    ,               reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    TO              reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    ;               reduce using rule 82 (fact -> ( lparen expresion ) rparen .)
    {               reduce using rule 82 (fact -> ( lparen expresion ) rparen .)


state 154

    (58) func -> ID f_verify_func ( args . )

    )               shift and go to state 181


state 155

    (62) args -> args_list .
    (65) args_list -> args_list . , expresion

    )               reduce using rule 62 (args -> args_list .)
    ,               shift and go to state 182


state 156

    (63) args -> empty .

    )               reduce using rule 63 (args -> empty .)


state 157

    (64) args_list -> expresion .
    (73) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 64 (args_list -> expresion .)
    )               reduce using rule 64 (args_list -> expresion .)
    COMP            shift and go to state 55


state 158

    (59) func -> ID f_varobj : ID . f_verify_func_composite ( args )
    (61) f_verify_func_composite -> .

    (               reduce using rule 61 (f_verify_func_composite -> .)

    f_verify_func_composite        shift and go to state 183

state 159

    (107) input -> INPUT ( var ) .

    OPFACT          reduce using rule 107 (input -> INPUT ( var ) .)
    OPTERM          reduce using rule 107 (input -> INPUT ( var ) .)
    COMP            reduce using rule 107 (input -> INPUT ( var ) .)
    ]               reduce using rule 107 (input -> INPUT ( var ) .)
    )               reduce using rule 107 (input -> INPUT ( var ) .)
    ,               reduce using rule 107 (input -> INPUT ( var ) .)
    TO              reduce using rule 107 (input -> INPUT ( var ) .)
    ;               reduce using rule 107 (input -> INPUT ( var ) .)
    {               reduce using rule 107 (input -> INPUT ( var ) .)


state 160

    (108) write -> PRINT ( write_list ) .

    OPFACT          reduce using rule 108 (write -> PRINT ( write_list ) .)
    OPTERM          reduce using rule 108 (write -> PRINT ( write_list ) .)
    COMP            reduce using rule 108 (write -> PRINT ( write_list ) .)
    ]               reduce using rule 108 (write -> PRINT ( write_list ) .)
    )               reduce using rule 108 (write -> PRINT ( write_list ) .)
    ,               reduce using rule 108 (write -> PRINT ( write_list ) .)
    TO              reduce using rule 108 (write -> PRINT ( write_list ) .)
    ;               reduce using rule 108 (write -> PRINT ( write_list ) .)
    {               reduce using rule 108 (write -> PRINT ( write_list ) .)


state 161

    (109) write_list -> write_list & . write_listp
    (111) write_listp -> . STR
    (112) write_listp -> . var
    (113) write_listp -> . CALL to_str
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    STR             shift and go to state 123
    CALL            shift and go to state 125
    ID              shift and go to state 45

    write_listp                    shift and go to state 184
    var                            shift and go to state 124

state 162

    (113) write_listp -> CALL to_str .

    )               reduce using rule 113 (write_listp -> CALL to_str .)
    &               reduce using rule 113 (write_listp -> CALL to_str .)


state 163

    (104) to_num -> TO_NUMBER ( STR ) .

    OPFACT          reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    OPTERM          reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    COMP            reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    ]               reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    )               reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    ,               reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    TO              reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    ;               reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)
    {               reduce using rule 104 (to_num -> TO_NUMBER ( STR ) .)


state 164

    (105) to_num -> TO_NUMBER ( var ) .

    OPFACT          reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    ;               reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 105 (to_num -> TO_NUMBER ( var ) .)


state 165

    (106) to_str -> TO_STRING ( expresion ) .

    OPFACT          reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    ;               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)
    &               reduce using rule 106 (to_str -> TO_STRING ( expresion ) .)


state 166

    (114) return -> RET ( expresion ) .

    OPFACT          reduce using rule 114 (return -> RET ( expresion ) .)
    OPTERM          reduce using rule 114 (return -> RET ( expresion ) .)
    COMP            reduce using rule 114 (return -> RET ( expresion ) .)
    ]               reduce using rule 114 (return -> RET ( expresion ) .)
    )               reduce using rule 114 (return -> RET ( expresion ) .)
    ,               reduce using rule 114 (return -> RET ( expresion ) .)
    TO              reduce using rule 114 (return -> RET ( expresion ) .)
    ;               reduce using rule 114 (return -> RET ( expresion ) .)
    {               reduce using rule 114 (return -> RET ( expresion ) .)


state 167

    (67) var -> ID f_varobj : ID f_verify_type_composite . dimension
    (31) dimension -> . [ expresion f_dim1 ] f_onedim
    (32) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (33) dimension -> . empty
    (115) empty -> .

    [               shift and go to state 28
    OPFACT          reduce using rule 115 (empty -> .)
    OPTERM          reduce using rule 115 (empty -> .)
    COMP            reduce using rule 115 (empty -> .)
    ]               reduce using rule 115 (empty -> .)
    )               reduce using rule 115 (empty -> .)
    ,               reduce using rule 115 (empty -> .)
    TO              reduce using rule 115 (empty -> .)
    ;               reduce using rule 115 (empty -> .)
    {               reduce using rule 115 (empty -> .)
    &               reduce using rule 115 (empty -> .)
    =               reduce using rule 115 (empty -> .)

    dimension                      shift and go to state 185
    empty                          shift and go to state 29

state 168

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    FUNC            reduce using rule 115 (empty -> .)

    funciones                      shift and go to state 186
    empty                          shift and go to state 15

state 169

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)


state 170

    (26) cvars -> cvars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 187

state 171

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END . f_end ;
    (5) f_end -> .

    ;               reduce using rule 5 (f_end -> .)

    f_end                          shift and go to state 188

state 172

    (51) estatuto -> CALL call_func . ;

    ;               shift and go to state 189


state 173

    (66) asignacion -> var = . f_oper expresion ;
    (81) f_oper -> .

    (               reduce using rule 81 (f_oper -> .)
    NUM             reduce using rule 81 (f_oper -> .)
    OPTERM          reduce using rule 81 (f_oper -> .)
    CALL            reduce using rule 81 (f_oper -> .)
    ID              reduce using rule 81 (f_oper -> .)

    f_oper                         shift and go to state 190

state 174

    (96) while -> WHILE f_while . ( expresion f_exprwhile ) DO { estatutos } f_endwhile

    (               shift and go to state 191


state 175

    (100) for -> FOR expresion . f_for_start TO expresion f_for_to { estatutos } f_for_end
    (73) expresion -> expresion . COMP f_oper exp f_expres
    (101) f_for_start -> .

    COMP            shift and go to state 55
    TO              reduce using rule 101 (f_for_start -> .)

    f_for_start                    shift and go to state 192

state 176

    (90) condicion -> IF ( . expresion ) f_if THEN { estatutos } condicionp f_endif
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 193
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 177

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 194

state 178

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING . f_nothing f_tipofunc { vars estatutos } f_endfunc
    (19) f_nothing -> .

    {               reduce using rule 19 (f_nothing -> .)

    f_nothing                      shift and go to state 195

state 179

    (43) pparams -> pparams , tipo ID . f_param
    (44) f_param -> .

    ,               reduce using rule 44 (f_param -> .)
    )               reduce using rule 44 (f_param -> .)

    f_param                        shift and go to state 196

state 180

    (32) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 . ] f_twodim

    ]               shift and go to state 197


state 181

    (58) func -> ID f_verify_func ( args ) .

    OPFACT          reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    OPTERM          reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    COMP            reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    ]               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    )               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    ,               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    TO              reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    ;               reduce using rule 58 (func -> ID f_verify_func ( args ) .)
    {               reduce using rule 58 (func -> ID f_verify_func ( args ) .)


state 182

    (65) args_list -> args_list , . expresion
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 198
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 183

    (59) func -> ID f_varobj : ID f_verify_func_composite . ( args )

    (               shift and go to state 199


state 184

    (109) write_list -> write_list & write_listp .

    )               reduce using rule 109 (write_list -> write_list & write_listp .)
    &               reduce using rule 109 (write_list -> write_list & write_listp .)


state 185

    (67) var -> ID f_varobj : ID f_verify_type_composite dimension .

    OPFACT          reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    OPTERM          reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    COMP            reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ]               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    )               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ,               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    TO              reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ;               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    {               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    &               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    =               reduce using rule 67 (var -> ID f_varobj : ID f_verify_type_composite dimension .)


state 186

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 200
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 187

    (26) cvars -> cvars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 201
    ,               shift and go to state 86


state 188

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end . ;

    ;               shift and go to state 202


state 189

    (51) estatuto -> CALL call_func ; .

    }               reduce using rule 51 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 51 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 51 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 51 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 51 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 51 (estatuto -> CALL call_func ; .)


state 190

    (66) asignacion -> var = f_oper . expresion ;
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 42
    expresion                      shift and go to state 203
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40

state 191

    (96) while -> WHILE f_while ( . expresion f_exprwhile ) DO { estatutos } f_endwhile
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 204
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 192

    (100) for -> FOR expresion f_for_start . TO expresion f_for_to { estatutos } f_for_end

    TO              shift and go to state 205


state 193

    (90) condicion -> IF ( expresion . ) f_if THEN { estatutos } condicionp f_endif
    (73) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 206
    COMP            shift and go to state 55


state 194

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 207


state 195

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 208

state 196

    (43) pparams -> pparams , tipo ID f_param .

    ,               reduce using rule 43 (pparams -> pparams , tipo ID f_param .)
    )               reduce using rule 43 (pparams -> pparams , tipo ID f_param .)


state 197

    (32) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] . f_twodim
    (37) f_twodim -> .

    :               reduce using rule 37 (f_twodim -> .)
    OPFACT          reduce using rule 37 (f_twodim -> .)
    OPTERM          reduce using rule 37 (f_twodim -> .)
    COMP            reduce using rule 37 (f_twodim -> .)
    ]               reduce using rule 37 (f_twodim -> .)
    )               reduce using rule 37 (f_twodim -> .)
    ,               reduce using rule 37 (f_twodim -> .)
    TO              reduce using rule 37 (f_twodim -> .)
    ;               reduce using rule 37 (f_twodim -> .)
    {               reduce using rule 37 (f_twodim -> .)
    &               reduce using rule 37 (f_twodim -> .)
    =               reduce using rule 37 (f_twodim -> .)

    f_twodim                       shift and go to state 209

state 198

    (65) args_list -> args_list , expresion .
    (73) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 65 (args_list -> args_list , expresion .)
    )               reduce using rule 65 (args_list -> args_list , expresion .)
    COMP            shift and go to state 55


state 199

    (59) func -> ID f_varobj : ID f_verify_func_composite ( . args )
    (62) args -> . args_list
    (63) args -> . empty
    (64) args_list -> . expresion
    (65) args_list -> . args_list , expresion
    (115) empty -> .
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    )               reduce using rule 115 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 210
    args_list                      shift and go to state 155
    empty                          shift and go to state 156
    expresion                      shift and go to state 157
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 200

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 211

state 201

    (26) cvars -> cvars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)


state 202

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .

    $end            reduce using rule 1 (start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .)


state 203

    (66) asignacion -> var = f_oper expresion . ;
    (73) expresion -> expresion . COMP f_oper exp f_expres

    ;               shift and go to state 212
    COMP            shift and go to state 55


state 204

    (96) while -> WHILE f_while ( expresion . f_exprwhile ) DO { estatutos } f_endwhile
    (73) expresion -> expresion . COMP f_oper exp f_expres
    (98) f_exprwhile -> .

    COMP            shift and go to state 55
    )               reduce using rule 98 (f_exprwhile -> .)

    f_exprwhile                    shift and go to state 213

state 205

    (100) for -> FOR expresion f_for_start TO . expresion f_for_to { estatutos } f_for_end
    (72) expresion -> . exp
    (73) expresion -> . expresion COMP f_oper exp f_expres
    (75) exp -> . term
    (76) exp -> . exp OPTERM f_oper term f_exp
    (78) term -> . fact
    (79) term -> . term OPFACT f_oper fact f_term
    (82) fact -> . ( lparen expresion ) rparen
    (83) fact -> . var
    (84) fact -> . NUM f_fact
    (85) fact -> . OPTERM NUM
    (86) fact -> . CALL call_func
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 214
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 206

    (90) condicion -> IF ( expresion ) . f_if THEN { estatutos } condicionp f_endif
    (93) f_if -> .

    THEN            reduce using rule 93 (f_if -> .)

    f_if                           shift and go to state 215

state 207

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (115) empty -> .

    DEF             reduce using rule 115 (empty -> .)
    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    vars                           shift and go to state 216
    empty                          shift and go to state 11

state 208

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 217


state 209

    (32) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .

    :               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    OPFACT          reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    OPTERM          reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    COMP            reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ]               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    )               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ,               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    TO              reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ;               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    {               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    &               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    =               reduce using rule 32 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)


state 210

    (59) func -> ID f_varobj : ID f_verify_func_composite ( args . )

    )               shift and go to state 218


state 211

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)


state 212

    (66) asignacion -> var = f_oper expresion ; .

    }               reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    CALL            reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    WHILE           reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    FOR             reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    IF              reduce using rule 66 (asignacion -> var = f_oper expresion ; .)
    ID              reduce using rule 66 (asignacion -> var = f_oper expresion ; .)


state 213

    (96) while -> WHILE f_while ( expresion f_exprwhile . ) DO { estatutos } f_endwhile

    )               shift and go to state 219


state 214

    (100) for -> FOR expresion f_for_start TO expresion . f_for_to { estatutos } f_for_end
    (73) expresion -> expresion . COMP f_oper exp f_expres
    (102) f_for_to -> .

    COMP            shift and go to state 55
    {               reduce using rule 102 (f_for_to -> .)

    f_for_to                       shift and go to state 220

state 215

    (90) condicion -> IF ( expresion ) f_if . THEN { estatutos } condicionp f_endif

    THEN            shift and go to state 221


state 216

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 222
    empty                          shift and go to state 107

state 217

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id ;
    (24) vars -> . empty
    (115) empty -> .

    DEF             reduce using rule 115 (empty -> .)
    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    vars                           shift and go to state 223
    empty                          shift and go to state 11

state 218

    (59) func -> ID f_varobj : ID f_verify_func_composite ( args ) .

    OPFACT          reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPTERM          reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    COMP            reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ]               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    )               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ,               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    TO              reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ;               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    {               reduce using rule 59 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)


state 219

    (96) while -> WHILE f_while ( expresion f_exprwhile ) . DO { estatutos } f_endwhile

    DO              shift and go to state 224


state 220

    (100) for -> FOR expresion f_for_start TO expresion f_for_to . { estatutos } f_for_end

    {               shift and go to state 225


state 221

    (90) condicion -> IF ( expresion ) f_if THEN . { estatutos } condicionp f_endif

    {               shift and go to state 226


state 222

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos . } f_endfunc
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 227
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 223

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id ;
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 228
    empty                          shift and go to state 107

state 224

    (96) while -> WHILE f_while ( expresion f_exprwhile ) DO . { estatutos } f_endwhile

    {               shift and go to state 229


state 225

    (100) for -> FOR expresion f_for_start TO expresion f_for_to { . estatutos } f_for_end
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 230
    empty                          shift and go to state 107

state 226

    (90) condicion -> IF ( expresion ) f_if THEN { . estatutos } condicionp f_endif
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 231
    empty                          shift and go to state 107

state 227

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 232

state 228

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos . } f_endfunc
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 233
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 229

    (96) while -> WHILE f_while ( expresion f_exprwhile ) DO { . estatutos } f_endwhile
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 234
    empty                          shift and go to state 107

state 230

    (100) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos . } f_for_end
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 235
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 231

    (90) condicion -> IF ( expresion ) f_if THEN { estatutos . } condicionp f_endif
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 236
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 232

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)


state 233

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 237

state 234

    (96) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos . } f_endwhile
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 238
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 235

    (100) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } . f_for_end
    (103) f_for_end -> .

    }               reduce using rule 103 (f_for_end -> .)
    CALL            reduce using rule 103 (f_for_end -> .)
    WHILE           reduce using rule 103 (f_for_end -> .)
    FOR             reduce using rule 103 (f_for_end -> .)
    IF              reduce using rule 103 (f_for_end -> .)
    ID              reduce using rule 103 (f_for_end -> .)

    f_for_end                      shift and go to state 239

state 236

    (90) condicion -> IF ( expresion ) f_if THEN { estatutos } . condicionp f_endif
    (91) condicionp -> . ELSE f_else { estatutos }
    (92) condicionp -> . empty
    (115) empty -> .

    ELSE            shift and go to state 241
    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    condicionp                     shift and go to state 240
    empty                          shift and go to state 242

state 237

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)


state 238

    (96) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } . f_endwhile
    (99) f_endwhile -> .

    }               reduce using rule 99 (f_endwhile -> .)
    CALL            reduce using rule 99 (f_endwhile -> .)
    WHILE           reduce using rule 99 (f_endwhile -> .)
    FOR             reduce using rule 99 (f_endwhile -> .)
    IF              reduce using rule 99 (f_endwhile -> .)
    ID              reduce using rule 99 (f_endwhile -> .)

    f_endwhile                     shift and go to state 243

state 239

    (100) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .

    }               reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    CALL            reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    WHILE           reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    FOR             reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    IF              reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    ID              reduce using rule 100 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)


state 240

    (90) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp . f_endif
    (94) f_endif -> .

    }               reduce using rule 94 (f_endif -> .)
    CALL            reduce using rule 94 (f_endif -> .)
    WHILE           reduce using rule 94 (f_endif -> .)
    FOR             reduce using rule 94 (f_endif -> .)
    IF              reduce using rule 94 (f_endif -> .)
    ID              reduce using rule 94 (f_endif -> .)

    f_endif                        shift and go to state 244

state 241

    (91) condicionp -> ELSE . f_else { estatutos }
    (95) f_else -> .

    {               reduce using rule 95 (f_else -> .)

    f_else                         shift and go to state 245

state 242

    (92) condicionp -> empty .

    }               reduce using rule 92 (condicionp -> empty .)
    CALL            reduce using rule 92 (condicionp -> empty .)
    WHILE           reduce using rule 92 (condicionp -> empty .)
    FOR             reduce using rule 92 (condicionp -> empty .)
    IF              reduce using rule 92 (condicionp -> empty .)
    ID              reduce using rule 92 (condicionp -> empty .)


state 243

    (96) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .

    }               reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    CALL            reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    WHILE           reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    FOR             reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    IF              reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    ID              reduce using rule 96 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)


state 244

    (90) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .

    }               reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    CALL            reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    WHILE           reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    FOR             reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    IF              reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    ID              reduce using rule 90 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)


state 245

    (91) condicionp -> ELSE f_else . { estatutos }

    {               shift and go to state 246


state 246

    (91) condicionp -> ELSE f_else { . estatutos }
    (45) estatutos -> . estatutos estatuto
    (46) estatutos -> . empty
    (115) empty -> .

    }               reduce using rule 115 (empty -> .)
    CALL            reduce using rule 115 (empty -> .)
    WHILE           reduce using rule 115 (empty -> .)
    FOR             reduce using rule 115 (empty -> .)
    IF              reduce using rule 115 (empty -> .)
    ID              reduce using rule 115 (empty -> .)

    estatutos                      shift and go to state 247
    empty                          shift and go to state 107

state 247

    (91) condicionp -> ELSE f_else { estatutos . }
    (45) estatutos -> estatutos . estatuto
    (47) estatuto -> . asignacion
    (48) estatuto -> . while
    (49) estatuto -> . for
    (50) estatuto -> . condicion
    (51) estatuto -> . CALL call_func ;
    (66) asignacion -> . var = f_oper expresion ;
    (96) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (100) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (90) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (67) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (68) var -> . ID f_verify_type dimension

    }               shift and go to state 248
    CALL            shift and go to state 140
    WHILE           shift and go to state 142
    FOR             shift and go to state 143
    IF              shift and go to state 144
    ID              shift and go to state 45

    estatuto                       shift and go to state 135
    asignacion                     shift and go to state 136
    while                          shift and go to state 137
    for                            shift and go to state 138
    condicion                      shift and go to state 139
    var                            shift and go to state 141

state 248

    (91) condicionp -> ELSE f_else { estatutos } .

    }               reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)
    CALL            reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)
    WHILE           reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)
    FOR             reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)
    IF              reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)
    ID              reduce using rule 91 (condicionp -> ELSE f_else { estatutos } .)

