Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
Rule 2     f_start -> <empty>
Rule 3     f_prog -> <empty>
Rule 4     f_main -> <empty>
Rule 5     f_end -> <empty>
Rule 6     clases -> clases clase
Rule 7     clases -> empty
Rule 8     clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
Rule 9     clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
Rule 10    f_startclass -> <empty>
Rule 11    f_clasepadre -> <empty>
Rule 12    cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim
Rule 13    cvars -> empty
Rule 14    f_cvars -> <empty>
Rule 15    f_endclass -> <empty>
Rule 16    funciones -> funciones funcion
Rule 17    funciones -> empty
Rule 18    funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
Rule 19    funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc
Rule 20    f_startfunc -> <empty>
Rule 21    f_nothing -> <empty>
Rule 22    f_tipofunc -> <empty>
Rule 23    f_endfunc -> <empty>
Rule 24    vars -> vars DEF tipo dimension : lista_id ; f_delete_dim
Rule 25    vars -> vars DEF ID f_varsobj : lista_id_obj ;
Rule 26    vars -> empty
Rule 27    f_varsobj -> <empty>
Rule 28    lista_id -> ID f_vars
Rule 29    lista_id -> lista_id , ID f_vars
Rule 30    f_delete_dim -> <empty>
Rule 31    f_vars -> <empty>
Rule 32    lista_id_obj -> ID f_vars_obj
Rule 33    lista_id_obj -> lista_id_obj , ID f_vars_obj
Rule 34    f_vars_obj -> <empty>
Rule 35    dimension -> [ NUM f_dim1 ] f_enddim
Rule 36    dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_enddim
Rule 37    dimension -> empty
Rule 38    f_dim1 -> <empty>
Rule 39    f_dim2 -> <empty>
Rule 40    f_enddim -> <empty>
Rule 41    tipo -> NUMBER
Rule 42    tipo -> STRING
Rule 43    params -> pparams
Rule 44    params -> empty
Rule 45    pparams -> tipo ID f_param
Rule 46    pparams -> pparams , tipo ID f_param
Rule 47    f_param -> <empty>
Rule 48    estatutos -> estatutos estatuto
Rule 49    estatutos -> empty
Rule 50    estatuto -> asignacion
Rule 51    estatuto -> while
Rule 52    estatuto -> for
Rule 53    estatuto -> condicion
Rule 54    estatuto -> CALL call_func ;
Rule 55    call_func -> func f_gosub f_end_call f_end_check
Rule 56    call_func -> input
Rule 57    call_func -> write
Rule 58    call_func -> return
Rule 59    f_end_call -> <empty>
Rule 60    f_gosub -> <empty>
Rule 61    func -> ID f_verify_func ( args )
Rule 62    func -> ID f_varobj : ID f_verify_func_composite ( args )
Rule 63    f_verify_func -> <empty>
Rule 64    f_varobj -> <empty>
Rule 65    f_verify_func_composite -> <empty>
Rule 66    args -> args_list f_end_args
Rule 67    args -> f_end_args
Rule 68    args_list -> expresion f_arg
Rule 69    args_list -> args_list , expresion f_arg
Rule 70    f_arg -> <empty>
Rule 71    f_end_args -> <empty>
Rule 72    asignacion -> var = f_oper expresion ;
Rule 73    var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
Rule 74    var -> ID f_verify_type indexacion f_end_check
Rule 75    f_verify_type -> <empty>
Rule 76    f_verify_type_composite -> <empty>
Rule 77    f_end_check -> <empty>
Rule 78    f_index_obj -> <empty>
Rule 79    indexacion -> [ f_start_array expresion f_index ] f_end_array
Rule 80    indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array
Rule 81    indexacion -> f_no_index empty
Rule 82    f_no_index -> <empty>
Rule 83    f_start_array -> <empty>
Rule 84    f_index -> <empty>
Rule 85    f_next_index -> <empty>
Rule 86    f_end_array -> <empty>
Rule 87    expresion -> exp
Rule 88    expresion -> expresion COMP f_oper exp f_expres
Rule 89    f_expres -> <empty>
Rule 90    exp -> term
Rule 91    exp -> exp OPTERM f_oper term f_exp
Rule 92    f_exp -> <empty>
Rule 93    term -> fact
Rule 94    term -> term OPFACT f_oper fact f_term
Rule 95    f_term -> <empty>
Rule 96    f_oper -> <empty>
Rule 97    fact -> ( f_lparen expresion ) f_rparen
Rule 98    fact -> var
Rule 99    fact -> NUM f_fact
Rule 100   fact -> OPTERM NUM
Rule 101   fact -> CALL func f_gosub f_return_val f_end_call f_end_check
Rule 102   fact -> CALL to_num
Rule 103   fact -> CALL to_str
Rule 104   fact -> STR f_string
Rule 105   fact -> fact & f_oper var f_concat
Rule 106   fact -> fact & f_oper STR f_string f_concat
Rule 107   f_concat -> <empty>
Rule 108   f_lparen -> <empty>
Rule 109   f_rparen -> <empty>
Rule 110   f_fact -> <empty>
Rule 111   f_return_val -> <empty>
Rule 112   condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
Rule 113   condicionp -> ELSE f_else { estatutos }
Rule 114   condicionp -> empty
Rule 115   f_if -> <empty>
Rule 116   f_endif -> <empty>
Rule 117   f_else -> <empty>
Rule 118   while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
Rule 119   f_while -> <empty>
Rule 120   f_exprwhile -> <empty>
Rule 121   f_endwhile -> <empty>
Rule 122   for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
Rule 123   f_for_start -> <empty>
Rule 124   f_for_to -> <empty>
Rule 125   f_for_end -> <empty>
Rule 126   to_num -> TO_NUMBER ( STR f_string )
Rule 127   to_num -> TO_NUMBER ( var )
Rule 128   to_str -> TO_STRING ( expresion )
Rule 129   input -> INPUT ( var )
Rule 130   write -> PRINT ( write_list ) f_call_empty_print
Rule 131   write -> PRINT ( ) f_call_empty_print
Rule 132   f_call_empty_print -> <empty>
Rule 133   write_list -> write_list & write_listp
Rule 134   write_list -> write_listp
Rule 135   write_listp -> STR f_string
Rule 136   write_listp -> var
Rule 137   write_listp -> CALL to_str
Rule 138   f_string -> <empty>
Rule 139   return -> RET ( expresion )
Rule 140   empty -> <empty>

Terminals, with rules where they appear

&                    : 105 106 133
(                    : 1 18 19 61 62 97 112 118 126 127 128 129 130 131 139
)                    : 1 18 19 61 62 97 112 118 126 127 128 129 130 131 139
,                    : 29 33 46 69
:                    : 8 12 18 19 24 25 62 73
;                    : 1 1 12 24 25 54 72
=                    : 72
CALL                 : 54 101 102 103 137
COMP                 : 88
DEF                  : 12 24 25
DO                   : 118
ELSE                 : 113
END                  : 1
FOR                  : 122
FUNC                 : 18 19
ID                   : 1 8 8 9 18 19 25 28 29 32 33 45 46 61 62 62 73 73 74
IF                   : 112
INPUT                : 129
MAIN                 : 1
NOTHING              : 19
NUM                  : 35 36 36 99 100
NUMBER               : 41
OPFACT               : 94
OPTERM               : 91 100
PRINT                : 130 131
PROGRAM              : 1
RET                  : 139
STR                  : 104 106 126 135
STRING               : 42
THEN                 : 112
TO                   : 122
TO_NUMBER            : 126 127
TO_STRING            : 128
TYPE                 : 8 9
WHILE                : 118
[                    : 35 36 36 79 80 80
]                    : 35 36 36 79 80 80
error                : 
{                    : 1 8 9 18 19 112 113 118 122
}                    : 1 8 9 18 19 112 113 118 122

Nonterminals, with rules where they appear

args                 : 61 62
args_list            : 66 69
asignacion           : 50
call_func            : 54
clase                : 6
clases               : 1 6
condicion            : 53
condicionp           : 112
cvars                : 8 9 12 18 19
dimension            : 12 24
empty                : 7 13 17 26 37 44 49 81 114
estatuto             : 48
estatutos            : 1 18 19 48 112 113 118 122
exp                  : 87 88 91
expresion            : 68 69 72 79 80 80 88 97 112 118 122 122 128 139
f_arg                : 68 69
f_call_empty_print   : 130 131
f_clasepadre         : 8
f_concat             : 105 106
f_cvars              : 8 9
f_delete_dim         : 12 24
f_dim1               : 35 36
f_dim2               : 36
f_else               : 113
f_end                : 1
f_end_args           : 66 67
f_end_array          : 79 80
f_end_call           : 55 101
f_end_check          : 55 73 74 101
f_endclass           : 8 9
f_enddim             : 35 36
f_endfunc            : 18 19
f_endif              : 112
f_endwhile           : 118
f_exp                : 91
f_expres             : 88
f_exprwhile          : 118
f_fact               : 99
f_for_end            : 122
f_for_start          : 122
f_for_to             : 122
f_gosub              : 55 101
f_if                 : 112
f_index              : 79 80 80
f_index_obj          : 73
f_lparen             : 97
f_main               : 1
f_next_index         : 80
f_no_index           : 81
f_nothing            : 19
f_oper               : 72 88 91 94 105 106
f_param              : 45 46
f_prog               : 1
f_return_val         : 101
f_rparen             : 97
f_start              : 1
f_start_array        : 79 80
f_startclass         : 8 9
f_startfunc          : 18 19
f_string             : 104 106 126 135
f_term               : 94
f_tipofunc           : 18 19
f_varobj             : 62 73
f_vars               : 28 29
f_vars_obj           : 32 33
f_varsobj            : 25
f_verify_func        : 61
f_verify_func_composite : 62
f_verify_type        : 74
f_verify_type_composite : 73
f_while              : 118
fact                 : 93 94 105 106
for                  : 52
func                 : 55 101
funcion              : 16
funciones            : 1 8 9 16
indexacion           : 73 74
input                : 56
lista_id             : 12 24 29
lista_id_obj         : 25 33
params               : 18 19
pparams              : 43 46
return               : 58
start                : 0
term                 : 90 91 94
tipo                 : 12 18 24 45 46
to_num               : 102
to_str               : 103 137
var                  : 72 98 105 127 129 136
vars                 : 1 24 25
while                : 51
write                : 57
write_list           : 130 133
write_listp          : 133 134

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (2) f_start -> .

    ID              reduce using rule 2 (f_start -> .)

    f_start                        shift and go to state 3

state 3

    (1) start -> PROGRAM f_start . ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ID              shift and go to state 4


state 4

    (1) start -> PROGRAM f_start ID . f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (3) f_prog -> .

    ;               reduce using rule 3 (f_prog -> .)

    f_prog                         shift and go to state 5

state 5

    (1) start -> PROGRAM f_start ID f_prog . ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ;               shift and go to state 6


state 6

    (1) start -> PROGRAM f_start ID f_prog ; . clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> . clases clase
    (7) clases -> . empty
    (140) empty -> .

    TYPE            reduce using rule 140 (empty -> .)
    DEF             reduce using rule 140 (empty -> .)
    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    clases                         shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) start -> PROGRAM f_start ID f_prog ; clases . vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> clases . clase
    (24) vars -> . vars DEF tipo dimension : lista_id ; f_delete_dim
    (25) vars -> . vars DEF ID f_varsobj : lista_id_obj ;
    (26) vars -> . empty
    (8) clase -> . TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> . TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
    (140) empty -> .

    TYPE            shift and go to state 12
    DEF             reduce using rule 140 (empty -> .)
    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    vars                           shift and go to state 9
    clase                          shift and go to state 10
    empty                          shift and go to state 11

state 8

    (7) clases -> empty .

    TYPE            reduce using rule 7 (clases -> empty .)
    DEF             reduce using rule 7 (clases -> empty .)
    MAIN            reduce using rule 7 (clases -> empty .)
    FUNC            reduce using rule 7 (clases -> empty .)


state 9

    (1) start -> PROGRAM f_start ID f_prog ; clases vars . funciones MAIN f_main ( ) { estatutos } END f_end ;
    (24) vars -> vars . DEF tipo dimension : lista_id ; f_delete_dim
    (25) vars -> vars . DEF ID f_varsobj : lista_id_obj ;
    (16) funciones -> . funciones funcion
    (17) funciones -> . empty
    (140) empty -> .

    DEF             shift and go to state 14
    MAIN            reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    funciones                      shift and go to state 13
    empty                          shift and go to state 15

state 10

    (6) clases -> clases clase .

    TYPE            reduce using rule 6 (clases -> clases clase .)
    DEF             reduce using rule 6 (clases -> clases clase .)
    MAIN            reduce using rule 6 (clases -> clases clase .)
    FUNC            reduce using rule 6 (clases -> clases clase .)


state 11

    (26) vars -> empty .

    DEF             reduce using rule 26 (vars -> empty .)
    MAIN            reduce using rule 26 (vars -> empty .)
    FUNC            reduce using rule 26 (vars -> empty .)


state 12

    (8) clase -> TYPE . ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE . ID f_startclass { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 16


state 13

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones . MAIN f_main ( ) { estatutos } END f_end ;
    (16) funciones -> funciones . funcion
    (18) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    MAIN            shift and go to state 17
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 14

    (24) vars -> vars DEF . tipo dimension : lista_id ; f_delete_dim
    (25) vars -> vars DEF . ID f_varsobj : lista_id_obj ;
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    ID              shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 20

state 15

    (17) funciones -> empty .

    MAIN            reduce using rule 17 (funciones -> empty .)
    FUNC            reduce using rule 17 (funciones -> empty .)
    }               reduce using rule 17 (funciones -> empty .)


state 16

    (8) clase -> TYPE ID . f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID . f_startclass { cvars f_cvars funciones } f_endclass
    (10) f_startclass -> .

    :               reduce using rule 10 (f_startclass -> .)
    {               reduce using rule 10 (f_startclass -> .)

    f_startclass                   shift and go to state 24

state 17

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN . f_main ( ) { estatutos } END f_end ;
    (4) f_main -> .

    (               reduce using rule 4 (f_main -> .)

    f_main                         shift and go to state 25

state 18

    (16) funciones -> funciones funcion .

    MAIN            reduce using rule 16 (funciones -> funciones funcion .)
    FUNC            reduce using rule 16 (funciones -> funciones funcion .)
    }               reduce using rule 16 (funciones -> funciones funcion .)


state 19

    (18) funcion -> FUNC . ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC . ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    ID              shift and go to state 26


state 20

    (24) vars -> vars DEF tipo . dimension : lista_id ; f_delete_dim
    (35) dimension -> . [ NUM f_dim1 ] f_enddim
    (36) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_enddim
    (37) dimension -> . empty
    (140) empty -> .

    [               shift and go to state 28
    :               reduce using rule 140 (empty -> .)

    dimension                      shift and go to state 27
    empty                          shift and go to state 29

state 21

    (25) vars -> vars DEF ID . f_varsobj : lista_id_obj ;
    (27) f_varsobj -> .

    :               reduce using rule 27 (f_varsobj -> .)

    f_varsobj                      shift and go to state 30

state 22

    (41) tipo -> NUMBER .

    [               reduce using rule 41 (tipo -> NUMBER .)
    :               reduce using rule 41 (tipo -> NUMBER .)
    ID              reduce using rule 41 (tipo -> NUMBER .)
    {               reduce using rule 41 (tipo -> NUMBER .)


state 23

    (42) tipo -> STRING .

    [               reduce using rule 42 (tipo -> STRING .)
    :               reduce using rule 42 (tipo -> STRING .)
    ID              reduce using rule 42 (tipo -> STRING .)
    {               reduce using rule 42 (tipo -> STRING .)


state 24

    (8) clase -> TYPE ID f_startclass . : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID f_startclass . { cvars f_cvars funciones } f_endclass

    :               shift and go to state 31
    {               shift and go to state 32


state 25

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main . ( ) { estatutos } END f_end ;

    (               shift and go to state 33


state 26

    (18) funcion -> FUNC ID . f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID . f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc
    (20) f_startfunc -> .

    (               reduce using rule 20 (f_startfunc -> .)

    f_startfunc                    shift and go to state 34

state 27

    (24) vars -> vars DEF tipo dimension . : lista_id ; f_delete_dim

    :               shift and go to state 35


state 28

    (35) dimension -> [ . NUM f_dim1 ] f_enddim
    (36) dimension -> [ . NUM f_dim1 ] [ NUM f_dim2 ] f_enddim

    NUM             shift and go to state 36


state 29

    (37) dimension -> empty .

    :               reduce using rule 37 (dimension -> empty .)


state 30

    (25) vars -> vars DEF ID f_varsobj . : lista_id_obj ;

    :               shift and go to state 37


state 31

    (8) clase -> TYPE ID f_startclass : . ID f_clasepadre { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 38


state 32

    (9) clase -> TYPE ID f_startclass { . cvars f_cvars funciones } f_endclass
    (12) cvars -> . cvars DEF tipo dimension : lista_id ; f_delete_dim
    (13) cvars -> . empty
    (140) empty -> .

    DEF             reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    cvars                          shift and go to state 39
    empty                          shift and go to state 40

state 33

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( . ) { estatutos } END f_end ;

    )               shift and go to state 41


state 34

    (18) funcion -> FUNC ID f_startfunc . ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID f_startfunc . ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    (               shift and go to state 42


state 35

    (24) vars -> vars DEF tipo dimension : . lista_id ; f_delete_dim
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 43

state 36

    (35) dimension -> [ NUM . f_dim1 ] f_enddim
    (36) dimension -> [ NUM . f_dim1 ] [ NUM f_dim2 ] f_enddim
    (38) f_dim1 -> .

    ]               reduce using rule 38 (f_dim1 -> .)

    f_dim1                         shift and go to state 45

state 37

    (25) vars -> vars DEF ID f_varsobj : . lista_id_obj ;
    (32) lista_id_obj -> . ID f_vars_obj
    (33) lista_id_obj -> . lista_id_obj , ID f_vars_obj

    ID              shift and go to state 46

    lista_id_obj                   shift and go to state 47

state 38

    (8) clase -> TYPE ID f_startclass : ID . f_clasepadre { cvars f_cvars funciones } f_endclass
    (11) f_clasepadre -> .

    {               reduce using rule 11 (f_clasepadre -> .)

    f_clasepadre                   shift and go to state 48

state 39

    (9) clase -> TYPE ID f_startclass { cvars . f_cvars funciones } f_endclass
    (12) cvars -> cvars . DEF tipo dimension : lista_id ; f_delete_dim
    (14) f_cvars -> .

    DEF             shift and go to state 50
    }               reduce using rule 14 (f_cvars -> .)
    FUNC            reduce using rule 14 (f_cvars -> .)

    f_cvars                        shift and go to state 49

state 40

    (13) cvars -> empty .

    DEF             reduce using rule 13 (cvars -> empty .)
    }               reduce using rule 13 (cvars -> empty .)
    FUNC            reduce using rule 13 (cvars -> empty .)
    CALL            reduce using rule 13 (cvars -> empty .)
    WHILE           reduce using rule 13 (cvars -> empty .)
    FOR             reduce using rule 13 (cvars -> empty .)
    IF              reduce using rule 13 (cvars -> empty .)
    ID              reduce using rule 13 (cvars -> empty .)


state 41

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) . { estatutos } END f_end ;

    {               shift and go to state 51


state 42

    (18) funcion -> FUNC ID f_startfunc ( . params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID f_startfunc ( . params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc
    (43) params -> . pparams
    (44) params -> . empty
    (45) pparams -> . tipo ID f_param
    (46) pparams -> . pparams , tipo ID f_param
    (140) empty -> .
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    )               reduce using rule 140 (empty -> .)
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    params                         shift and go to state 52
    tipo                           shift and go to state 53
    pparams                        shift and go to state 54
    empty                          shift and go to state 55

state 43

    (24) vars -> vars DEF tipo dimension : lista_id . ; f_delete_dim
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 56
    ,               shift and go to state 57


state 44

    (28) lista_id -> ID . f_vars
    (31) f_vars -> .

    ;               reduce using rule 31 (f_vars -> .)
    ,               reduce using rule 31 (f_vars -> .)

    f_vars                         shift and go to state 58

state 45

    (35) dimension -> [ NUM f_dim1 . ] f_enddim
    (36) dimension -> [ NUM f_dim1 . ] [ NUM f_dim2 ] f_enddim

    ]               shift and go to state 59


state 46

    (32) lista_id_obj -> ID . f_vars_obj
    (34) f_vars_obj -> .

    ;               reduce using rule 34 (f_vars_obj -> .)
    ,               reduce using rule 34 (f_vars_obj -> .)

    f_vars_obj                     shift and go to state 60

state 47

    (25) vars -> vars DEF ID f_varsobj : lista_id_obj . ;
    (33) lista_id_obj -> lista_id_obj . , ID f_vars_obj

    ;               shift and go to state 61
    ,               shift and go to state 62


state 48

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre . { cvars f_cvars funciones } f_endclass

    {               shift and go to state 63


state 49

    (9) clase -> TYPE ID f_startclass { cvars f_cvars . funciones } f_endclass
    (16) funciones -> . funciones funcion
    (17) funciones -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    funciones                      shift and go to state 64
    empty                          shift and go to state 15

state 50

    (12) cvars -> cvars DEF . tipo dimension : lista_id ; f_delete_dim
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 65

state 51

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { . estatutos } END f_end ;
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 66
    empty                          shift and go to state 67

state 52

    (18) funcion -> FUNC ID f_startfunc ( params . ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID f_startfunc ( params . ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    )               shift and go to state 68


state 53

    (45) pparams -> tipo . ID f_param

    ID              shift and go to state 69


state 54

    (43) params -> pparams .
    (46) pparams -> pparams . , tipo ID f_param

    )               reduce using rule 43 (params -> pparams .)
    ,               shift and go to state 70


state 55

    (44) params -> empty .

    )               reduce using rule 44 (params -> empty .)


state 56

    (24) vars -> vars DEF tipo dimension : lista_id ; . f_delete_dim
    (30) f_delete_dim -> .

    DEF             reduce using rule 30 (f_delete_dim -> .)
    MAIN            reduce using rule 30 (f_delete_dim -> .)
    FUNC            reduce using rule 30 (f_delete_dim -> .)

    f_delete_dim                   shift and go to state 71

state 57

    (29) lista_id -> lista_id , . ID f_vars

    ID              shift and go to state 72


state 58

    (28) lista_id -> ID f_vars .

    ;               reduce using rule 28 (lista_id -> ID f_vars .)
    ,               reduce using rule 28 (lista_id -> ID f_vars .)


state 59

    (35) dimension -> [ NUM f_dim1 ] . f_enddim
    (36) dimension -> [ NUM f_dim1 ] . [ NUM f_dim2 ] f_enddim
    (40) f_enddim -> .

    [               shift and go to state 73
    :               reduce using rule 40 (f_enddim -> .)

    f_enddim                       shift and go to state 74

state 60

    (32) lista_id_obj -> ID f_vars_obj .

    ;               reduce using rule 32 (lista_id_obj -> ID f_vars_obj .)
    ,               reduce using rule 32 (lista_id_obj -> ID f_vars_obj .)


state 61

    (25) vars -> vars DEF ID f_varsobj : lista_id_obj ; .

    DEF             reduce using rule 25 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    MAIN            reduce using rule 25 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    FUNC            reduce using rule 25 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)


state 62

    (33) lista_id_obj -> lista_id_obj , . ID f_vars_obj

    ID              shift and go to state 75


state 63

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { . cvars f_cvars funciones } f_endclass
    (12) cvars -> . cvars DEF tipo dimension : lista_id ; f_delete_dim
    (13) cvars -> . empty
    (140) empty -> .

    DEF             reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    cvars                          shift and go to state 76
    empty                          shift and go to state 40

state 64

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones . } f_endclass
    (16) funciones -> funciones . funcion
    (18) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    }               shift and go to state 77
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 65

    (12) cvars -> cvars DEF tipo . dimension : lista_id ; f_delete_dim
    (35) dimension -> . [ NUM f_dim1 ] f_enddim
    (36) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_enddim
    (37) dimension -> . empty
    (140) empty -> .

    [               shift and go to state 28
    :               reduce using rule 140 (empty -> .)

    dimension                      shift and go to state 78
    empty                          shift and go to state 29

state 66

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos . } END f_end ;
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 80
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 67

    (49) estatutos -> empty .

    }               reduce using rule 49 (estatutos -> empty .)
    CALL            reduce using rule 49 (estatutos -> empty .)
    WHILE           reduce using rule 49 (estatutos -> empty .)
    FOR             reduce using rule 49 (estatutos -> empty .)
    IF              reduce using rule 49 (estatutos -> empty .)
    ID              reduce using rule 49 (estatutos -> empty .)


state 68

    (18) funcion -> FUNC ID f_startfunc ( params ) . : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID f_startfunc ( params ) . : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    :               shift and go to state 91


state 69

    (45) pparams -> tipo ID . f_param
    (47) f_param -> .

    ,               reduce using rule 47 (f_param -> .)
    )               reduce using rule 47 (f_param -> .)

    f_param                        shift and go to state 92

state 70

    (46) pparams -> pparams , . tipo ID f_param
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 93

state 71

    (24) vars -> vars DEF tipo dimension : lista_id ; f_delete_dim .

    DEF             reduce using rule 24 (vars -> vars DEF tipo dimension : lista_id ; f_delete_dim .)
    MAIN            reduce using rule 24 (vars -> vars DEF tipo dimension : lista_id ; f_delete_dim .)
    FUNC            reduce using rule 24 (vars -> vars DEF tipo dimension : lista_id ; f_delete_dim .)


state 72

    (29) lista_id -> lista_id , ID . f_vars
    (31) f_vars -> .

    ;               reduce using rule 31 (f_vars -> .)
    ,               reduce using rule 31 (f_vars -> .)

    f_vars                         shift and go to state 94

state 73

    (36) dimension -> [ NUM f_dim1 ] [ . NUM f_dim2 ] f_enddim

    NUM             shift and go to state 95


state 74

    (35) dimension -> [ NUM f_dim1 ] f_enddim .

    :               reduce using rule 35 (dimension -> [ NUM f_dim1 ] f_enddim .)


state 75

    (33) lista_id_obj -> lista_id_obj , ID . f_vars_obj
    (34) f_vars_obj -> .

    ;               reduce using rule 34 (f_vars_obj -> .)
    ,               reduce using rule 34 (f_vars_obj -> .)

    f_vars_obj                     shift and go to state 96

state 76

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars . f_cvars funciones } f_endclass
    (12) cvars -> cvars . DEF tipo dimension : lista_id ; f_delete_dim
    (14) f_cvars -> .

    DEF             shift and go to state 50
    }               reduce using rule 14 (f_cvars -> .)
    FUNC            reduce using rule 14 (f_cvars -> .)

    f_cvars                        shift and go to state 97

state 77

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } . f_endclass
    (15) f_endclass -> .

    TYPE            reduce using rule 15 (f_endclass -> .)
    DEF             reduce using rule 15 (f_endclass -> .)
    MAIN            reduce using rule 15 (f_endclass -> .)
    FUNC            reduce using rule 15 (f_endclass -> .)

    f_endclass                     shift and go to state 98

state 78

    (12) cvars -> cvars DEF tipo dimension . : lista_id ; f_delete_dim

    :               shift and go to state 99


state 79

    (73) var -> ID . f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> ID . f_verify_type indexacion f_end_check
    (64) f_varobj -> .
    (75) f_verify_type -> .

    :               reduce using rule 64 (f_varobj -> .)
    [               reduce using rule 75 (f_verify_type -> .)
    =               reduce using rule 75 (f_verify_type -> .)
    &               reduce using rule 75 (f_verify_type -> .)
    OPFACT          reduce using rule 75 (f_verify_type -> .)
    OPTERM          reduce using rule 75 (f_verify_type -> .)
    COMP            reduce using rule 75 (f_verify_type -> .)
    TO              reduce using rule 75 (f_verify_type -> .)
    )               reduce using rule 75 (f_verify_type -> .)
    ;               reduce using rule 75 (f_verify_type -> .)
    ]               reduce using rule 75 (f_verify_type -> .)
    ,               reduce using rule 75 (f_verify_type -> .)
    {               reduce using rule 75 (f_verify_type -> .)

    f_varobj                       shift and go to state 100
    f_verify_type                  shift and go to state 101

state 80

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } . END f_end ;

    END             shift and go to state 102


state 81

    (48) estatutos -> estatutos estatuto .

    }               reduce using rule 48 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 48 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 48 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 48 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 48 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 48 (estatutos -> estatutos estatuto .)


state 82

    (50) estatuto -> asignacion .

    }               reduce using rule 50 (estatuto -> asignacion .)
    CALL            reduce using rule 50 (estatuto -> asignacion .)
    WHILE           reduce using rule 50 (estatuto -> asignacion .)
    FOR             reduce using rule 50 (estatuto -> asignacion .)
    IF              reduce using rule 50 (estatuto -> asignacion .)
    ID              reduce using rule 50 (estatuto -> asignacion .)


state 83

    (51) estatuto -> while .

    }               reduce using rule 51 (estatuto -> while .)
    CALL            reduce using rule 51 (estatuto -> while .)
    WHILE           reduce using rule 51 (estatuto -> while .)
    FOR             reduce using rule 51 (estatuto -> while .)
    IF              reduce using rule 51 (estatuto -> while .)
    ID              reduce using rule 51 (estatuto -> while .)


state 84

    (52) estatuto -> for .

    }               reduce using rule 52 (estatuto -> for .)
    CALL            reduce using rule 52 (estatuto -> for .)
    WHILE           reduce using rule 52 (estatuto -> for .)
    FOR             reduce using rule 52 (estatuto -> for .)
    IF              reduce using rule 52 (estatuto -> for .)
    ID              reduce using rule 52 (estatuto -> for .)


state 85

    (53) estatuto -> condicion .

    }               reduce using rule 53 (estatuto -> condicion .)
    CALL            reduce using rule 53 (estatuto -> condicion .)
    WHILE           reduce using rule 53 (estatuto -> condicion .)
    FOR             reduce using rule 53 (estatuto -> condicion .)
    IF              reduce using rule 53 (estatuto -> condicion .)
    ID              reduce using rule 53 (estatuto -> condicion .)


state 86

    (54) estatuto -> CALL . call_func ;
    (55) call_func -> . func f_gosub f_end_call f_end_check
    (56) call_func -> . input
    (57) call_func -> . write
    (58) call_func -> . return
    (61) func -> . ID f_verify_func ( args )
    (62) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (129) input -> . INPUT ( var )
    (130) write -> . PRINT ( write_list ) f_call_empty_print
    (131) write -> . PRINT ( ) f_call_empty_print
    (139) return -> . RET ( expresion )

    ID              shift and go to state 108
    INPUT           shift and go to state 109
    PRINT           shift and go to state 110
    RET             shift and go to state 111

    call_func                      shift and go to state 103
    func                           shift and go to state 104
    input                          shift and go to state 105
    write                          shift and go to state 106
    return                         shift and go to state 107

state 87

    (72) asignacion -> var . = f_oper expresion ;

    =               shift and go to state 112


state 88

    (118) while -> WHILE . f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (119) f_while -> .

    (               reduce using rule 119 (f_while -> .)

    f_while                        shift and go to state 113

state 89

    (122) for -> FOR . expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 114
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 90

    (112) condicion -> IF . ( expresion ) f_if THEN { estatutos } condicionp f_endif

    (               shift and go to state 124


state 91

    (18) funcion -> FUNC ID f_startfunc ( params ) : . tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> FUNC ID f_startfunc ( params ) : . NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NOTHING         shift and go to state 126
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 125

state 92

    (45) pparams -> tipo ID f_param .

    ,               reduce using rule 45 (pparams -> tipo ID f_param .)
    )               reduce using rule 45 (pparams -> tipo ID f_param .)


state 93

    (46) pparams -> pparams , tipo . ID f_param

    ID              shift and go to state 127


state 94

    (29) lista_id -> lista_id , ID f_vars .

    ;               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)
    ,               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)


state 95

    (36) dimension -> [ NUM f_dim1 ] [ NUM . f_dim2 ] f_enddim
    (39) f_dim2 -> .

    ]               reduce using rule 39 (f_dim2 -> .)

    f_dim2                         shift and go to state 128

state 96

    (33) lista_id_obj -> lista_id_obj , ID f_vars_obj .

    ;               reduce using rule 33 (lista_id_obj -> lista_id_obj , ID f_vars_obj .)
    ,               reduce using rule 33 (lista_id_obj -> lista_id_obj , ID f_vars_obj .)


state 97

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars . funciones } f_endclass
    (16) funciones -> . funciones funcion
    (17) funciones -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    FUNC            reduce using rule 140 (empty -> .)

    funciones                      shift and go to state 129
    empty                          shift and go to state 15

state 98

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)


state 99

    (12) cvars -> cvars DEF tipo dimension : . lista_id ; f_delete_dim
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 130

state 100

    (73) var -> ID f_varobj . : ID f_verify_type_composite f_index_obj indexacion f_end_check

    :               shift and go to state 131


state 101

    (74) var -> ID f_verify_type . indexacion f_end_check
    (79) indexacion -> . [ f_start_array expresion f_index ] f_end_array
    (80) indexacion -> . [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array
    (81) indexacion -> . f_no_index empty
    (82) f_no_index -> .

    [               shift and go to state 133
    =               reduce using rule 82 (f_no_index -> .)
    &               reduce using rule 82 (f_no_index -> .)
    OPFACT          reduce using rule 82 (f_no_index -> .)
    OPTERM          reduce using rule 82 (f_no_index -> .)
    COMP            reduce using rule 82 (f_no_index -> .)
    TO              reduce using rule 82 (f_no_index -> .)
    )               reduce using rule 82 (f_no_index -> .)
    ;               reduce using rule 82 (f_no_index -> .)
    ]               reduce using rule 82 (f_no_index -> .)
    ,               reduce using rule 82 (f_no_index -> .)
    {               reduce using rule 82 (f_no_index -> .)

    indexacion                     shift and go to state 132
    f_no_index                     shift and go to state 134

state 102

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END . f_end ;
    (5) f_end -> .

    ;               reduce using rule 5 (f_end -> .)

    f_end                          shift and go to state 135

state 103

    (54) estatuto -> CALL call_func . ;

    ;               shift and go to state 136


state 104

    (55) call_func -> func . f_gosub f_end_call f_end_check
    (60) f_gosub -> .

    ;               reduce using rule 60 (f_gosub -> .)

    f_gosub                        shift and go to state 137

state 105

    (56) call_func -> input .

    ;               reduce using rule 56 (call_func -> input .)


state 106

    (57) call_func -> write .

    ;               reduce using rule 57 (call_func -> write .)


state 107

    (58) call_func -> return .

    ;               reduce using rule 58 (call_func -> return .)


state 108

    (61) func -> ID . f_verify_func ( args )
    (62) func -> ID . f_varobj : ID f_verify_func_composite ( args )
    (63) f_verify_func -> .
    (64) f_varobj -> .

    (               reduce using rule 63 (f_verify_func -> .)
    :               reduce using rule 64 (f_varobj -> .)

    f_verify_func                  shift and go to state 138
    f_varobj                       shift and go to state 139

state 109

    (129) input -> INPUT . ( var )

    (               shift and go to state 140


state 110

    (130) write -> PRINT . ( write_list ) f_call_empty_print
    (131) write -> PRINT . ( ) f_call_empty_print

    (               shift and go to state 141


state 111

    (139) return -> RET . ( expresion )

    (               shift and go to state 142


state 112

    (72) asignacion -> var = . f_oper expresion ;
    (96) f_oper -> .

    (               reduce using rule 96 (f_oper -> .)
    NUM             reduce using rule 96 (f_oper -> .)
    OPTERM          reduce using rule 96 (f_oper -> .)
    CALL            reduce using rule 96 (f_oper -> .)
    STR             reduce using rule 96 (f_oper -> .)
    ID              reduce using rule 96 (f_oper -> .)

    f_oper                         shift and go to state 143

state 113

    (118) while -> WHILE f_while . ( expresion f_exprwhile ) DO { estatutos } f_endwhile

    (               shift and go to state 144


state 114

    (122) for -> FOR expresion . f_for_start TO expresion f_for_to { estatutos } f_for_end
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (123) f_for_start -> .

    COMP            shift and go to state 146
    TO              reduce using rule 123 (f_for_start -> .)

    f_for_start                    shift and go to state 145

state 115

    (87) expresion -> exp .
    (91) exp -> exp . OPTERM f_oper term f_exp

    COMP            reduce using rule 87 (expresion -> exp .)
    TO              reduce using rule 87 (expresion -> exp .)
    )               reduce using rule 87 (expresion -> exp .)
    ;               reduce using rule 87 (expresion -> exp .)
    ]               reduce using rule 87 (expresion -> exp .)
    ,               reduce using rule 87 (expresion -> exp .)
    {               reduce using rule 87 (expresion -> exp .)
    OPTERM          shift and go to state 147


state 116

    (90) exp -> term .
    (94) term -> term . OPFACT f_oper fact f_term

    OPTERM          reduce using rule 90 (exp -> term .)
    COMP            reduce using rule 90 (exp -> term .)
    TO              reduce using rule 90 (exp -> term .)
    )               reduce using rule 90 (exp -> term .)
    ;               reduce using rule 90 (exp -> term .)
    ]               reduce using rule 90 (exp -> term .)
    ,               reduce using rule 90 (exp -> term .)
    {               reduce using rule 90 (exp -> term .)
    OPFACT          shift and go to state 148


state 117

    (100) fact -> OPTERM . NUM

    NUM             shift and go to state 149


state 118

    (93) term -> fact .
    (105) fact -> fact . & f_oper var f_concat
    (106) fact -> fact . & f_oper STR f_string f_concat

    OPFACT          reduce using rule 93 (term -> fact .)
    OPTERM          reduce using rule 93 (term -> fact .)
    COMP            reduce using rule 93 (term -> fact .)
    TO              reduce using rule 93 (term -> fact .)
    )               reduce using rule 93 (term -> fact .)
    ;               reduce using rule 93 (term -> fact .)
    ]               reduce using rule 93 (term -> fact .)
    ,               reduce using rule 93 (term -> fact .)
    {               reduce using rule 93 (term -> fact .)
    &               shift and go to state 150


state 119

    (97) fact -> ( . f_lparen expresion ) f_rparen
    (108) f_lparen -> .

    (               reduce using rule 108 (f_lparen -> .)
    NUM             reduce using rule 108 (f_lparen -> .)
    OPTERM          reduce using rule 108 (f_lparen -> .)
    CALL            reduce using rule 108 (f_lparen -> .)
    STR             reduce using rule 108 (f_lparen -> .)
    ID              reduce using rule 108 (f_lparen -> .)

    f_lparen                       shift and go to state 151

state 120

    (98) fact -> var .

    &               reduce using rule 98 (fact -> var .)
    OPFACT          reduce using rule 98 (fact -> var .)
    OPTERM          reduce using rule 98 (fact -> var .)
    COMP            reduce using rule 98 (fact -> var .)
    TO              reduce using rule 98 (fact -> var .)
    )               reduce using rule 98 (fact -> var .)
    ;               reduce using rule 98 (fact -> var .)
    ]               reduce using rule 98 (fact -> var .)
    ,               reduce using rule 98 (fact -> var .)
    {               reduce using rule 98 (fact -> var .)


state 121

    (99) fact -> NUM . f_fact
    (110) f_fact -> .

    &               reduce using rule 110 (f_fact -> .)
    OPFACT          reduce using rule 110 (f_fact -> .)
    OPTERM          reduce using rule 110 (f_fact -> .)
    COMP            reduce using rule 110 (f_fact -> .)
    TO              reduce using rule 110 (f_fact -> .)
    )               reduce using rule 110 (f_fact -> .)
    ;               reduce using rule 110 (f_fact -> .)
    ]               reduce using rule 110 (f_fact -> .)
    ,               reduce using rule 110 (f_fact -> .)
    {               reduce using rule 110 (f_fact -> .)

    f_fact                         shift and go to state 152

state 122

    (101) fact -> CALL . func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> CALL . to_num
    (103) fact -> CALL . to_str
    (61) func -> . ID f_verify_func ( args )
    (62) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (126) to_num -> . TO_NUMBER ( STR f_string )
    (127) to_num -> . TO_NUMBER ( var )
    (128) to_str -> . TO_STRING ( expresion )

    ID              shift and go to state 108
    TO_NUMBER       shift and go to state 156
    TO_STRING       shift and go to state 157

    func                           shift and go to state 153
    to_num                         shift and go to state 154
    to_str                         shift and go to state 155

state 123

    (104) fact -> STR . f_string
    (138) f_string -> .

    &               reduce using rule 138 (f_string -> .)
    OPFACT          reduce using rule 138 (f_string -> .)
    OPTERM          reduce using rule 138 (f_string -> .)
    COMP            reduce using rule 138 (f_string -> .)
    TO              reduce using rule 138 (f_string -> .)
    )               reduce using rule 138 (f_string -> .)
    ;               reduce using rule 138 (f_string -> .)
    ]               reduce using rule 138 (f_string -> .)
    ,               reduce using rule 138 (f_string -> .)
    {               reduce using rule 138 (f_string -> .)

    f_string                       shift and go to state 158

state 124

    (112) condicion -> IF ( . expresion ) f_if THEN { estatutos } condicionp f_endif
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 159
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 125

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo . f_tipofunc { cvars estatutos } f_endfunc
    (22) f_tipofunc -> .

    {               reduce using rule 22 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 160

state 126

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING . f_nothing f_tipofunc { cvars estatutos } f_endfunc
    (21) f_nothing -> .

    {               reduce using rule 21 (f_nothing -> .)

    f_nothing                      shift and go to state 161

state 127

    (46) pparams -> pparams , tipo ID . f_param
    (47) f_param -> .

    ,               reduce using rule 47 (f_param -> .)
    )               reduce using rule 47 (f_param -> .)

    f_param                        shift and go to state 162

state 128

    (36) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 . ] f_enddim

    ]               shift and go to state 163


state 129

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones . } f_endclass
    (16) funciones -> funciones . funcion
    (18) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc
    (19) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc

    }               shift and go to state 164
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 130

    (12) cvars -> cvars DEF tipo dimension : lista_id . ; f_delete_dim
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 165
    ,               shift and go to state 57


state 131

    (73) var -> ID f_varobj : . ID f_verify_type_composite f_index_obj indexacion f_end_check

    ID              shift and go to state 166


state 132

    (74) var -> ID f_verify_type indexacion . f_end_check
    (77) f_end_check -> .

    =               reduce using rule 77 (f_end_check -> .)
    &               reduce using rule 77 (f_end_check -> .)
    OPFACT          reduce using rule 77 (f_end_check -> .)
    OPTERM          reduce using rule 77 (f_end_check -> .)
    COMP            reduce using rule 77 (f_end_check -> .)
    TO              reduce using rule 77 (f_end_check -> .)
    )               reduce using rule 77 (f_end_check -> .)
    ;               reduce using rule 77 (f_end_check -> .)
    ]               reduce using rule 77 (f_end_check -> .)
    ,               reduce using rule 77 (f_end_check -> .)
    {               reduce using rule 77 (f_end_check -> .)

    f_end_check                    shift and go to state 167

state 133

    (79) indexacion -> [ . f_start_array expresion f_index ] f_end_array
    (80) indexacion -> [ . f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array
    (83) f_start_array -> .

    (               reduce using rule 83 (f_start_array -> .)
    NUM             reduce using rule 83 (f_start_array -> .)
    OPTERM          reduce using rule 83 (f_start_array -> .)
    CALL            reduce using rule 83 (f_start_array -> .)
    STR             reduce using rule 83 (f_start_array -> .)
    ID              reduce using rule 83 (f_start_array -> .)

    f_start_array                  shift and go to state 168

state 134

    (81) indexacion -> f_no_index . empty
    (140) empty -> .

    =               reduce using rule 140 (empty -> .)
    &               reduce using rule 140 (empty -> .)
    OPFACT          reduce using rule 140 (empty -> .)
    OPTERM          reduce using rule 140 (empty -> .)
    COMP            reduce using rule 140 (empty -> .)
    TO              reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    ]               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    {               reduce using rule 140 (empty -> .)

    empty                          shift and go to state 169

state 135

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end . ;

    ;               shift and go to state 170


state 136

    (54) estatuto -> CALL call_func ; .

    }               reduce using rule 54 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 54 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 54 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 54 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 54 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 54 (estatuto -> CALL call_func ; .)


state 137

    (55) call_func -> func f_gosub . f_end_call f_end_check
    (59) f_end_call -> .

    ;               reduce using rule 59 (f_end_call -> .)

    f_end_call                     shift and go to state 171

state 138

    (61) func -> ID f_verify_func . ( args )

    (               shift and go to state 172


state 139

    (62) func -> ID f_varobj . : ID f_verify_func_composite ( args )

    :               shift and go to state 173


state 140

    (129) input -> INPUT ( . var )
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    ID              shift and go to state 79

    var                            shift and go to state 174

state 141

    (130) write -> PRINT ( . write_list ) f_call_empty_print
    (131) write -> PRINT ( . ) f_call_empty_print
    (133) write_list -> . write_list & write_listp
    (134) write_list -> . write_listp
    (135) write_listp -> . STR f_string
    (136) write_listp -> . var
    (137) write_listp -> . CALL to_str
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    )               shift and go to state 176
    STR             shift and go to state 178
    CALL            shift and go to state 180
    ID              shift and go to state 79

    write_list                     shift and go to state 175
    write_listp                    shift and go to state 177
    var                            shift and go to state 179

state 142

    (139) return -> RET ( . expresion )
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 181
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 143

    (72) asignacion -> var = f_oper . expresion ;
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    var                            shift and go to state 120
    expresion                      shift and go to state 182
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118

state 144

    (118) while -> WHILE f_while ( . expresion f_exprwhile ) DO { estatutos } f_endwhile
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 183
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 145

    (122) for -> FOR expresion f_for_start . TO expresion f_for_to { estatutos } f_for_end

    TO              shift and go to state 184


state 146

    (88) expresion -> expresion COMP . f_oper exp f_expres
    (96) f_oper -> .

    (               reduce using rule 96 (f_oper -> .)
    NUM             reduce using rule 96 (f_oper -> .)
    OPTERM          reduce using rule 96 (f_oper -> .)
    CALL            reduce using rule 96 (f_oper -> .)
    STR             reduce using rule 96 (f_oper -> .)
    ID              reduce using rule 96 (f_oper -> .)

    f_oper                         shift and go to state 185

state 147

    (91) exp -> exp OPTERM . f_oper term f_exp
    (96) f_oper -> .

    (               reduce using rule 96 (f_oper -> .)
    NUM             reduce using rule 96 (f_oper -> .)
    OPTERM          reduce using rule 96 (f_oper -> .)
    CALL            reduce using rule 96 (f_oper -> .)
    STR             reduce using rule 96 (f_oper -> .)
    ID              reduce using rule 96 (f_oper -> .)

    f_oper                         shift and go to state 186

state 148

    (94) term -> term OPFACT . f_oper fact f_term
    (96) f_oper -> .

    (               reduce using rule 96 (f_oper -> .)
    NUM             reduce using rule 96 (f_oper -> .)
    OPTERM          reduce using rule 96 (f_oper -> .)
    CALL            reduce using rule 96 (f_oper -> .)
    STR             reduce using rule 96 (f_oper -> .)
    ID              reduce using rule 96 (f_oper -> .)

    f_oper                         shift and go to state 187

state 149

    (100) fact -> OPTERM NUM .

    &               reduce using rule 100 (fact -> OPTERM NUM .)
    OPFACT          reduce using rule 100 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 100 (fact -> OPTERM NUM .)
    COMP            reduce using rule 100 (fact -> OPTERM NUM .)
    TO              reduce using rule 100 (fact -> OPTERM NUM .)
    )               reduce using rule 100 (fact -> OPTERM NUM .)
    ;               reduce using rule 100 (fact -> OPTERM NUM .)
    ]               reduce using rule 100 (fact -> OPTERM NUM .)
    ,               reduce using rule 100 (fact -> OPTERM NUM .)
    {               reduce using rule 100 (fact -> OPTERM NUM .)


state 150

    (105) fact -> fact & . f_oper var f_concat
    (106) fact -> fact & . f_oper STR f_string f_concat
    (96) f_oper -> .

    STR             reduce using rule 96 (f_oper -> .)
    ID              reduce using rule 96 (f_oper -> .)

    f_oper                         shift and go to state 188

state 151

    (97) fact -> ( f_lparen . expresion ) f_rparen
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 189
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 152

    (99) fact -> NUM f_fact .

    &               reduce using rule 99 (fact -> NUM f_fact .)
    OPFACT          reduce using rule 99 (fact -> NUM f_fact .)
    OPTERM          reduce using rule 99 (fact -> NUM f_fact .)
    COMP            reduce using rule 99 (fact -> NUM f_fact .)
    TO              reduce using rule 99 (fact -> NUM f_fact .)
    )               reduce using rule 99 (fact -> NUM f_fact .)
    ;               reduce using rule 99 (fact -> NUM f_fact .)
    ]               reduce using rule 99 (fact -> NUM f_fact .)
    ,               reduce using rule 99 (fact -> NUM f_fact .)
    {               reduce using rule 99 (fact -> NUM f_fact .)


state 153

    (101) fact -> CALL func . f_gosub f_return_val f_end_call f_end_check
    (60) f_gosub -> .

    &               reduce using rule 60 (f_gosub -> .)
    OPFACT          reduce using rule 60 (f_gosub -> .)
    OPTERM          reduce using rule 60 (f_gosub -> .)
    COMP            reduce using rule 60 (f_gosub -> .)
    TO              reduce using rule 60 (f_gosub -> .)
    )               reduce using rule 60 (f_gosub -> .)
    ;               reduce using rule 60 (f_gosub -> .)
    ]               reduce using rule 60 (f_gosub -> .)
    ,               reduce using rule 60 (f_gosub -> .)
    {               reduce using rule 60 (f_gosub -> .)

    f_gosub                        shift and go to state 190

state 154

    (102) fact -> CALL to_num .

    &               reduce using rule 102 (fact -> CALL to_num .)
    OPFACT          reduce using rule 102 (fact -> CALL to_num .)
    OPTERM          reduce using rule 102 (fact -> CALL to_num .)
    COMP            reduce using rule 102 (fact -> CALL to_num .)
    TO              reduce using rule 102 (fact -> CALL to_num .)
    )               reduce using rule 102 (fact -> CALL to_num .)
    ;               reduce using rule 102 (fact -> CALL to_num .)
    ]               reduce using rule 102 (fact -> CALL to_num .)
    ,               reduce using rule 102 (fact -> CALL to_num .)
    {               reduce using rule 102 (fact -> CALL to_num .)


state 155

    (103) fact -> CALL to_str .

    &               reduce using rule 103 (fact -> CALL to_str .)
    OPFACT          reduce using rule 103 (fact -> CALL to_str .)
    OPTERM          reduce using rule 103 (fact -> CALL to_str .)
    COMP            reduce using rule 103 (fact -> CALL to_str .)
    TO              reduce using rule 103 (fact -> CALL to_str .)
    )               reduce using rule 103 (fact -> CALL to_str .)
    ;               reduce using rule 103 (fact -> CALL to_str .)
    ]               reduce using rule 103 (fact -> CALL to_str .)
    ,               reduce using rule 103 (fact -> CALL to_str .)
    {               reduce using rule 103 (fact -> CALL to_str .)


state 156

    (126) to_num -> TO_NUMBER . ( STR f_string )
    (127) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 191


state 157

    (128) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 192


state 158

    (104) fact -> STR f_string .

    &               reduce using rule 104 (fact -> STR f_string .)
    OPFACT          reduce using rule 104 (fact -> STR f_string .)
    OPTERM          reduce using rule 104 (fact -> STR f_string .)
    COMP            reduce using rule 104 (fact -> STR f_string .)
    TO              reduce using rule 104 (fact -> STR f_string .)
    )               reduce using rule 104 (fact -> STR f_string .)
    ;               reduce using rule 104 (fact -> STR f_string .)
    ]               reduce using rule 104 (fact -> STR f_string .)
    ,               reduce using rule 104 (fact -> STR f_string .)
    {               reduce using rule 104 (fact -> STR f_string .)


state 159

    (112) condicion -> IF ( expresion . ) f_if THEN { estatutos } condicionp f_endif
    (88) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 193
    COMP            shift and go to state 146


state 160

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc . { cvars estatutos } f_endfunc

    {               shift and go to state 194


state 161

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing . f_tipofunc { cvars estatutos } f_endfunc
    (22) f_tipofunc -> .

    {               reduce using rule 22 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 195

state 162

    (46) pparams -> pparams , tipo ID f_param .

    ,               reduce using rule 46 (pparams -> pparams , tipo ID f_param .)
    )               reduce using rule 46 (pparams -> pparams , tipo ID f_param .)


state 163

    (36) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] . f_enddim
    (40) f_enddim -> .

    :               reduce using rule 40 (f_enddim -> .)

    f_enddim                       shift and go to state 196

state 164

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } . f_endclass
    (15) f_endclass -> .

    TYPE            reduce using rule 15 (f_endclass -> .)
    DEF             reduce using rule 15 (f_endclass -> .)
    MAIN            reduce using rule 15 (f_endclass -> .)
    FUNC            reduce using rule 15 (f_endclass -> .)

    f_endclass                     shift and go to state 197

state 165

    (12) cvars -> cvars DEF tipo dimension : lista_id ; . f_delete_dim
    (30) f_delete_dim -> .

    DEF             reduce using rule 30 (f_delete_dim -> .)
    }               reduce using rule 30 (f_delete_dim -> .)
    FUNC            reduce using rule 30 (f_delete_dim -> .)
    CALL            reduce using rule 30 (f_delete_dim -> .)
    WHILE           reduce using rule 30 (f_delete_dim -> .)
    FOR             reduce using rule 30 (f_delete_dim -> .)
    IF              reduce using rule 30 (f_delete_dim -> .)
    ID              reduce using rule 30 (f_delete_dim -> .)

    f_delete_dim                   shift and go to state 198

state 166

    (73) var -> ID f_varobj : ID . f_verify_type_composite f_index_obj indexacion f_end_check
    (76) f_verify_type_composite -> .

    [               reduce using rule 76 (f_verify_type_composite -> .)
    =               reduce using rule 76 (f_verify_type_composite -> .)
    &               reduce using rule 76 (f_verify_type_composite -> .)
    OPFACT          reduce using rule 76 (f_verify_type_composite -> .)
    OPTERM          reduce using rule 76 (f_verify_type_composite -> .)
    COMP            reduce using rule 76 (f_verify_type_composite -> .)
    TO              reduce using rule 76 (f_verify_type_composite -> .)
    )               reduce using rule 76 (f_verify_type_composite -> .)
    ;               reduce using rule 76 (f_verify_type_composite -> .)
    ]               reduce using rule 76 (f_verify_type_composite -> .)
    ,               reduce using rule 76 (f_verify_type_composite -> .)
    {               reduce using rule 76 (f_verify_type_composite -> .)

    f_verify_type_composite        shift and go to state 199

state 167

    (74) var -> ID f_verify_type indexacion f_end_check .

    =               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    &               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    OPFACT          reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    OPTERM          reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    COMP            reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    TO              reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    )               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    ;               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    ]               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    ,               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)
    {               reduce using rule 74 (var -> ID f_verify_type indexacion f_end_check .)


state 168

    (79) indexacion -> [ f_start_array . expresion f_index ] f_end_array
    (80) indexacion -> [ f_start_array . expresion f_index ] [ f_next_index expresion f_index ] f_end_array
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 200
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 169

    (81) indexacion -> f_no_index empty .

    =               reduce using rule 81 (indexacion -> f_no_index empty .)
    &               reduce using rule 81 (indexacion -> f_no_index empty .)
    OPFACT          reduce using rule 81 (indexacion -> f_no_index empty .)
    OPTERM          reduce using rule 81 (indexacion -> f_no_index empty .)
    COMP            reduce using rule 81 (indexacion -> f_no_index empty .)
    TO              reduce using rule 81 (indexacion -> f_no_index empty .)
    )               reduce using rule 81 (indexacion -> f_no_index empty .)
    ;               reduce using rule 81 (indexacion -> f_no_index empty .)
    ]               reduce using rule 81 (indexacion -> f_no_index empty .)
    ,               reduce using rule 81 (indexacion -> f_no_index empty .)
    {               reduce using rule 81 (indexacion -> f_no_index empty .)


state 170

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .

    $end            reduce using rule 1 (start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .)


state 171

    (55) call_func -> func f_gosub f_end_call . f_end_check
    (77) f_end_check -> .

    ;               reduce using rule 77 (f_end_check -> .)

    f_end_check                    shift and go to state 201

state 172

    (61) func -> ID f_verify_func ( . args )
    (66) args -> . args_list f_end_args
    (67) args -> . f_end_args
    (68) args_list -> . expresion f_arg
    (69) args_list -> . args_list , expresion f_arg
    (71) f_end_args -> .
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    )               reduce using rule 71 (f_end_args -> .)
    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    args                           shift and go to state 202
    args_list                      shift and go to state 203
    f_end_args                     shift and go to state 204
    expresion                      shift and go to state 205
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 173

    (62) func -> ID f_varobj : . ID f_verify_func_composite ( args )

    ID              shift and go to state 206


state 174

    (129) input -> INPUT ( var . )

    )               shift and go to state 207


state 175

    (130) write -> PRINT ( write_list . ) f_call_empty_print
    (133) write_list -> write_list . & write_listp

    )               shift and go to state 208
    &               shift and go to state 209


state 176

    (131) write -> PRINT ( ) . f_call_empty_print
    (132) f_call_empty_print -> .

    ;               reduce using rule 132 (f_call_empty_print -> .)

    f_call_empty_print             shift and go to state 210

state 177

    (134) write_list -> write_listp .

    )               reduce using rule 134 (write_list -> write_listp .)
    &               reduce using rule 134 (write_list -> write_listp .)


state 178

    (135) write_listp -> STR . f_string
    (138) f_string -> .

    )               reduce using rule 138 (f_string -> .)
    &               reduce using rule 138 (f_string -> .)

    f_string                       shift and go to state 211

state 179

    (136) write_listp -> var .

    )               reduce using rule 136 (write_listp -> var .)
    &               reduce using rule 136 (write_listp -> var .)


state 180

    (137) write_listp -> CALL . to_str
    (128) to_str -> . TO_STRING ( expresion )

    TO_STRING       shift and go to state 157

    to_str                         shift and go to state 212

state 181

    (139) return -> RET ( expresion . )
    (88) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 213
    COMP            shift and go to state 146


state 182

    (72) asignacion -> var = f_oper expresion . ;
    (88) expresion -> expresion . COMP f_oper exp f_expres

    ;               shift and go to state 214
    COMP            shift and go to state 146


state 183

    (118) while -> WHILE f_while ( expresion . f_exprwhile ) DO { estatutos } f_endwhile
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (120) f_exprwhile -> .

    COMP            shift and go to state 146
    )               reduce using rule 120 (f_exprwhile -> .)

    f_exprwhile                    shift and go to state 215

state 184

    (122) for -> FOR expresion f_for_start TO . expresion f_for_to { estatutos } f_for_end
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 216
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 185

    (88) expresion -> expresion COMP f_oper . exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    exp                            shift and go to state 217
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 186

    (91) exp -> exp OPTERM f_oper . term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    term                           shift and go to state 218
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 187

    (94) term -> term OPFACT f_oper . fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    fact                           shift and go to state 219
    var                            shift and go to state 120

state 188

    (105) fact -> fact & f_oper . var f_concat
    (106) fact -> fact & f_oper . STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    STR             shift and go to state 221
    ID              shift and go to state 79

    var                            shift and go to state 220

state 189

    (97) fact -> ( f_lparen expresion . ) f_rparen
    (88) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 222
    COMP            shift and go to state 146


state 190

    (101) fact -> CALL func f_gosub . f_return_val f_end_call f_end_check
    (111) f_return_val -> .

    &               reduce using rule 111 (f_return_val -> .)
    OPFACT          reduce using rule 111 (f_return_val -> .)
    OPTERM          reduce using rule 111 (f_return_val -> .)
    COMP            reduce using rule 111 (f_return_val -> .)
    TO              reduce using rule 111 (f_return_val -> .)
    )               reduce using rule 111 (f_return_val -> .)
    ;               reduce using rule 111 (f_return_val -> .)
    ]               reduce using rule 111 (f_return_val -> .)
    ,               reduce using rule 111 (f_return_val -> .)
    {               reduce using rule 111 (f_return_val -> .)

    f_return_val                   shift and go to state 223

state 191

    (126) to_num -> TO_NUMBER ( . STR f_string )
    (127) to_num -> TO_NUMBER ( . var )
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    STR             shift and go to state 224
    ID              shift and go to state 79

    var                            shift and go to state 225

state 192

    (128) to_str -> TO_STRING ( . expresion )
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 226
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 193

    (112) condicion -> IF ( expresion ) . f_if THEN { estatutos } condicionp f_endif
    (115) f_if -> .

    THEN            reduce using rule 115 (f_if -> .)

    f_if                           shift and go to state 227

state 194

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { . cvars estatutos } f_endfunc
    (12) cvars -> . cvars DEF tipo dimension : lista_id ; f_delete_dim
    (13) cvars -> . empty
    (140) empty -> .

    DEF             reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    cvars                          shift and go to state 228
    empty                          shift and go to state 40

state 195

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc . { cvars estatutos } f_endfunc

    {               shift and go to state 229


state 196

    (36) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_enddim .

    :               reduce using rule 36 (dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_enddim .)


state 197

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)


state 198

    (12) cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .

    DEF             reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    }               reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    FUNC            reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    CALL            reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    WHILE           reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    FOR             reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    IF              reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)
    ID              reduce using rule 12 (cvars -> cvars DEF tipo dimension : lista_id ; f_delete_dim .)


state 199

    (73) var -> ID f_varobj : ID f_verify_type_composite . f_index_obj indexacion f_end_check
    (78) f_index_obj -> .

    [               reduce using rule 78 (f_index_obj -> .)
    =               reduce using rule 78 (f_index_obj -> .)
    &               reduce using rule 78 (f_index_obj -> .)
    OPFACT          reduce using rule 78 (f_index_obj -> .)
    OPTERM          reduce using rule 78 (f_index_obj -> .)
    COMP            reduce using rule 78 (f_index_obj -> .)
    TO              reduce using rule 78 (f_index_obj -> .)
    )               reduce using rule 78 (f_index_obj -> .)
    ;               reduce using rule 78 (f_index_obj -> .)
    ]               reduce using rule 78 (f_index_obj -> .)
    ,               reduce using rule 78 (f_index_obj -> .)
    {               reduce using rule 78 (f_index_obj -> .)

    f_index_obj                    shift and go to state 230

state 200

    (79) indexacion -> [ f_start_array expresion . f_index ] f_end_array
    (80) indexacion -> [ f_start_array expresion . f_index ] [ f_next_index expresion f_index ] f_end_array
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (84) f_index -> .

    COMP            shift and go to state 146
    ]               reduce using rule 84 (f_index -> .)

    f_index                        shift and go to state 231

state 201

    (55) call_func -> func f_gosub f_end_call f_end_check .

    ;               reduce using rule 55 (call_func -> func f_gosub f_end_call f_end_check .)


state 202

    (61) func -> ID f_verify_func ( args . )

    )               shift and go to state 232


state 203

    (66) args -> args_list . f_end_args
    (69) args_list -> args_list . , expresion f_arg
    (71) f_end_args -> .

    ,               shift and go to state 234
    )               reduce using rule 71 (f_end_args -> .)

    f_end_args                     shift and go to state 233

state 204

    (67) args -> f_end_args .

    )               reduce using rule 67 (args -> f_end_args .)


state 205

    (68) args_list -> expresion . f_arg
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (70) f_arg -> .

    COMP            shift and go to state 146
    ,               reduce using rule 70 (f_arg -> .)
    )               reduce using rule 70 (f_arg -> .)

    f_arg                          shift and go to state 235

state 206

    (62) func -> ID f_varobj : ID . f_verify_func_composite ( args )
    (65) f_verify_func_composite -> .

    (               reduce using rule 65 (f_verify_func_composite -> .)

    f_verify_func_composite        shift and go to state 236

state 207

    (129) input -> INPUT ( var ) .

    ;               reduce using rule 129 (input -> INPUT ( var ) .)


state 208

    (130) write -> PRINT ( write_list ) . f_call_empty_print
    (132) f_call_empty_print -> .

    ;               reduce using rule 132 (f_call_empty_print -> .)

    f_call_empty_print             shift and go to state 237

state 209

    (133) write_list -> write_list & . write_listp
    (135) write_listp -> . STR f_string
    (136) write_listp -> . var
    (137) write_listp -> . CALL to_str
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    STR             shift and go to state 178
    CALL            shift and go to state 180
    ID              shift and go to state 79

    write_listp                    shift and go to state 238
    var                            shift and go to state 179

state 210

    (131) write -> PRINT ( ) f_call_empty_print .

    ;               reduce using rule 131 (write -> PRINT ( ) f_call_empty_print .)


state 211

    (135) write_listp -> STR f_string .

    )               reduce using rule 135 (write_listp -> STR f_string .)
    &               reduce using rule 135 (write_listp -> STR f_string .)


state 212

    (137) write_listp -> CALL to_str .

    )               reduce using rule 137 (write_listp -> CALL to_str .)
    &               reduce using rule 137 (write_listp -> CALL to_str .)


state 213

    (139) return -> RET ( expresion ) .

    ;               reduce using rule 139 (return -> RET ( expresion ) .)


state 214

    (72) asignacion -> var = f_oper expresion ; .

    }               reduce using rule 72 (asignacion -> var = f_oper expresion ; .)
    CALL            reduce using rule 72 (asignacion -> var = f_oper expresion ; .)
    WHILE           reduce using rule 72 (asignacion -> var = f_oper expresion ; .)
    FOR             reduce using rule 72 (asignacion -> var = f_oper expresion ; .)
    IF              reduce using rule 72 (asignacion -> var = f_oper expresion ; .)
    ID              reduce using rule 72 (asignacion -> var = f_oper expresion ; .)


state 215

    (118) while -> WHILE f_while ( expresion f_exprwhile . ) DO { estatutos } f_endwhile

    )               shift and go to state 239


state 216

    (122) for -> FOR expresion f_for_start TO expresion . f_for_to { estatutos } f_for_end
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (124) f_for_to -> .

    COMP            shift and go to state 146
    {               reduce using rule 124 (f_for_to -> .)

    f_for_to                       shift and go to state 240

state 217

    (88) expresion -> expresion COMP f_oper exp . f_expres
    (91) exp -> exp . OPTERM f_oper term f_exp
    (89) f_expres -> .

    OPTERM          shift and go to state 147
    COMP            reduce using rule 89 (f_expres -> .)
    TO              reduce using rule 89 (f_expres -> .)
    )               reduce using rule 89 (f_expres -> .)
    ;               reduce using rule 89 (f_expres -> .)
    ]               reduce using rule 89 (f_expres -> .)
    ,               reduce using rule 89 (f_expres -> .)
    {               reduce using rule 89 (f_expres -> .)

    f_expres                       shift and go to state 241

state 218

    (91) exp -> exp OPTERM f_oper term . f_exp
    (94) term -> term . OPFACT f_oper fact f_term
    (92) f_exp -> .

    OPFACT          shift and go to state 148
    OPTERM          reduce using rule 92 (f_exp -> .)
    COMP            reduce using rule 92 (f_exp -> .)
    TO              reduce using rule 92 (f_exp -> .)
    )               reduce using rule 92 (f_exp -> .)
    ;               reduce using rule 92 (f_exp -> .)
    ]               reduce using rule 92 (f_exp -> .)
    ,               reduce using rule 92 (f_exp -> .)
    {               reduce using rule 92 (f_exp -> .)

    f_exp                          shift and go to state 242

state 219

    (94) term -> term OPFACT f_oper fact . f_term
    (105) fact -> fact . & f_oper var f_concat
    (106) fact -> fact . & f_oper STR f_string f_concat
    (95) f_term -> .

    &               shift and go to state 150
    OPFACT          reduce using rule 95 (f_term -> .)
    OPTERM          reduce using rule 95 (f_term -> .)
    COMP            reduce using rule 95 (f_term -> .)
    TO              reduce using rule 95 (f_term -> .)
    )               reduce using rule 95 (f_term -> .)
    ;               reduce using rule 95 (f_term -> .)
    ]               reduce using rule 95 (f_term -> .)
    ,               reduce using rule 95 (f_term -> .)
    {               reduce using rule 95 (f_term -> .)

    f_term                         shift and go to state 243

state 220

    (105) fact -> fact & f_oper var . f_concat
    (107) f_concat -> .

    &               reduce using rule 107 (f_concat -> .)
    OPFACT          reduce using rule 107 (f_concat -> .)
    OPTERM          reduce using rule 107 (f_concat -> .)
    COMP            reduce using rule 107 (f_concat -> .)
    TO              reduce using rule 107 (f_concat -> .)
    )               reduce using rule 107 (f_concat -> .)
    ;               reduce using rule 107 (f_concat -> .)
    ]               reduce using rule 107 (f_concat -> .)
    ,               reduce using rule 107 (f_concat -> .)
    {               reduce using rule 107 (f_concat -> .)

    f_concat                       shift and go to state 244

state 221

    (106) fact -> fact & f_oper STR . f_string f_concat
    (138) f_string -> .

    &               reduce using rule 138 (f_string -> .)
    OPFACT          reduce using rule 138 (f_string -> .)
    OPTERM          reduce using rule 138 (f_string -> .)
    COMP            reduce using rule 138 (f_string -> .)
    TO              reduce using rule 138 (f_string -> .)
    )               reduce using rule 138 (f_string -> .)
    ;               reduce using rule 138 (f_string -> .)
    ]               reduce using rule 138 (f_string -> .)
    ,               reduce using rule 138 (f_string -> .)
    {               reduce using rule 138 (f_string -> .)

    f_string                       shift and go to state 245

state 222

    (97) fact -> ( f_lparen expresion ) . f_rparen
    (109) f_rparen -> .

    &               reduce using rule 109 (f_rparen -> .)
    OPFACT          reduce using rule 109 (f_rparen -> .)
    OPTERM          reduce using rule 109 (f_rparen -> .)
    COMP            reduce using rule 109 (f_rparen -> .)
    TO              reduce using rule 109 (f_rparen -> .)
    )               reduce using rule 109 (f_rparen -> .)
    ;               reduce using rule 109 (f_rparen -> .)
    ]               reduce using rule 109 (f_rparen -> .)
    ,               reduce using rule 109 (f_rparen -> .)
    {               reduce using rule 109 (f_rparen -> .)

    f_rparen                       shift and go to state 246

state 223

    (101) fact -> CALL func f_gosub f_return_val . f_end_call f_end_check
    (59) f_end_call -> .

    &               reduce using rule 59 (f_end_call -> .)
    OPFACT          reduce using rule 59 (f_end_call -> .)
    OPTERM          reduce using rule 59 (f_end_call -> .)
    COMP            reduce using rule 59 (f_end_call -> .)
    TO              reduce using rule 59 (f_end_call -> .)
    )               reduce using rule 59 (f_end_call -> .)
    ;               reduce using rule 59 (f_end_call -> .)
    ]               reduce using rule 59 (f_end_call -> .)
    ,               reduce using rule 59 (f_end_call -> .)
    {               reduce using rule 59 (f_end_call -> .)

    f_end_call                     shift and go to state 247

state 224

    (126) to_num -> TO_NUMBER ( STR . f_string )
    (138) f_string -> .

    )               reduce using rule 138 (f_string -> .)

    f_string                       shift and go to state 248

state 225

    (127) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 249


state 226

    (128) to_str -> TO_STRING ( expresion . )
    (88) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 250
    COMP            shift and go to state 146


state 227

    (112) condicion -> IF ( expresion ) f_if . THEN { estatutos } condicionp f_endif

    THEN            shift and go to state 251


state 228

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars . estatutos } f_endfunc
    (12) cvars -> cvars . DEF tipo dimension : lista_id ; f_delete_dim
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    DEF             shift and go to state 50
    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 252
    empty                          shift and go to state 67

state 229

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { . cvars estatutos } f_endfunc
    (12) cvars -> . cvars DEF tipo dimension : lista_id ; f_delete_dim
    (13) cvars -> . empty
    (140) empty -> .

    DEF             reduce using rule 140 (empty -> .)
    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    cvars                          shift and go to state 253
    empty                          shift and go to state 40

state 230

    (73) var -> ID f_varobj : ID f_verify_type_composite f_index_obj . indexacion f_end_check
    (79) indexacion -> . [ f_start_array expresion f_index ] f_end_array
    (80) indexacion -> . [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array
    (81) indexacion -> . f_no_index empty
    (82) f_no_index -> .

    [               shift and go to state 133
    =               reduce using rule 82 (f_no_index -> .)
    &               reduce using rule 82 (f_no_index -> .)
    OPFACT          reduce using rule 82 (f_no_index -> .)
    OPTERM          reduce using rule 82 (f_no_index -> .)
    COMP            reduce using rule 82 (f_no_index -> .)
    TO              reduce using rule 82 (f_no_index -> .)
    )               reduce using rule 82 (f_no_index -> .)
    ;               reduce using rule 82 (f_no_index -> .)
    ]               reduce using rule 82 (f_no_index -> .)
    ,               reduce using rule 82 (f_no_index -> .)
    {               reduce using rule 82 (f_no_index -> .)

    indexacion                     shift and go to state 254
    f_no_index                     shift and go to state 134

state 231

    (79) indexacion -> [ f_start_array expresion f_index . ] f_end_array
    (80) indexacion -> [ f_start_array expresion f_index . ] [ f_next_index expresion f_index ] f_end_array

    ]               shift and go to state 255


state 232

    (61) func -> ID f_verify_func ( args ) .

    ;               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    &               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    OPFACT          reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    OPTERM          reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    COMP            reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    TO              reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    )               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    ]               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    ,               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    {               reduce using rule 61 (func -> ID f_verify_func ( args ) .)


state 233

    (66) args -> args_list f_end_args .

    )               reduce using rule 66 (args -> args_list f_end_args .)


state 234

    (69) args_list -> args_list , . expresion f_arg
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 256
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 235

    (68) args_list -> expresion f_arg .

    ,               reduce using rule 68 (args_list -> expresion f_arg .)
    )               reduce using rule 68 (args_list -> expresion f_arg .)


state 236

    (62) func -> ID f_varobj : ID f_verify_func_composite . ( args )

    (               shift and go to state 257


state 237

    (130) write -> PRINT ( write_list ) f_call_empty_print .

    ;               reduce using rule 130 (write -> PRINT ( write_list ) f_call_empty_print .)


state 238

    (133) write_list -> write_list & write_listp .

    )               reduce using rule 133 (write_list -> write_list & write_listp .)
    &               reduce using rule 133 (write_list -> write_list & write_listp .)


state 239

    (118) while -> WHILE f_while ( expresion f_exprwhile ) . DO { estatutos } f_endwhile

    DO              shift and go to state 258


state 240

    (122) for -> FOR expresion f_for_start TO expresion f_for_to . { estatutos } f_for_end

    {               shift and go to state 259


state 241

    (88) expresion -> expresion COMP f_oper exp f_expres .

    COMP            reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    TO              reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    )               reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    ;               reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    ]               reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    ,               reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)
    {               reduce using rule 88 (expresion -> expresion COMP f_oper exp f_expres .)


state 242

    (91) exp -> exp OPTERM f_oper term f_exp .

    OPTERM          reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    COMP            reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    TO              reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    )               reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    ;               reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    ]               reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    ,               reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)
    {               reduce using rule 91 (exp -> exp OPTERM f_oper term f_exp .)


state 243

    (94) term -> term OPFACT f_oper fact f_term .

    OPFACT          reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    OPTERM          reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    COMP            reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    TO              reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    )               reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    ;               reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    ]               reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    ,               reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)
    {               reduce using rule 94 (term -> term OPFACT f_oper fact f_term .)


state 244

    (105) fact -> fact & f_oper var f_concat .

    &               reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    OPFACT          reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    OPTERM          reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    COMP            reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    TO              reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    )               reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    ;               reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    ]               reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    ,               reduce using rule 105 (fact -> fact & f_oper var f_concat .)
    {               reduce using rule 105 (fact -> fact & f_oper var f_concat .)


state 245

    (106) fact -> fact & f_oper STR f_string . f_concat
    (107) f_concat -> .

    &               reduce using rule 107 (f_concat -> .)
    OPFACT          reduce using rule 107 (f_concat -> .)
    OPTERM          reduce using rule 107 (f_concat -> .)
    COMP            reduce using rule 107 (f_concat -> .)
    TO              reduce using rule 107 (f_concat -> .)
    )               reduce using rule 107 (f_concat -> .)
    ;               reduce using rule 107 (f_concat -> .)
    ]               reduce using rule 107 (f_concat -> .)
    ,               reduce using rule 107 (f_concat -> .)
    {               reduce using rule 107 (f_concat -> .)

    f_concat                       shift and go to state 260

state 246

    (97) fact -> ( f_lparen expresion ) f_rparen .

    &               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    OPFACT          reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    OPTERM          reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    COMP            reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    TO              reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    )               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    ;               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    ]               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    ,               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)
    {               reduce using rule 97 (fact -> ( f_lparen expresion ) f_rparen .)


state 247

    (101) fact -> CALL func f_gosub f_return_val f_end_call . f_end_check
    (77) f_end_check -> .

    &               reduce using rule 77 (f_end_check -> .)
    OPFACT          reduce using rule 77 (f_end_check -> .)
    OPTERM          reduce using rule 77 (f_end_check -> .)
    COMP            reduce using rule 77 (f_end_check -> .)
    TO              reduce using rule 77 (f_end_check -> .)
    )               reduce using rule 77 (f_end_check -> .)
    ;               reduce using rule 77 (f_end_check -> .)
    ]               reduce using rule 77 (f_end_check -> .)
    ,               reduce using rule 77 (f_end_check -> .)
    {               reduce using rule 77 (f_end_check -> .)

    f_end_check                    shift and go to state 261

state 248

    (126) to_num -> TO_NUMBER ( STR f_string . )

    )               shift and go to state 262


state 249

    (127) to_num -> TO_NUMBER ( var ) .

    &               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    OPFACT          reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    ;               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 127 (to_num -> TO_NUMBER ( var ) .)


state 250

    (128) to_str -> TO_STRING ( expresion ) .

    &               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    OPFACT          reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    ;               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 128 (to_str -> TO_STRING ( expresion ) .)


state 251

    (112) condicion -> IF ( expresion ) f_if THEN . { estatutos } condicionp f_endif

    {               shift and go to state 263


state 252

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos . } f_endfunc
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 264
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 253

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars . estatutos } f_endfunc
    (12) cvars -> cvars . DEF tipo dimension : lista_id ; f_delete_dim
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    DEF             shift and go to state 50
    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 265
    empty                          shift and go to state 67

state 254

    (73) var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion . f_end_check
    (77) f_end_check -> .

    =               reduce using rule 77 (f_end_check -> .)
    &               reduce using rule 77 (f_end_check -> .)
    OPFACT          reduce using rule 77 (f_end_check -> .)
    OPTERM          reduce using rule 77 (f_end_check -> .)
    COMP            reduce using rule 77 (f_end_check -> .)
    TO              reduce using rule 77 (f_end_check -> .)
    )               reduce using rule 77 (f_end_check -> .)
    ;               reduce using rule 77 (f_end_check -> .)
    ]               reduce using rule 77 (f_end_check -> .)
    ,               reduce using rule 77 (f_end_check -> .)
    {               reduce using rule 77 (f_end_check -> .)

    f_end_check                    shift and go to state 266

state 255

    (79) indexacion -> [ f_start_array expresion f_index ] . f_end_array
    (80) indexacion -> [ f_start_array expresion f_index ] . [ f_next_index expresion f_index ] f_end_array
    (86) f_end_array -> .

    [               shift and go to state 267
    =               reduce using rule 86 (f_end_array -> .)
    &               reduce using rule 86 (f_end_array -> .)
    OPFACT          reduce using rule 86 (f_end_array -> .)
    OPTERM          reduce using rule 86 (f_end_array -> .)
    COMP            reduce using rule 86 (f_end_array -> .)
    TO              reduce using rule 86 (f_end_array -> .)
    )               reduce using rule 86 (f_end_array -> .)
    ;               reduce using rule 86 (f_end_array -> .)
    ]               reduce using rule 86 (f_end_array -> .)
    ,               reduce using rule 86 (f_end_array -> .)
    {               reduce using rule 86 (f_end_array -> .)

    f_end_array                    shift and go to state 268

state 256

    (69) args_list -> args_list , expresion . f_arg
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (70) f_arg -> .

    COMP            shift and go to state 146
    ,               reduce using rule 70 (f_arg -> .)
    )               reduce using rule 70 (f_arg -> .)

    f_arg                          shift and go to state 269

state 257

    (62) func -> ID f_varobj : ID f_verify_func_composite ( . args )
    (66) args -> . args_list f_end_args
    (67) args -> . f_end_args
    (68) args_list -> . expresion f_arg
    (69) args_list -> . args_list , expresion f_arg
    (71) f_end_args -> .
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    )               reduce using rule 71 (f_end_args -> .)
    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    args                           shift and go to state 270
    args_list                      shift and go to state 203
    f_end_args                     shift and go to state 204
    expresion                      shift and go to state 205
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 258

    (118) while -> WHILE f_while ( expresion f_exprwhile ) DO . { estatutos } f_endwhile

    {               shift and go to state 271


state 259

    (122) for -> FOR expresion f_for_start TO expresion f_for_to { . estatutos } f_for_end
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 272
    empty                          shift and go to state 67

state 260

    (106) fact -> fact & f_oper STR f_string f_concat .

    &               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    OPFACT          reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    OPTERM          reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    COMP            reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    TO              reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    )               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    ;               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    ]               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    ,               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)
    {               reduce using rule 106 (fact -> fact & f_oper STR f_string f_concat .)


state 261

    (101) fact -> CALL func f_gosub f_return_val f_end_call f_end_check .

    &               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    OPFACT          reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    OPTERM          reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    COMP            reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    TO              reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    )               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    ;               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    ]               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    ,               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)
    {               reduce using rule 101 (fact -> CALL func f_gosub f_return_val f_end_call f_end_check .)


state 262

    (126) to_num -> TO_NUMBER ( STR f_string ) .

    &               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    OPFACT          reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    OPTERM          reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    COMP            reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    TO              reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    )               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    ;               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    ]               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    ,               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)
    {               reduce using rule 126 (to_num -> TO_NUMBER ( STR f_string ) .)


state 263

    (112) condicion -> IF ( expresion ) f_if THEN { . estatutos } condicionp f_endif
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 273
    empty                          shift and go to state 67

state 264

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } . f_endfunc
    (23) f_endfunc -> .

    MAIN            reduce using rule 23 (f_endfunc -> .)
    FUNC            reduce using rule 23 (f_endfunc -> .)
    }               reduce using rule 23 (f_endfunc -> .)

    f_endfunc                      shift and go to state 274

state 265

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos . } f_endfunc
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 275
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 266

    (73) var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .

    =               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    &               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    OPFACT          reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    OPTERM          reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    COMP            reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    TO              reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    )               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    ;               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    ]               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    ,               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)
    {               reduce using rule 73 (var -> ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check .)


state 267

    (80) indexacion -> [ f_start_array expresion f_index ] [ . f_next_index expresion f_index ] f_end_array
    (85) f_next_index -> .

    (               reduce using rule 85 (f_next_index -> .)
    NUM             reduce using rule 85 (f_next_index -> .)
    OPTERM          reduce using rule 85 (f_next_index -> .)
    CALL            reduce using rule 85 (f_next_index -> .)
    STR             reduce using rule 85 (f_next_index -> .)
    ID              reduce using rule 85 (f_next_index -> .)

    f_next_index                   shift and go to state 276

state 268

    (79) indexacion -> [ f_start_array expresion f_index ] f_end_array .

    =               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    &               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    OPFACT          reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    OPTERM          reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    COMP            reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    TO              reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    )               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    ;               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    ]               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    ,               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)
    {               reduce using rule 79 (indexacion -> [ f_start_array expresion f_index ] f_end_array .)


state 269

    (69) args_list -> args_list , expresion f_arg .

    ,               reduce using rule 69 (args_list -> args_list , expresion f_arg .)
    )               reduce using rule 69 (args_list -> args_list , expresion f_arg .)


state 270

    (62) func -> ID f_varobj : ID f_verify_func_composite ( args . )

    )               shift and go to state 277


state 271

    (118) while -> WHILE f_while ( expresion f_exprwhile ) DO { . estatutos } f_endwhile
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 278
    empty                          shift and go to state 67

state 272

    (122) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos . } f_for_end
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 279
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 273

    (112) condicion -> IF ( expresion ) f_if THEN { estatutos . } condicionp f_endif
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 280
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 274

    (18) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc .

    MAIN            reduce using rule 18 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc .)
    FUNC            reduce using rule 18 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc .)
    }               reduce using rule 18 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { cvars estatutos } f_endfunc .)


state 275

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } . f_endfunc
    (23) f_endfunc -> .

    MAIN            reduce using rule 23 (f_endfunc -> .)
    FUNC            reduce using rule 23 (f_endfunc -> .)
    }               reduce using rule 23 (f_endfunc -> .)

    f_endfunc                      shift and go to state 281

state 276

    (80) indexacion -> [ f_start_array expresion f_index ] [ f_next_index . expresion f_index ] f_end_array
    (87) expresion -> . exp
    (88) expresion -> . expresion COMP f_oper exp f_expres
    (90) exp -> . term
    (91) exp -> . exp OPTERM f_oper term f_exp
    (93) term -> . fact
    (94) term -> . term OPFACT f_oper fact f_term
    (97) fact -> . ( f_lparen expresion ) f_rparen
    (98) fact -> . var
    (99) fact -> . NUM f_fact
    (100) fact -> . OPTERM NUM
    (101) fact -> . CALL func f_gosub f_return_val f_end_call f_end_check
    (102) fact -> . CALL to_num
    (103) fact -> . CALL to_str
    (104) fact -> . STR f_string
    (105) fact -> . fact & f_oper var f_concat
    (106) fact -> . fact & f_oper STR f_string f_concat
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    (               shift and go to state 119
    NUM             shift and go to state 121
    OPTERM          shift and go to state 117
    CALL            shift and go to state 122
    STR             shift and go to state 123
    ID              shift and go to state 79

    expresion                      shift and go to state 282
    exp                            shift and go to state 115
    term                           shift and go to state 116
    fact                           shift and go to state 118
    var                            shift and go to state 120

state 277

    (62) func -> ID f_varobj : ID f_verify_func_composite ( args ) .

    ;               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    &               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPFACT          reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPTERM          reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    COMP            reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    TO              reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    )               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ]               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ,               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    {               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)


state 278

    (118) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos . } f_endwhile
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 283
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 279

    (122) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } . f_for_end
    (125) f_for_end -> .

    }               reduce using rule 125 (f_for_end -> .)
    CALL            reduce using rule 125 (f_for_end -> .)
    WHILE           reduce using rule 125 (f_for_end -> .)
    FOR             reduce using rule 125 (f_for_end -> .)
    IF              reduce using rule 125 (f_for_end -> .)
    ID              reduce using rule 125 (f_for_end -> .)

    f_for_end                      shift and go to state 284

state 280

    (112) condicion -> IF ( expresion ) f_if THEN { estatutos } . condicionp f_endif
    (113) condicionp -> . ELSE f_else { estatutos }
    (114) condicionp -> . empty
    (140) empty -> .

    ELSE            shift and go to state 286
    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    condicionp                     shift and go to state 285
    empty                          shift and go to state 287

state 281

    (19) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc .

    MAIN            reduce using rule 19 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc .)
    FUNC            reduce using rule 19 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc .)
    }               reduce using rule 19 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { cvars estatutos } f_endfunc .)


state 282

    (80) indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion . f_index ] f_end_array
    (88) expresion -> expresion . COMP f_oper exp f_expres
    (84) f_index -> .

    COMP            shift and go to state 146
    ]               reduce using rule 84 (f_index -> .)

    f_index                        shift and go to state 288

state 283

    (118) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } . f_endwhile
    (121) f_endwhile -> .

    }               reduce using rule 121 (f_endwhile -> .)
    CALL            reduce using rule 121 (f_endwhile -> .)
    WHILE           reduce using rule 121 (f_endwhile -> .)
    FOR             reduce using rule 121 (f_endwhile -> .)
    IF              reduce using rule 121 (f_endwhile -> .)
    ID              reduce using rule 121 (f_endwhile -> .)

    f_endwhile                     shift and go to state 289

state 284

    (122) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .

    }               reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    CALL            reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    WHILE           reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    FOR             reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    IF              reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    ID              reduce using rule 122 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)


state 285

    (112) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp . f_endif
    (116) f_endif -> .

    }               reduce using rule 116 (f_endif -> .)
    CALL            reduce using rule 116 (f_endif -> .)
    WHILE           reduce using rule 116 (f_endif -> .)
    FOR             reduce using rule 116 (f_endif -> .)
    IF              reduce using rule 116 (f_endif -> .)
    ID              reduce using rule 116 (f_endif -> .)

    f_endif                        shift and go to state 290

state 286

    (113) condicionp -> ELSE . f_else { estatutos }
    (117) f_else -> .

    {               reduce using rule 117 (f_else -> .)

    f_else                         shift and go to state 291

state 287

    (114) condicionp -> empty .

    }               reduce using rule 114 (condicionp -> empty .)
    CALL            reduce using rule 114 (condicionp -> empty .)
    WHILE           reduce using rule 114 (condicionp -> empty .)
    FOR             reduce using rule 114 (condicionp -> empty .)
    IF              reduce using rule 114 (condicionp -> empty .)
    ID              reduce using rule 114 (condicionp -> empty .)


state 288

    (80) indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index . ] f_end_array

    ]               shift and go to state 292


state 289

    (118) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .

    }               reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    CALL            reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    WHILE           reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    FOR             reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    IF              reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    ID              reduce using rule 118 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)


state 290

    (112) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .

    }               reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    CALL            reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    WHILE           reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    FOR             reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    IF              reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    ID              reduce using rule 112 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)


state 291

    (113) condicionp -> ELSE f_else . { estatutos }

    {               shift and go to state 293


state 292

    (80) indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] . f_end_array
    (86) f_end_array -> .

    =               reduce using rule 86 (f_end_array -> .)
    &               reduce using rule 86 (f_end_array -> .)
    OPFACT          reduce using rule 86 (f_end_array -> .)
    OPTERM          reduce using rule 86 (f_end_array -> .)
    COMP            reduce using rule 86 (f_end_array -> .)
    TO              reduce using rule 86 (f_end_array -> .)
    )               reduce using rule 86 (f_end_array -> .)
    ;               reduce using rule 86 (f_end_array -> .)
    ]               reduce using rule 86 (f_end_array -> .)
    ,               reduce using rule 86 (f_end_array -> .)
    {               reduce using rule 86 (f_end_array -> .)

    f_end_array                    shift and go to state 294

state 293

    (113) condicionp -> ELSE f_else { . estatutos }
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (140) empty -> .

    }               reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    WHILE           reduce using rule 140 (empty -> .)
    FOR             reduce using rule 140 (empty -> .)
    IF              reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)

    estatutos                      shift and go to state 295
    empty                          shift and go to state 67

state 294

    (80) indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .

    =               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    &               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    OPFACT          reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    OPTERM          reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    COMP            reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    TO              reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    )               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    ;               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    ]               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    ,               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)
    {               reduce using rule 80 (indexacion -> [ f_start_array expresion f_index ] [ f_next_index expresion f_index ] f_end_array .)


state 295

    (113) condicionp -> ELSE f_else { estatutos . }
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (72) asignacion -> . var = f_oper expresion ;
    (118) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (122) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (112) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (73) var -> . ID f_varobj : ID f_verify_type_composite f_index_obj indexacion f_end_check
    (74) var -> . ID f_verify_type indexacion f_end_check

    }               shift and go to state 296
    CALL            shift and go to state 86
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    IF              shift and go to state 90
    ID              shift and go to state 79

    estatuto                       shift and go to state 81
    asignacion                     shift and go to state 82
    while                          shift and go to state 83
    for                            shift and go to state 84
    condicion                      shift and go to state 85
    var                            shift and go to state 87

state 296

    (113) condicionp -> ELSE f_else { estatutos } .

    }               reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)
    CALL            reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)
    WHILE           reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)
    FOR             reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)
    IF              reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)
    ID              reduce using rule 113 (condicionp -> ELSE f_else { estatutos } .)

