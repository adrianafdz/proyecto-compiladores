Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ;
Rule 2     f_start -> <empty>
Rule 3     f_prog -> <empty>
Rule 4     f_end -> <empty>
Rule 5     clases -> clases clase
Rule 6     clases -> empty
Rule 7     clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
Rule 8     clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
Rule 9     f_startclass -> <empty>
Rule 10    f_clasepadre -> <empty>
Rule 11    f_cvars -> <empty>
Rule 12    f_endclass -> <empty>
Rule 13    funciones -> funciones funcion
Rule 14    funciones -> empty
Rule 15    funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
Rule 16    funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
Rule 17    f_startfunc -> <empty>
Rule 18    f_nothing -> <empty>
Rule 19    f_tipofunc -> <empty>
Rule 20    f_endfunc -> <empty>
Rule 21    vars -> vars DEF tipo dimension : lista_id ;
Rule 22    vars -> vars DEF ID f_varsobj : lista_id ;
Rule 23    vars -> empty
Rule 24    f_varsobj -> <empty>
Rule 25    cvars -> cvars DEF tipo dimension : lista_id ;
Rule 26    cvars -> empty
Rule 27    lista_id -> ID f_vars
Rule 28    lista_id -> lista_id , ID f_vars
Rule 29    f_vars -> <empty>
Rule 30    dimension -> [ expresion f_dim1 ] f_onedim
Rule 31    dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
Rule 32    dimension -> empty
Rule 33    f_dim1 -> <empty>
Rule 34    f_dim2 -> <empty>
Rule 35    f_onedim -> <empty>
Rule 36    f_twodim -> <empty>
Rule 37    tipo -> NUMBER
Rule 38    tipo -> STRING
Rule 39    params -> pparams
Rule 40    params -> empty
Rule 41    pparams -> tipo ID f_param
Rule 42    pparams -> pparams , tipo ID f_param
Rule 43    f_param -> <empty>
Rule 44    estatutos -> estatutos estatuto
Rule 45    estatutos -> empty
Rule 46    estatuto -> asignacion
Rule 47    estatuto -> while
Rule 48    estatuto -> for
Rule 49    estatuto -> condicion
Rule 50    estatuto -> CALL call_func ;
Rule 51    call_func -> func
Rule 52    call_func -> input
Rule 53    call_func -> write
Rule 54    call_func -> to_num
Rule 55    call_func -> to_str
Rule 56    call_func -> return
Rule 57    func -> ID f_verify_func ( args )
Rule 58    func -> ID f_varobj : ID f_verify_func_composite ( args )
Rule 59    f_verify_func -> <empty>
Rule 60    f_verify_func_composite -> <empty>
Rule 61    args -> args_list
Rule 62    args -> empty
Rule 63    args_list -> expresion
Rule 64    args_list -> args_list , expresion
Rule 65    asignacion -> var = f_oper expresion ;
Rule 66    var -> ID f_varobj : ID f_verify_type_composite dimension
Rule 67    var -> ID f_verify_type dimension
Rule 68    f_varobj -> <empty>
Rule 69    f_verify_type -> <empty>
Rule 70    f_verify_type_composite -> <empty>
Rule 71    expresion -> exp
Rule 72    expresion -> expresion COMP f_oper exp f_expres
Rule 73    f_expres -> <empty>
Rule 74    exp -> term
Rule 75    exp -> exp OPTERM f_oper term f_exp
Rule 76    f_exp -> <empty>
Rule 77    term -> fact
Rule 78    term -> term OPFACT f_oper fact f_term
Rule 79    f_term -> <empty>
Rule 80    f_oper -> <empty>
Rule 81    fact -> ( lparen expresion ) rparen
Rule 82    fact -> var
Rule 83    fact -> NUM f_fact
Rule 84    fact -> OPTERM NUM
Rule 85    fact -> CALL call_func
Rule 86    lparen -> <empty>
Rule 87    rparen -> <empty>
Rule 88    f_fact -> <empty>
Rule 89    condicion -> IF ( expresion ) THEN { estatutos } condicionp
Rule 90    condicionp -> ELSE { estatutos }
Rule 91    condicionp -> empty
Rule 92    while -> WHILE ( expresion ) DO { estatutos }
Rule 93    for -> FOR expresion TO expresion { estatutos }
Rule 94    to_num -> TO_NUMBER ( STR )
Rule 95    to_num -> TO_NUMBER ( var )
Rule 96    to_str -> TO_STRING ( expresion )
Rule 97    input -> INPUT ( var )
Rule 98    write -> PRINT ( write_list )
Rule 99    write_list -> write_list & write_listp
Rule 100   write_list -> write_listp
Rule 101   write_listp -> STR
Rule 102   write_listp -> var
Rule 103   write_listp -> CALL to_str
Rule 104   return -> RET ( expresion )
Rule 105   empty -> <empty>

Terminals, with rules where they appear

&                    : 99
(                    : 1 15 16 57 58 81 89 92 94 95 96 97 98 104
)                    : 1 15 16 57 58 81 89 92 94 95 96 97 98 104
,                    : 28 42 64
:                    : 7 15 16 21 22 25 58 66
;                    : 1 1 21 22 25 50 65
=                    : 65
CALL                 : 50 85 103
COMP                 : 72
DEF                  : 21 22 25
DO                   : 92
ELSE                 : 90
END                  : 1
FOR                  : 93
FUNC                 : 15 16
ID                   : 1 7 7 8 15 16 22 27 28 41 42 57 58 58 66 66 67
IF                   : 89
INPUT                : 97
MAIN                 : 1
NOTHING              : 16
NUM                  : 83 84
NUMBER               : 37
OPFACT               : 78
OPTERM               : 75 84
PRINT                : 98
PROGRAM              : 1
RET                  : 104
STR                  : 94 101
STRING               : 38
THEN                 : 89
TO                   : 93
TO_NUMBER            : 94 95
TO_STRING            : 96
TYPE                 : 7 8
WHILE                : 92
[                    : 30 31 31
]                    : 30 31 31
error                : 
{                    : 1 7 8 15 16 89 90 92 93
}                    : 1 7 8 15 16 89 90 92 93

Nonterminals, with rules where they appear

args                 : 57 58
args_list            : 61 64
asignacion           : 46
call_func            : 50 85
clase                : 5
clases               : 1 5
condicion            : 49
condicionp           : 89
cvars                : 7 8 25
dimension            : 21 25 66 67
empty                : 6 14 23 26 32 40 45 62 91
estatuto             : 44
estatutos            : 1 15 16 44 89 90 92 93
exp                  : 71 72 75
expresion            : 30 31 31 63 64 65 72 81 89 92 93 93 96 104
f_clasepadre         : 7
f_cvars              : 7 8
f_dim1               : 30 31
f_dim2               : 31
f_end                : 1
f_endclass           : 7 8
f_endfunc            : 15 16
f_exp                : 75
f_expres             : 72
f_fact               : 83
f_nothing            : 16
f_onedim             : 30
f_oper               : 65 72 75 78
f_param              : 41 42
f_prog               : 1
f_start              : 1
f_startclass         : 7 8
f_startfunc          : 15 16
f_term               : 78
f_tipofunc           : 15 16
f_twodim             : 31
f_varobj             : 58 66
f_vars               : 27 28
f_varsobj            : 22
f_verify_func        : 57
f_verify_func_composite : 58
f_verify_type        : 67
f_verify_type_composite : 66
fact                 : 77 78
for                  : 48
func                 : 51
funcion              : 13
funciones            : 1 7 8 13
input                : 52
lista_id             : 21 22 25 28
lparen               : 81
params               : 15 16
pparams              : 39 42
return               : 56
rparen               : 81
start                : 0
term                 : 74 75 78
tipo                 : 15 21 25 41 42
to_num               : 54
to_str               : 55 103
var                  : 65 82 95 97 102
vars                 : 1 15 16 21 22
while                : 47
write                : 53
write_list           : 98 99
write_listp          : 99 100

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ;
    (2) f_start -> .

    ID              reduce using rule 2 (f_start -> .)

    f_start                        shift and go to state 3

state 3

    (1) start -> PROGRAM f_start . ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ;

    ID              shift and go to state 4


state 4

    (1) start -> PROGRAM f_start ID . f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ;
    (3) f_prog -> .

    ;               reduce using rule 3 (f_prog -> .)

    f_prog                         shift and go to state 5

state 5

    (1) start -> PROGRAM f_start ID f_prog . ; clases vars funciones MAIN ( ) { estatutos } END f_end ;

    ;               shift and go to state 6


state 6

    (1) start -> PROGRAM f_start ID f_prog ; . clases vars funciones MAIN ( ) { estatutos } END f_end ;
    (5) clases -> . clases clase
    (6) clases -> . empty
    (105) empty -> .

    TYPE            reduce using rule 105 (empty -> .)
    DEF             reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    clases                         shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) start -> PROGRAM f_start ID f_prog ; clases . vars funciones MAIN ( ) { estatutos } END f_end ;
    (5) clases -> clases . clase
    (21) vars -> . vars DEF tipo dimension : lista_id ;
    (22) vars -> . vars DEF ID f_varsobj : lista_id ;
    (23) vars -> . empty
    (7) clase -> . TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (8) clase -> . TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
    (105) empty -> .

    TYPE            shift and go to state 12
    DEF             reduce using rule 105 (empty -> .)
    MAIN            reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    vars                           shift and go to state 9
    clase                          shift and go to state 10
    empty                          shift and go to state 11

state 8

    (6) clases -> empty .

    TYPE            reduce using rule 6 (clases -> empty .)
    DEF             reduce using rule 6 (clases -> empty .)
    MAIN            reduce using rule 6 (clases -> empty .)
    FUNC            reduce using rule 6 (clases -> empty .)


state 9

    (1) start -> PROGRAM f_start ID f_prog ; clases vars . funciones MAIN ( ) { estatutos } END f_end ;
    (21) vars -> vars . DEF tipo dimension : lista_id ;
    (22) vars -> vars . DEF ID f_varsobj : lista_id ;
    (13) funciones -> . funciones funcion
    (14) funciones -> . empty
    (105) empty -> .

    DEF             shift and go to state 14
    MAIN            reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    funciones                      shift and go to state 13
    empty                          shift and go to state 15

state 10

    (5) clases -> clases clase .

    TYPE            reduce using rule 5 (clases -> clases clase .)
    DEF             reduce using rule 5 (clases -> clases clase .)
    MAIN            reduce using rule 5 (clases -> clases clase .)
    FUNC            reduce using rule 5 (clases -> clases clase .)


state 11

    (23) vars -> empty .

    DEF             reduce using rule 23 (vars -> empty .)
    MAIN            reduce using rule 23 (vars -> empty .)
    FUNC            reduce using rule 23 (vars -> empty .)
    }               reduce using rule 23 (vars -> empty .)
    CALL            reduce using rule 23 (vars -> empty .)
    WHILE           reduce using rule 23 (vars -> empty .)
    FOR             reduce using rule 23 (vars -> empty .)
    IF              reduce using rule 23 (vars -> empty .)
    ID              reduce using rule 23 (vars -> empty .)


state 12

    (7) clase -> TYPE . ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (8) clase -> TYPE . ID f_startclass { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 16


state 13

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones . MAIN ( ) { estatutos } END f_end ;
    (13) funciones -> funciones . funcion
    (15) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    MAIN            shift and go to state 17
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 14

    (21) vars -> vars DEF . tipo dimension : lista_id ;
    (22) vars -> vars DEF . ID f_varsobj : lista_id ;
    (37) tipo -> . NUMBER
    (38) tipo -> . STRING

    ID              shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 20

state 15

    (14) funciones -> empty .

    MAIN            reduce using rule 14 (funciones -> empty .)
    FUNC            reduce using rule 14 (funciones -> empty .)
    }               reduce using rule 14 (funciones -> empty .)


state 16

    (7) clase -> TYPE ID . f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (8) clase -> TYPE ID . f_startclass { cvars f_cvars funciones } f_endclass
    (9) f_startclass -> .

    :               reduce using rule 9 (f_startclass -> .)
    {               reduce using rule 9 (f_startclass -> .)

    f_startclass                   shift and go to state 24

state 17

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN . ( ) { estatutos } END f_end ;

    (               shift and go to state 25


state 18

    (13) funciones -> funciones funcion .

    MAIN            reduce using rule 13 (funciones -> funciones funcion .)
    FUNC            reduce using rule 13 (funciones -> funciones funcion .)
    }               reduce using rule 13 (funciones -> funciones funcion .)


state 19

    (15) funcion -> FUNC . ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC . ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    ID              shift and go to state 26


state 20

    (21) vars -> vars DEF tipo . dimension : lista_id ;
    (30) dimension -> . [ expresion f_dim1 ] f_onedim
    (31) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (32) dimension -> . empty
    (105) empty -> .

    [               shift and go to state 28
    :               reduce using rule 105 (empty -> .)

    dimension                      shift and go to state 27
    empty                          shift and go to state 29

state 21

    (22) vars -> vars DEF ID . f_varsobj : lista_id ;
    (24) f_varsobj -> .

    :               reduce using rule 24 (f_varsobj -> .)

    f_varsobj                      shift and go to state 30

state 22

    (37) tipo -> NUMBER .

    [               reduce using rule 37 (tipo -> NUMBER .)
    :               reduce using rule 37 (tipo -> NUMBER .)
    ID              reduce using rule 37 (tipo -> NUMBER .)
    {               reduce using rule 37 (tipo -> NUMBER .)


state 23

    (38) tipo -> STRING .

    [               reduce using rule 38 (tipo -> STRING .)
    :               reduce using rule 38 (tipo -> STRING .)
    ID              reduce using rule 38 (tipo -> STRING .)
    {               reduce using rule 38 (tipo -> STRING .)


state 24

    (7) clase -> TYPE ID f_startclass . : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (8) clase -> TYPE ID f_startclass . { cvars f_cvars funciones } f_endclass

    :               shift and go to state 31
    {               shift and go to state 32


state 25

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( . ) { estatutos } END f_end ;

    )               shift and go to state 33


state 26

    (15) funcion -> FUNC ID . f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID . f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (17) f_startfunc -> .

    (               reduce using rule 17 (f_startfunc -> .)

    f_startfunc                    shift and go to state 34

state 27

    (21) vars -> vars DEF tipo dimension . : lista_id ;

    :               shift and go to state 35


state 28

    (30) dimension -> [ . expresion f_dim1 ] f_onedim
    (31) dimension -> [ . expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 36
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 29

    (32) dimension -> empty .

    :               reduce using rule 32 (dimension -> empty .)
    OPFACT          reduce using rule 32 (dimension -> empty .)
    OPTERM          reduce using rule 32 (dimension -> empty .)
    COMP            reduce using rule 32 (dimension -> empty .)
    ]               reduce using rule 32 (dimension -> empty .)
    )               reduce using rule 32 (dimension -> empty .)
    =               reduce using rule 32 (dimension -> empty .)
    TO              reduce using rule 32 (dimension -> empty .)
    ,               reduce using rule 32 (dimension -> empty .)
    ;               reduce using rule 32 (dimension -> empty .)
    {               reduce using rule 32 (dimension -> empty .)
    &               reduce using rule 32 (dimension -> empty .)


state 30

    (22) vars -> vars DEF ID f_varsobj . : lista_id ;

    :               shift and go to state 46


state 31

    (7) clase -> TYPE ID f_startclass : . ID f_clasepadre { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 47


state 32

    (8) clase -> TYPE ID f_startclass { . cvars f_cvars funciones } f_endclass
    (25) cvars -> . cvars DEF tipo dimension : lista_id ;
    (26) cvars -> . empty
    (105) empty -> .

    DEF             reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    cvars                          shift and go to state 48
    empty                          shift and go to state 49

state 33

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) . { estatutos } END f_end ;

    {               shift and go to state 50


state 34

    (15) funcion -> FUNC ID f_startfunc . ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID f_startfunc . ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    (               shift and go to state 51


state 35

    (21) vars -> vars DEF tipo dimension : . lista_id ;
    (27) lista_id -> . ID f_vars
    (28) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 52

state 36

    (30) dimension -> [ expresion . f_dim1 ] f_onedim
    (31) dimension -> [ expresion . f_dim1 ] [ expresion f_dim2 ] f_twodim
    (72) expresion -> expresion . COMP f_oper exp f_expres
    (33) f_dim1 -> .

    COMP            shift and go to state 55
    ]               reduce using rule 33 (f_dim1 -> .)

    f_dim1                         shift and go to state 54

state 37

    (71) expresion -> exp .
    (75) exp -> exp . OPTERM f_oper term f_exp

    COMP            reduce using rule 71 (expresion -> exp .)
    ]               reduce using rule 71 (expresion -> exp .)
    )               reduce using rule 71 (expresion -> exp .)
    TO              reduce using rule 71 (expresion -> exp .)
    ,               reduce using rule 71 (expresion -> exp .)
    ;               reduce using rule 71 (expresion -> exp .)
    {               reduce using rule 71 (expresion -> exp .)
    OPTERM          shift and go to state 56


state 38

    (74) exp -> term .
    (78) term -> term . OPFACT f_oper fact f_term

    OPTERM          reduce using rule 74 (exp -> term .)
    COMP            reduce using rule 74 (exp -> term .)
    ]               reduce using rule 74 (exp -> term .)
    )               reduce using rule 74 (exp -> term .)
    TO              reduce using rule 74 (exp -> term .)
    ,               reduce using rule 74 (exp -> term .)
    ;               reduce using rule 74 (exp -> term .)
    {               reduce using rule 74 (exp -> term .)
    OPFACT          shift and go to state 57


state 39

    (84) fact -> OPTERM . NUM

    NUM             shift and go to state 58


state 40

    (77) term -> fact .

    OPFACT          reduce using rule 77 (term -> fact .)
    OPTERM          reduce using rule 77 (term -> fact .)
    COMP            reduce using rule 77 (term -> fact .)
    ]               reduce using rule 77 (term -> fact .)
    )               reduce using rule 77 (term -> fact .)
    TO              reduce using rule 77 (term -> fact .)
    ,               reduce using rule 77 (term -> fact .)
    ;               reduce using rule 77 (term -> fact .)
    {               reduce using rule 77 (term -> fact .)


state 41

    (81) fact -> ( . lparen expresion ) rparen
    (86) lparen -> .

    (               reduce using rule 86 (lparen -> .)
    NUM             reduce using rule 86 (lparen -> .)
    OPTERM          reduce using rule 86 (lparen -> .)
    CALL            reduce using rule 86 (lparen -> .)
    ID              reduce using rule 86 (lparen -> .)

    lparen                         shift and go to state 59

state 42

    (82) fact -> var .

    OPFACT          reduce using rule 82 (fact -> var .)
    OPTERM          reduce using rule 82 (fact -> var .)
    COMP            reduce using rule 82 (fact -> var .)
    ]               reduce using rule 82 (fact -> var .)
    )               reduce using rule 82 (fact -> var .)
    TO              reduce using rule 82 (fact -> var .)
    ,               reduce using rule 82 (fact -> var .)
    ;               reduce using rule 82 (fact -> var .)
    {               reduce using rule 82 (fact -> var .)


state 43

    (83) fact -> NUM . f_fact
    (88) f_fact -> .

    OPFACT          reduce using rule 88 (f_fact -> .)
    OPTERM          reduce using rule 88 (f_fact -> .)
    COMP            reduce using rule 88 (f_fact -> .)
    ]               reduce using rule 88 (f_fact -> .)
    )               reduce using rule 88 (f_fact -> .)
    TO              reduce using rule 88 (f_fact -> .)
    ,               reduce using rule 88 (f_fact -> .)
    ;               reduce using rule 88 (f_fact -> .)
    {               reduce using rule 88 (f_fact -> .)

    f_fact                         shift and go to state 60

state 44

    (85) fact -> CALL . call_func
    (51) call_func -> . func
    (52) call_func -> . input
    (53) call_func -> . write
    (54) call_func -> . to_num
    (55) call_func -> . to_str
    (56) call_func -> . return
    (57) func -> . ID f_verify_func ( args )
    (58) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (97) input -> . INPUT ( var )
    (98) write -> . PRINT ( write_list )
    (94) to_num -> . TO_NUMBER ( STR )
    (95) to_num -> . TO_NUMBER ( var )
    (96) to_str -> . TO_STRING ( expresion )
    (104) return -> . RET ( expresion )

    ID              shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    TO_NUMBER       shift and go to state 71
    TO_STRING       shift and go to state 72
    RET             shift and go to state 73

    call_func                      shift and go to state 61
    func                           shift and go to state 62
    input                          shift and go to state 63
    write                          shift and go to state 64
    to_num                         shift and go to state 65
    to_str                         shift and go to state 66
    return                         shift and go to state 67

state 45

    (66) var -> ID . f_varobj : ID f_verify_type_composite dimension
    (67) var -> ID . f_verify_type dimension
    (68) f_varobj -> .
    (69) f_verify_type -> .

    :               reduce using rule 68 (f_varobj -> .)
    [               reduce using rule 69 (f_verify_type -> .)
    OPFACT          reduce using rule 69 (f_verify_type -> .)
    OPTERM          reduce using rule 69 (f_verify_type -> .)
    COMP            reduce using rule 69 (f_verify_type -> .)
    ]               reduce using rule 69 (f_verify_type -> .)
    )               reduce using rule 69 (f_verify_type -> .)
    =               reduce using rule 69 (f_verify_type -> .)
    TO              reduce using rule 69 (f_verify_type -> .)
    ,               reduce using rule 69 (f_verify_type -> .)
    ;               reduce using rule 69 (f_verify_type -> .)
    {               reduce using rule 69 (f_verify_type -> .)
    &               reduce using rule 69 (f_verify_type -> .)

    f_varobj                       shift and go to state 74
    f_verify_type                  shift and go to state 75

state 46

    (22) vars -> vars DEF ID f_varsobj : . lista_id ;
    (27) lista_id -> . ID f_vars
    (28) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 76

state 47

    (7) clase -> TYPE ID f_startclass : ID . f_clasepadre { cvars f_cvars funciones } f_endclass
    (10) f_clasepadre -> .

    {               reduce using rule 10 (f_clasepadre -> .)

    f_clasepadre                   shift and go to state 77

state 48

    (8) clase -> TYPE ID f_startclass { cvars . f_cvars funciones } f_endclass
    (25) cvars -> cvars . DEF tipo dimension : lista_id ;
    (11) f_cvars -> .

    DEF             shift and go to state 79
    }               reduce using rule 11 (f_cvars -> .)
    FUNC            reduce using rule 11 (f_cvars -> .)

    f_cvars                        shift and go to state 78

state 49

    (26) cvars -> empty .

    DEF             reduce using rule 26 (cvars -> empty .)
    }               reduce using rule 26 (cvars -> empty .)
    FUNC            reduce using rule 26 (cvars -> empty .)


state 50

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { . estatutos } END f_end ;
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 80
    empty                          shift and go to state 81

state 51

    (15) funcion -> FUNC ID f_startfunc ( . params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID f_startfunc ( . params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (39) params -> . pparams
    (40) params -> . empty
    (41) pparams -> . tipo ID f_param
    (42) pparams -> . pparams , tipo ID f_param
    (105) empty -> .
    (37) tipo -> . NUMBER
    (38) tipo -> . STRING

    )               reduce using rule 105 (empty -> .)
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    params                         shift and go to state 82
    tipo                           shift and go to state 83
    pparams                        shift and go to state 84
    empty                          shift and go to state 85

state 52

    (21) vars -> vars DEF tipo dimension : lista_id . ;
    (28) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 86
    ,               shift and go to state 87


state 53

    (27) lista_id -> ID . f_vars
    (29) f_vars -> .

    ;               reduce using rule 29 (f_vars -> .)
    ,               reduce using rule 29 (f_vars -> .)

    f_vars                         shift and go to state 88

state 54

    (30) dimension -> [ expresion f_dim1 . ] f_onedim
    (31) dimension -> [ expresion f_dim1 . ] [ expresion f_dim2 ] f_twodim

    ]               shift and go to state 89


state 55

    (72) expresion -> expresion COMP . f_oper exp f_expres
    (80) f_oper -> .

    (               reduce using rule 80 (f_oper -> .)
    NUM             reduce using rule 80 (f_oper -> .)
    OPTERM          reduce using rule 80 (f_oper -> .)
    CALL            reduce using rule 80 (f_oper -> .)
    ID              reduce using rule 80 (f_oper -> .)

    f_oper                         shift and go to state 90

state 56

    (75) exp -> exp OPTERM . f_oper term f_exp
    (80) f_oper -> .

    (               reduce using rule 80 (f_oper -> .)
    NUM             reduce using rule 80 (f_oper -> .)
    OPTERM          reduce using rule 80 (f_oper -> .)
    CALL            reduce using rule 80 (f_oper -> .)
    ID              reduce using rule 80 (f_oper -> .)

    f_oper                         shift and go to state 91

state 57

    (78) term -> term OPFACT . f_oper fact f_term
    (80) f_oper -> .

    (               reduce using rule 80 (f_oper -> .)
    NUM             reduce using rule 80 (f_oper -> .)
    OPTERM          reduce using rule 80 (f_oper -> .)
    CALL            reduce using rule 80 (f_oper -> .)
    ID              reduce using rule 80 (f_oper -> .)

    f_oper                         shift and go to state 92

state 58

    (84) fact -> OPTERM NUM .

    OPFACT          reduce using rule 84 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 84 (fact -> OPTERM NUM .)
    COMP            reduce using rule 84 (fact -> OPTERM NUM .)
    ]               reduce using rule 84 (fact -> OPTERM NUM .)
    )               reduce using rule 84 (fact -> OPTERM NUM .)
    TO              reduce using rule 84 (fact -> OPTERM NUM .)
    ,               reduce using rule 84 (fact -> OPTERM NUM .)
    ;               reduce using rule 84 (fact -> OPTERM NUM .)
    {               reduce using rule 84 (fact -> OPTERM NUM .)


state 59

    (81) fact -> ( lparen . expresion ) rparen
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 93
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 60

    (83) fact -> NUM f_fact .

    OPFACT          reduce using rule 83 (fact -> NUM f_fact .)
    OPTERM          reduce using rule 83 (fact -> NUM f_fact .)
    COMP            reduce using rule 83 (fact -> NUM f_fact .)
    ]               reduce using rule 83 (fact -> NUM f_fact .)
    )               reduce using rule 83 (fact -> NUM f_fact .)
    TO              reduce using rule 83 (fact -> NUM f_fact .)
    ,               reduce using rule 83 (fact -> NUM f_fact .)
    ;               reduce using rule 83 (fact -> NUM f_fact .)
    {               reduce using rule 83 (fact -> NUM f_fact .)


state 61

    (85) fact -> CALL call_func .

    OPFACT          reduce using rule 85 (fact -> CALL call_func .)
    OPTERM          reduce using rule 85 (fact -> CALL call_func .)
    COMP            reduce using rule 85 (fact -> CALL call_func .)
    ]               reduce using rule 85 (fact -> CALL call_func .)
    )               reduce using rule 85 (fact -> CALL call_func .)
    TO              reduce using rule 85 (fact -> CALL call_func .)
    ,               reduce using rule 85 (fact -> CALL call_func .)
    ;               reduce using rule 85 (fact -> CALL call_func .)
    {               reduce using rule 85 (fact -> CALL call_func .)


state 62

    (51) call_func -> func .

    OPFACT          reduce using rule 51 (call_func -> func .)
    OPTERM          reduce using rule 51 (call_func -> func .)
    COMP            reduce using rule 51 (call_func -> func .)
    ]               reduce using rule 51 (call_func -> func .)
    )               reduce using rule 51 (call_func -> func .)
    TO              reduce using rule 51 (call_func -> func .)
    ,               reduce using rule 51 (call_func -> func .)
    ;               reduce using rule 51 (call_func -> func .)
    {               reduce using rule 51 (call_func -> func .)


state 63

    (52) call_func -> input .

    OPFACT          reduce using rule 52 (call_func -> input .)
    OPTERM          reduce using rule 52 (call_func -> input .)
    COMP            reduce using rule 52 (call_func -> input .)
    ]               reduce using rule 52 (call_func -> input .)
    )               reduce using rule 52 (call_func -> input .)
    TO              reduce using rule 52 (call_func -> input .)
    ,               reduce using rule 52 (call_func -> input .)
    ;               reduce using rule 52 (call_func -> input .)
    {               reduce using rule 52 (call_func -> input .)


state 64

    (53) call_func -> write .

    OPFACT          reduce using rule 53 (call_func -> write .)
    OPTERM          reduce using rule 53 (call_func -> write .)
    COMP            reduce using rule 53 (call_func -> write .)
    ]               reduce using rule 53 (call_func -> write .)
    )               reduce using rule 53 (call_func -> write .)
    TO              reduce using rule 53 (call_func -> write .)
    ,               reduce using rule 53 (call_func -> write .)
    ;               reduce using rule 53 (call_func -> write .)
    {               reduce using rule 53 (call_func -> write .)


state 65

    (54) call_func -> to_num .

    OPFACT          reduce using rule 54 (call_func -> to_num .)
    OPTERM          reduce using rule 54 (call_func -> to_num .)
    COMP            reduce using rule 54 (call_func -> to_num .)
    ]               reduce using rule 54 (call_func -> to_num .)
    )               reduce using rule 54 (call_func -> to_num .)
    TO              reduce using rule 54 (call_func -> to_num .)
    ,               reduce using rule 54 (call_func -> to_num .)
    ;               reduce using rule 54 (call_func -> to_num .)
    {               reduce using rule 54 (call_func -> to_num .)


state 66

    (55) call_func -> to_str .

    OPFACT          reduce using rule 55 (call_func -> to_str .)
    OPTERM          reduce using rule 55 (call_func -> to_str .)
    COMP            reduce using rule 55 (call_func -> to_str .)
    ]               reduce using rule 55 (call_func -> to_str .)
    )               reduce using rule 55 (call_func -> to_str .)
    TO              reduce using rule 55 (call_func -> to_str .)
    ,               reduce using rule 55 (call_func -> to_str .)
    ;               reduce using rule 55 (call_func -> to_str .)
    {               reduce using rule 55 (call_func -> to_str .)


state 67

    (56) call_func -> return .

    OPFACT          reduce using rule 56 (call_func -> return .)
    OPTERM          reduce using rule 56 (call_func -> return .)
    COMP            reduce using rule 56 (call_func -> return .)
    ]               reduce using rule 56 (call_func -> return .)
    )               reduce using rule 56 (call_func -> return .)
    TO              reduce using rule 56 (call_func -> return .)
    ,               reduce using rule 56 (call_func -> return .)
    ;               reduce using rule 56 (call_func -> return .)
    {               reduce using rule 56 (call_func -> return .)


state 68

    (57) func -> ID . f_verify_func ( args )
    (58) func -> ID . f_varobj : ID f_verify_func_composite ( args )
    (59) f_verify_func -> .
    (68) f_varobj -> .

    (               reduce using rule 59 (f_verify_func -> .)
    :               reduce using rule 68 (f_varobj -> .)

    f_verify_func                  shift and go to state 94
    f_varobj                       shift and go to state 95

state 69

    (97) input -> INPUT . ( var )

    (               shift and go to state 96


state 70

    (98) write -> PRINT . ( write_list )

    (               shift and go to state 97


state 71

    (94) to_num -> TO_NUMBER . ( STR )
    (95) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 98


state 72

    (96) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 99


state 73

    (104) return -> RET . ( expresion )

    (               shift and go to state 100


state 74

    (66) var -> ID f_varobj . : ID f_verify_type_composite dimension

    :               shift and go to state 101


state 75

    (67) var -> ID f_verify_type . dimension
    (30) dimension -> . [ expresion f_dim1 ] f_onedim
    (31) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (32) dimension -> . empty
    (105) empty -> .

    [               shift and go to state 28
    OPFACT          reduce using rule 105 (empty -> .)
    OPTERM          reduce using rule 105 (empty -> .)
    COMP            reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    =               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    {               reduce using rule 105 (empty -> .)
    &               reduce using rule 105 (empty -> .)

    dimension                      shift and go to state 102
    empty                          shift and go to state 29

state 76

    (22) vars -> vars DEF ID f_varsobj : lista_id . ;
    (28) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 103
    ,               shift and go to state 87


state 77

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre . { cvars f_cvars funciones } f_endclass

    {               shift and go to state 104


state 78

    (8) clase -> TYPE ID f_startclass { cvars f_cvars . funciones } f_endclass
    (13) funciones -> . funciones funcion
    (14) funciones -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    funciones                      shift and go to state 105
    empty                          shift and go to state 15

state 79

    (25) cvars -> cvars DEF . tipo dimension : lista_id ;
    (37) tipo -> . NUMBER
    (38) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 106

state 80

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos . } END f_end ;
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 107
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 81

    (45) estatutos -> empty .

    }               reduce using rule 45 (estatutos -> empty .)
    CALL            reduce using rule 45 (estatutos -> empty .)
    WHILE           reduce using rule 45 (estatutos -> empty .)
    FOR             reduce using rule 45 (estatutos -> empty .)
    IF              reduce using rule 45 (estatutos -> empty .)
    ID              reduce using rule 45 (estatutos -> empty .)


state 82

    (15) funcion -> FUNC ID f_startfunc ( params . ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID f_startfunc ( params . ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    )               shift and go to state 118


state 83

    (41) pparams -> tipo . ID f_param

    ID              shift and go to state 119


state 84

    (39) params -> pparams .
    (42) pparams -> pparams . , tipo ID f_param

    )               reduce using rule 39 (params -> pparams .)
    ,               shift and go to state 120


state 85

    (40) params -> empty .

    )               reduce using rule 40 (params -> empty .)


state 86

    (21) vars -> vars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    MAIN            reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    CALL            reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    WHILE           reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    FOR             reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    IF              reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)
    ID              reduce using rule 21 (vars -> vars DEF tipo dimension : lista_id ; .)


state 87

    (28) lista_id -> lista_id , . ID f_vars

    ID              shift and go to state 121


state 88

    (27) lista_id -> ID f_vars .

    ;               reduce using rule 27 (lista_id -> ID f_vars .)
    ,               reduce using rule 27 (lista_id -> ID f_vars .)


state 89

    (30) dimension -> [ expresion f_dim1 ] . f_onedim
    (31) dimension -> [ expresion f_dim1 ] . [ expresion f_dim2 ] f_twodim
    (35) f_onedim -> .

    [               shift and go to state 122
    :               reduce using rule 35 (f_onedim -> .)
    OPFACT          reduce using rule 35 (f_onedim -> .)
    OPTERM          reduce using rule 35 (f_onedim -> .)
    COMP            reduce using rule 35 (f_onedim -> .)
    ]               reduce using rule 35 (f_onedim -> .)
    )               reduce using rule 35 (f_onedim -> .)
    =               reduce using rule 35 (f_onedim -> .)
    TO              reduce using rule 35 (f_onedim -> .)
    ,               reduce using rule 35 (f_onedim -> .)
    ;               reduce using rule 35 (f_onedim -> .)
    {               reduce using rule 35 (f_onedim -> .)
    &               reduce using rule 35 (f_onedim -> .)

    f_onedim                       shift and go to state 123

state 90

    (72) expresion -> expresion COMP f_oper . exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    exp                            shift and go to state 124
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 91

    (75) exp -> exp OPTERM f_oper . term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    term                           shift and go to state 125
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 92

    (78) term -> term OPFACT f_oper . fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    fact                           shift and go to state 126
    var                            shift and go to state 42

state 93

    (81) fact -> ( lparen expresion . ) rparen
    (72) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 127
    COMP            shift and go to state 55


state 94

    (57) func -> ID f_verify_func . ( args )

    (               shift and go to state 128


state 95

    (58) func -> ID f_varobj . : ID f_verify_func_composite ( args )

    :               shift and go to state 129


state 96

    (97) input -> INPUT ( . var )
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    ID              shift and go to state 45

    var                            shift and go to state 130

state 97

    (98) write -> PRINT ( . write_list )
    (99) write_list -> . write_list & write_listp
    (100) write_list -> . write_listp
    (101) write_listp -> . STR
    (102) write_listp -> . var
    (103) write_listp -> . CALL to_str
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    STR             shift and go to state 133
    CALL            shift and go to state 135
    ID              shift and go to state 45

    write_list                     shift and go to state 131
    write_listp                    shift and go to state 132
    var                            shift and go to state 134

state 98

    (94) to_num -> TO_NUMBER ( . STR )
    (95) to_num -> TO_NUMBER ( . var )
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    STR             shift and go to state 136
    ID              shift and go to state 45

    var                            shift and go to state 137

state 99

    (96) to_str -> TO_STRING ( . expresion )
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 138
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 100

    (104) return -> RET ( . expresion )
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 139
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 101

    (66) var -> ID f_varobj : . ID f_verify_type_composite dimension

    ID              shift and go to state 140


state 102

    (67) var -> ID f_verify_type dimension .

    OPFACT          reduce using rule 67 (var -> ID f_verify_type dimension .)
    OPTERM          reduce using rule 67 (var -> ID f_verify_type dimension .)
    COMP            reduce using rule 67 (var -> ID f_verify_type dimension .)
    ]               reduce using rule 67 (var -> ID f_verify_type dimension .)
    )               reduce using rule 67 (var -> ID f_verify_type dimension .)
    =               reduce using rule 67 (var -> ID f_verify_type dimension .)
    TO              reduce using rule 67 (var -> ID f_verify_type dimension .)
    ,               reduce using rule 67 (var -> ID f_verify_type dimension .)
    ;               reduce using rule 67 (var -> ID f_verify_type dimension .)
    {               reduce using rule 67 (var -> ID f_verify_type dimension .)
    &               reduce using rule 67 (var -> ID f_verify_type dimension .)


state 103

    (22) vars -> vars DEF ID f_varsobj : lista_id ; .

    DEF             reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    MAIN            reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FUNC            reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    }               reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    CALL            reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    WHILE           reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    FOR             reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    IF              reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)
    ID              reduce using rule 22 (vars -> vars DEF ID f_varsobj : lista_id ; .)


state 104

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { . cvars f_cvars funciones } f_endclass
    (25) cvars -> . cvars DEF tipo dimension : lista_id ;
    (26) cvars -> . empty
    (105) empty -> .

    DEF             reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    cvars                          shift and go to state 141
    empty                          shift and go to state 49

state 105

    (8) clase -> TYPE ID f_startclass { cvars f_cvars funciones . } f_endclass
    (13) funciones -> funciones . funcion
    (15) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 142
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 106

    (25) cvars -> cvars DEF tipo . dimension : lista_id ;
    (30) dimension -> . [ expresion f_dim1 ] f_onedim
    (31) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (32) dimension -> . empty
    (105) empty -> .

    [               shift and go to state 28
    :               reduce using rule 105 (empty -> .)

    dimension                      shift and go to state 143
    empty                          shift and go to state 29

state 107

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } . END f_end ;

    END             shift and go to state 144


state 108

    (44) estatutos -> estatutos estatuto .

    }               reduce using rule 44 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 44 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 44 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 44 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 44 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 44 (estatutos -> estatutos estatuto .)


state 109

    (46) estatuto -> asignacion .

    }               reduce using rule 46 (estatuto -> asignacion .)
    CALL            reduce using rule 46 (estatuto -> asignacion .)
    WHILE           reduce using rule 46 (estatuto -> asignacion .)
    FOR             reduce using rule 46 (estatuto -> asignacion .)
    IF              reduce using rule 46 (estatuto -> asignacion .)
    ID              reduce using rule 46 (estatuto -> asignacion .)


state 110

    (47) estatuto -> while .

    }               reduce using rule 47 (estatuto -> while .)
    CALL            reduce using rule 47 (estatuto -> while .)
    WHILE           reduce using rule 47 (estatuto -> while .)
    FOR             reduce using rule 47 (estatuto -> while .)
    IF              reduce using rule 47 (estatuto -> while .)
    ID              reduce using rule 47 (estatuto -> while .)


state 111

    (48) estatuto -> for .

    }               reduce using rule 48 (estatuto -> for .)
    CALL            reduce using rule 48 (estatuto -> for .)
    WHILE           reduce using rule 48 (estatuto -> for .)
    FOR             reduce using rule 48 (estatuto -> for .)
    IF              reduce using rule 48 (estatuto -> for .)
    ID              reduce using rule 48 (estatuto -> for .)


state 112

    (49) estatuto -> condicion .

    }               reduce using rule 49 (estatuto -> condicion .)
    CALL            reduce using rule 49 (estatuto -> condicion .)
    WHILE           reduce using rule 49 (estatuto -> condicion .)
    FOR             reduce using rule 49 (estatuto -> condicion .)
    IF              reduce using rule 49 (estatuto -> condicion .)
    ID              reduce using rule 49 (estatuto -> condicion .)


state 113

    (50) estatuto -> CALL . call_func ;
    (51) call_func -> . func
    (52) call_func -> . input
    (53) call_func -> . write
    (54) call_func -> . to_num
    (55) call_func -> . to_str
    (56) call_func -> . return
    (57) func -> . ID f_verify_func ( args )
    (58) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (97) input -> . INPUT ( var )
    (98) write -> . PRINT ( write_list )
    (94) to_num -> . TO_NUMBER ( STR )
    (95) to_num -> . TO_NUMBER ( var )
    (96) to_str -> . TO_STRING ( expresion )
    (104) return -> . RET ( expresion )

    ID              shift and go to state 68
    INPUT           shift and go to state 69
    PRINT           shift and go to state 70
    TO_NUMBER       shift and go to state 71
    TO_STRING       shift and go to state 72
    RET             shift and go to state 73

    call_func                      shift and go to state 145
    func                           shift and go to state 62
    input                          shift and go to state 63
    write                          shift and go to state 64
    to_num                         shift and go to state 65
    to_str                         shift and go to state 66
    return                         shift and go to state 67

state 114

    (65) asignacion -> var . = f_oper expresion ;

    =               shift and go to state 146


state 115

    (92) while -> WHILE . ( expresion ) DO { estatutos }

    (               shift and go to state 147


state 116

    (93) for -> FOR . expresion TO expresion { estatutos }
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 148
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 117

    (89) condicion -> IF . ( expresion ) THEN { estatutos } condicionp

    (               shift and go to state 149


state 118

    (15) funcion -> FUNC ID f_startfunc ( params ) . : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID f_startfunc ( params ) . : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    :               shift and go to state 150


state 119

    (41) pparams -> tipo ID . f_param
    (43) f_param -> .

    ,               reduce using rule 43 (f_param -> .)
    )               reduce using rule 43 (f_param -> .)

    f_param                        shift and go to state 151

state 120

    (42) pparams -> pparams , . tipo ID f_param
    (37) tipo -> . NUMBER
    (38) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 152

state 121

    (28) lista_id -> lista_id , ID . f_vars
    (29) f_vars -> .

    ;               reduce using rule 29 (f_vars -> .)
    ,               reduce using rule 29 (f_vars -> .)

    f_vars                         shift and go to state 153

state 122

    (31) dimension -> [ expresion f_dim1 ] [ . expresion f_dim2 ] f_twodim
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 154
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 123

    (30) dimension -> [ expresion f_dim1 ] f_onedim .

    :               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    OPFACT          reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    OPTERM          reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    COMP            reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ]               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    )               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    =               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    TO              reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ,               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    ;               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    {               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)
    &               reduce using rule 30 (dimension -> [ expresion f_dim1 ] f_onedim .)


state 124

    (72) expresion -> expresion COMP f_oper exp . f_expres
    (75) exp -> exp . OPTERM f_oper term f_exp
    (73) f_expres -> .

    OPTERM          shift and go to state 56
    COMP            reduce using rule 73 (f_expres -> .)
    ]               reduce using rule 73 (f_expres -> .)
    )               reduce using rule 73 (f_expres -> .)
    TO              reduce using rule 73 (f_expres -> .)
    ,               reduce using rule 73 (f_expres -> .)
    ;               reduce using rule 73 (f_expres -> .)
    {               reduce using rule 73 (f_expres -> .)

    f_expres                       shift and go to state 155

state 125

    (75) exp -> exp OPTERM f_oper term . f_exp
    (78) term -> term . OPFACT f_oper fact f_term
    (76) f_exp -> .

    OPFACT          shift and go to state 57
    OPTERM          reduce using rule 76 (f_exp -> .)
    COMP            reduce using rule 76 (f_exp -> .)
    ]               reduce using rule 76 (f_exp -> .)
    )               reduce using rule 76 (f_exp -> .)
    TO              reduce using rule 76 (f_exp -> .)
    ,               reduce using rule 76 (f_exp -> .)
    ;               reduce using rule 76 (f_exp -> .)
    {               reduce using rule 76 (f_exp -> .)

    f_exp                          shift and go to state 156

state 126

    (78) term -> term OPFACT f_oper fact . f_term
    (79) f_term -> .

    OPFACT          reduce using rule 79 (f_term -> .)
    OPTERM          reduce using rule 79 (f_term -> .)
    COMP            reduce using rule 79 (f_term -> .)
    ]               reduce using rule 79 (f_term -> .)
    )               reduce using rule 79 (f_term -> .)
    TO              reduce using rule 79 (f_term -> .)
    ,               reduce using rule 79 (f_term -> .)
    ;               reduce using rule 79 (f_term -> .)
    {               reduce using rule 79 (f_term -> .)

    f_term                         shift and go to state 157

state 127

    (81) fact -> ( lparen expresion ) . rparen
    (87) rparen -> .

    OPFACT          reduce using rule 87 (rparen -> .)
    OPTERM          reduce using rule 87 (rparen -> .)
    COMP            reduce using rule 87 (rparen -> .)
    ]               reduce using rule 87 (rparen -> .)
    )               reduce using rule 87 (rparen -> .)
    TO              reduce using rule 87 (rparen -> .)
    ,               reduce using rule 87 (rparen -> .)
    ;               reduce using rule 87 (rparen -> .)
    {               reduce using rule 87 (rparen -> .)

    rparen                         shift and go to state 158

state 128

    (57) func -> ID f_verify_func ( . args )
    (61) args -> . args_list
    (62) args -> . empty
    (63) args_list -> . expresion
    (64) args_list -> . args_list , expresion
    (105) empty -> .
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    )               reduce using rule 105 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 159
    args_list                      shift and go to state 160
    empty                          shift and go to state 161
    expresion                      shift and go to state 162
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 129

    (58) func -> ID f_varobj : . ID f_verify_func_composite ( args )

    ID              shift and go to state 163


state 130

    (97) input -> INPUT ( var . )

    )               shift and go to state 164


state 131

    (98) write -> PRINT ( write_list . )
    (99) write_list -> write_list . & write_listp

    )               shift and go to state 165
    &               shift and go to state 166


state 132

    (100) write_list -> write_listp .

    )               reduce using rule 100 (write_list -> write_listp .)
    &               reduce using rule 100 (write_list -> write_listp .)


state 133

    (101) write_listp -> STR .

    )               reduce using rule 101 (write_listp -> STR .)
    &               reduce using rule 101 (write_listp -> STR .)


state 134

    (102) write_listp -> var .

    )               reduce using rule 102 (write_listp -> var .)
    &               reduce using rule 102 (write_listp -> var .)


state 135

    (103) write_listp -> CALL . to_str
    (96) to_str -> . TO_STRING ( expresion )

    TO_STRING       shift and go to state 72

    to_str                         shift and go to state 167

state 136

    (94) to_num -> TO_NUMBER ( STR . )

    )               shift and go to state 168


state 137

    (95) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 169


state 138

    (96) to_str -> TO_STRING ( expresion . )
    (72) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 170
    COMP            shift and go to state 55


state 139

    (104) return -> RET ( expresion . )
    (72) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 171
    COMP            shift and go to state 55


state 140

    (66) var -> ID f_varobj : ID . f_verify_type_composite dimension
    (70) f_verify_type_composite -> .

    [               reduce using rule 70 (f_verify_type_composite -> .)
    OPFACT          reduce using rule 70 (f_verify_type_composite -> .)
    OPTERM          reduce using rule 70 (f_verify_type_composite -> .)
    COMP            reduce using rule 70 (f_verify_type_composite -> .)
    ]               reduce using rule 70 (f_verify_type_composite -> .)
    )               reduce using rule 70 (f_verify_type_composite -> .)
    =               reduce using rule 70 (f_verify_type_composite -> .)
    TO              reduce using rule 70 (f_verify_type_composite -> .)
    ,               reduce using rule 70 (f_verify_type_composite -> .)
    ;               reduce using rule 70 (f_verify_type_composite -> .)
    {               reduce using rule 70 (f_verify_type_composite -> .)
    &               reduce using rule 70 (f_verify_type_composite -> .)

    f_verify_type_composite        shift and go to state 172

state 141

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars . f_cvars funciones } f_endclass
    (25) cvars -> cvars . DEF tipo dimension : lista_id ;
    (11) f_cvars -> .

    DEF             shift and go to state 79
    }               reduce using rule 11 (f_cvars -> .)
    FUNC            reduce using rule 11 (f_cvars -> .)

    f_cvars                        shift and go to state 173

state 142

    (8) clase -> TYPE ID f_startclass { cvars f_cvars funciones } . f_endclass
    (12) f_endclass -> .

    TYPE            reduce using rule 12 (f_endclass -> .)
    DEF             reduce using rule 12 (f_endclass -> .)
    MAIN            reduce using rule 12 (f_endclass -> .)
    FUNC            reduce using rule 12 (f_endclass -> .)

    f_endclass                     shift and go to state 174

state 143

    (25) cvars -> cvars DEF tipo dimension . : lista_id ;

    :               shift and go to state 175


state 144

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END . f_end ;
    (4) f_end -> .

    ;               reduce using rule 4 (f_end -> .)

    f_end                          shift and go to state 176

state 145

    (50) estatuto -> CALL call_func . ;

    ;               shift and go to state 177


state 146

    (65) asignacion -> var = . f_oper expresion ;
    (80) f_oper -> .

    (               reduce using rule 80 (f_oper -> .)
    NUM             reduce using rule 80 (f_oper -> .)
    OPTERM          reduce using rule 80 (f_oper -> .)
    CALL            reduce using rule 80 (f_oper -> .)
    ID              reduce using rule 80 (f_oper -> .)

    f_oper                         shift and go to state 178

state 147

    (92) while -> WHILE ( . expresion ) DO { estatutos }
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 179
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 148

    (93) for -> FOR expresion . TO expresion { estatutos }
    (72) expresion -> expresion . COMP f_oper exp f_expres

    TO              shift and go to state 180
    COMP            shift and go to state 55


state 149

    (89) condicion -> IF ( . expresion ) THEN { estatutos } condicionp
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 181
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 150

    (15) funcion -> FUNC ID f_startfunc ( params ) : . tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> FUNC ID f_startfunc ( params ) : . NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (37) tipo -> . NUMBER
    (38) tipo -> . STRING

    NOTHING         shift and go to state 183
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 182

state 151

    (41) pparams -> tipo ID f_param .

    ,               reduce using rule 41 (pparams -> tipo ID f_param .)
    )               reduce using rule 41 (pparams -> tipo ID f_param .)


state 152

    (42) pparams -> pparams , tipo . ID f_param

    ID              shift and go to state 184


state 153

    (28) lista_id -> lista_id , ID f_vars .

    ;               reduce using rule 28 (lista_id -> lista_id , ID f_vars .)
    ,               reduce using rule 28 (lista_id -> lista_id , ID f_vars .)


state 154

    (31) dimension -> [ expresion f_dim1 ] [ expresion . f_dim2 ] f_twodim
    (72) expresion -> expresion . COMP f_oper exp f_expres
    (34) f_dim2 -> .

    COMP            shift and go to state 55
    ]               reduce using rule 34 (f_dim2 -> .)

    f_dim2                         shift and go to state 185

state 155

    (72) expresion -> expresion COMP f_oper exp f_expres .

    COMP            reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    ]               reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    )               reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    TO              reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    ,               reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    ;               reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)
    {               reduce using rule 72 (expresion -> expresion COMP f_oper exp f_expres .)


state 156

    (75) exp -> exp OPTERM f_oper term f_exp .

    OPTERM          reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    COMP            reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    ]               reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    )               reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    TO              reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    ,               reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    ;               reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)
    {               reduce using rule 75 (exp -> exp OPTERM f_oper term f_exp .)


state 157

    (78) term -> term OPFACT f_oper fact f_term .

    OPFACT          reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    OPTERM          reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    COMP            reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    ]               reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    )               reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    TO              reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    ,               reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    ;               reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)
    {               reduce using rule 78 (term -> term OPFACT f_oper fact f_term .)


state 158

    (81) fact -> ( lparen expresion ) rparen .

    OPFACT          reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    OPTERM          reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    COMP            reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    ]               reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    )               reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    TO              reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    ,               reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    ;               reduce using rule 81 (fact -> ( lparen expresion ) rparen .)
    {               reduce using rule 81 (fact -> ( lparen expresion ) rparen .)


state 159

    (57) func -> ID f_verify_func ( args . )

    )               shift and go to state 186


state 160

    (61) args -> args_list .
    (64) args_list -> args_list . , expresion

    )               reduce using rule 61 (args -> args_list .)
    ,               shift and go to state 187


state 161

    (62) args -> empty .

    )               reduce using rule 62 (args -> empty .)


state 162

    (63) args_list -> expresion .
    (72) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 63 (args_list -> expresion .)
    )               reduce using rule 63 (args_list -> expresion .)
    COMP            shift and go to state 55


state 163

    (58) func -> ID f_varobj : ID . f_verify_func_composite ( args )
    (60) f_verify_func_composite -> .

    (               reduce using rule 60 (f_verify_func_composite -> .)

    f_verify_func_composite        shift and go to state 188

state 164

    (97) input -> INPUT ( var ) .

    OPFACT          reduce using rule 97 (input -> INPUT ( var ) .)
    OPTERM          reduce using rule 97 (input -> INPUT ( var ) .)
    COMP            reduce using rule 97 (input -> INPUT ( var ) .)
    ]               reduce using rule 97 (input -> INPUT ( var ) .)
    )               reduce using rule 97 (input -> INPUT ( var ) .)
    TO              reduce using rule 97 (input -> INPUT ( var ) .)
    ,               reduce using rule 97 (input -> INPUT ( var ) .)
    ;               reduce using rule 97 (input -> INPUT ( var ) .)
    {               reduce using rule 97 (input -> INPUT ( var ) .)


state 165

    (98) write -> PRINT ( write_list ) .

    OPFACT          reduce using rule 98 (write -> PRINT ( write_list ) .)
    OPTERM          reduce using rule 98 (write -> PRINT ( write_list ) .)
    COMP            reduce using rule 98 (write -> PRINT ( write_list ) .)
    ]               reduce using rule 98 (write -> PRINT ( write_list ) .)
    )               reduce using rule 98 (write -> PRINT ( write_list ) .)
    TO              reduce using rule 98 (write -> PRINT ( write_list ) .)
    ,               reduce using rule 98 (write -> PRINT ( write_list ) .)
    ;               reduce using rule 98 (write -> PRINT ( write_list ) .)
    {               reduce using rule 98 (write -> PRINT ( write_list ) .)


state 166

    (99) write_list -> write_list & . write_listp
    (101) write_listp -> . STR
    (102) write_listp -> . var
    (103) write_listp -> . CALL to_str
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    STR             shift and go to state 133
    CALL            shift and go to state 135
    ID              shift and go to state 45

    write_listp                    shift and go to state 189
    var                            shift and go to state 134

state 167

    (103) write_listp -> CALL to_str .

    )               reduce using rule 103 (write_listp -> CALL to_str .)
    &               reduce using rule 103 (write_listp -> CALL to_str .)


state 168

    (94) to_num -> TO_NUMBER ( STR ) .

    OPFACT          reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    OPTERM          reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    COMP            reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    ]               reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    )               reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    TO              reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    ,               reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    ;               reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)
    {               reduce using rule 94 (to_num -> TO_NUMBER ( STR ) .)


state 169

    (95) to_num -> TO_NUMBER ( var ) .

    OPFACT          reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    ;               reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 95 (to_num -> TO_NUMBER ( var ) .)


state 170

    (96) to_str -> TO_STRING ( expresion ) .

    OPFACT          reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    ;               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)
    &               reduce using rule 96 (to_str -> TO_STRING ( expresion ) .)


state 171

    (104) return -> RET ( expresion ) .

    OPFACT          reduce using rule 104 (return -> RET ( expresion ) .)
    OPTERM          reduce using rule 104 (return -> RET ( expresion ) .)
    COMP            reduce using rule 104 (return -> RET ( expresion ) .)
    ]               reduce using rule 104 (return -> RET ( expresion ) .)
    )               reduce using rule 104 (return -> RET ( expresion ) .)
    TO              reduce using rule 104 (return -> RET ( expresion ) .)
    ,               reduce using rule 104 (return -> RET ( expresion ) .)
    ;               reduce using rule 104 (return -> RET ( expresion ) .)
    {               reduce using rule 104 (return -> RET ( expresion ) .)


state 172

    (66) var -> ID f_varobj : ID f_verify_type_composite . dimension
    (30) dimension -> . [ expresion f_dim1 ] f_onedim
    (31) dimension -> . [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim
    (32) dimension -> . empty
    (105) empty -> .

    [               shift and go to state 28
    OPFACT          reduce using rule 105 (empty -> .)
    OPTERM          reduce using rule 105 (empty -> .)
    COMP            reduce using rule 105 (empty -> .)
    ]               reduce using rule 105 (empty -> .)
    )               reduce using rule 105 (empty -> .)
    =               reduce using rule 105 (empty -> .)
    TO              reduce using rule 105 (empty -> .)
    ,               reduce using rule 105 (empty -> .)
    ;               reduce using rule 105 (empty -> .)
    {               reduce using rule 105 (empty -> .)
    &               reduce using rule 105 (empty -> .)

    dimension                      shift and go to state 190
    empty                          shift and go to state 29

state 173

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars . funciones } f_endclass
    (13) funciones -> . funciones funcion
    (14) funciones -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    FUNC            reduce using rule 105 (empty -> .)

    funciones                      shift and go to state 191
    empty                          shift and go to state 15

state 174

    (8) clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 8 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 8 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 8 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 8 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)


state 175

    (25) cvars -> cvars DEF tipo dimension : . lista_id ;
    (27) lista_id -> . ID f_vars
    (28) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 53

    lista_id                       shift and go to state 192

state 176

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end . ;

    ;               shift and go to state 193


state 177

    (50) estatuto -> CALL call_func ; .

    }               reduce using rule 50 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 50 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 50 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 50 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 50 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 50 (estatuto -> CALL call_func ; .)


state 178

    (65) asignacion -> var = f_oper . expresion ;
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    var                            shift and go to state 42
    expresion                      shift and go to state 194
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40

state 179

    (92) while -> WHILE ( expresion . ) DO { estatutos }
    (72) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 195
    COMP            shift and go to state 55


state 180

    (93) for -> FOR expresion TO . expresion { estatutos }
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 196
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 181

    (89) condicion -> IF ( expresion . ) THEN { estatutos } condicionp
    (72) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 197
    COMP            shift and go to state 55


state 182

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo . f_tipofunc { vars estatutos } f_endfunc
    (19) f_tipofunc -> .

    {               reduce using rule 19 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 198

state 183

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING . f_nothing f_tipofunc { vars estatutos } f_endfunc
    (18) f_nothing -> .

    {               reduce using rule 18 (f_nothing -> .)

    f_nothing                      shift and go to state 199

state 184

    (42) pparams -> pparams , tipo ID . f_param
    (43) f_param -> .

    ,               reduce using rule 43 (f_param -> .)
    )               reduce using rule 43 (f_param -> .)

    f_param                        shift and go to state 200

state 185

    (31) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 . ] f_twodim

    ]               shift and go to state 201


state 186

    (57) func -> ID f_verify_func ( args ) .

    OPFACT          reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    OPTERM          reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    COMP            reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    ]               reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    )               reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    TO              reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    ,               reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    ;               reduce using rule 57 (func -> ID f_verify_func ( args ) .)
    {               reduce using rule 57 (func -> ID f_verify_func ( args ) .)


state 187

    (64) args_list -> args_list , . expresion
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    expresion                      shift and go to state 202
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 188

    (58) func -> ID f_varobj : ID f_verify_func_composite . ( args )

    (               shift and go to state 203


state 189

    (99) write_list -> write_list & write_listp .

    )               reduce using rule 99 (write_list -> write_list & write_listp .)
    &               reduce using rule 99 (write_list -> write_list & write_listp .)


state 190

    (66) var -> ID f_varobj : ID f_verify_type_composite dimension .

    OPFACT          reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    OPTERM          reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    COMP            reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ]               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    )               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    =               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    TO              reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ,               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    ;               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    {               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)
    &               reduce using rule 66 (var -> ID f_varobj : ID f_verify_type_composite dimension .)


state 191

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones . } f_endclass
    (13) funciones -> funciones . funcion
    (15) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (16) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 204
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 192

    (25) cvars -> cvars DEF tipo dimension : lista_id . ;
    (28) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 205
    ,               shift and go to state 87


state 193

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ; .

    $end            reduce using rule 1 (start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN ( ) { estatutos } END f_end ; .)


state 194

    (65) asignacion -> var = f_oper expresion . ;
    (72) expresion -> expresion . COMP f_oper exp f_expres

    ;               shift and go to state 206
    COMP            shift and go to state 55


state 195

    (92) while -> WHILE ( expresion ) . DO { estatutos }

    DO              shift and go to state 207


state 196

    (93) for -> FOR expresion TO expresion . { estatutos }
    (72) expresion -> expresion . COMP f_oper exp f_expres

    {               shift and go to state 208
    COMP            shift and go to state 55


state 197

    (89) condicion -> IF ( expresion ) . THEN { estatutos } condicionp

    THEN            shift and go to state 209


state 198

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 210


state 199

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing . f_tipofunc { vars estatutos } f_endfunc
    (19) f_tipofunc -> .

    {               reduce using rule 19 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 211

state 200

    (42) pparams -> pparams , tipo ID f_param .

    ,               reduce using rule 42 (pparams -> pparams , tipo ID f_param .)
    )               reduce using rule 42 (pparams -> pparams , tipo ID f_param .)


state 201

    (31) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] . f_twodim
    (36) f_twodim -> .

    :               reduce using rule 36 (f_twodim -> .)
    OPFACT          reduce using rule 36 (f_twodim -> .)
    OPTERM          reduce using rule 36 (f_twodim -> .)
    COMP            reduce using rule 36 (f_twodim -> .)
    ]               reduce using rule 36 (f_twodim -> .)
    )               reduce using rule 36 (f_twodim -> .)
    =               reduce using rule 36 (f_twodim -> .)
    TO              reduce using rule 36 (f_twodim -> .)
    ,               reduce using rule 36 (f_twodim -> .)
    ;               reduce using rule 36 (f_twodim -> .)
    {               reduce using rule 36 (f_twodim -> .)
    &               reduce using rule 36 (f_twodim -> .)

    f_twodim                       shift and go to state 212

state 202

    (64) args_list -> args_list , expresion .
    (72) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 64 (args_list -> args_list , expresion .)
    )               reduce using rule 64 (args_list -> args_list , expresion .)
    COMP            shift and go to state 55


state 203

    (58) func -> ID f_varobj : ID f_verify_func_composite ( . args )
    (61) args -> . args_list
    (62) args -> . empty
    (63) args_list -> . expresion
    (64) args_list -> . args_list , expresion
    (105) empty -> .
    (71) expresion -> . exp
    (72) expresion -> . expresion COMP f_oper exp f_expres
    (74) exp -> . term
    (75) exp -> . exp OPTERM f_oper term f_exp
    (77) term -> . fact
    (78) term -> . term OPFACT f_oper fact f_term
    (81) fact -> . ( lparen expresion ) rparen
    (82) fact -> . var
    (83) fact -> . NUM f_fact
    (84) fact -> . OPTERM NUM
    (85) fact -> . CALL call_func
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    )               reduce using rule 105 (empty -> .)
    (               shift and go to state 41
    NUM             shift and go to state 43
    OPTERM          shift and go to state 39
    CALL            shift and go to state 44
    ID              shift and go to state 45

    args                           shift and go to state 213
    args_list                      shift and go to state 160
    empty                          shift and go to state 161
    expresion                      shift and go to state 162
    exp                            shift and go to state 37
    term                           shift and go to state 38
    fact                           shift and go to state 40
    var                            shift and go to state 42

state 204

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } . f_endclass
    (12) f_endclass -> .

    TYPE            reduce using rule 12 (f_endclass -> .)
    DEF             reduce using rule 12 (f_endclass -> .)
    MAIN            reduce using rule 12 (f_endclass -> .)
    FUNC            reduce using rule 12 (f_endclass -> .)

    f_endclass                     shift and go to state 214

state 205

    (25) cvars -> cvars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 25 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 25 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 25 (cvars -> cvars DEF tipo dimension : lista_id ; .)


state 206

    (65) asignacion -> var = f_oper expresion ; .

    }               reduce using rule 65 (asignacion -> var = f_oper expresion ; .)
    CALL            reduce using rule 65 (asignacion -> var = f_oper expresion ; .)
    WHILE           reduce using rule 65 (asignacion -> var = f_oper expresion ; .)
    FOR             reduce using rule 65 (asignacion -> var = f_oper expresion ; .)
    IF              reduce using rule 65 (asignacion -> var = f_oper expresion ; .)
    ID              reduce using rule 65 (asignacion -> var = f_oper expresion ; .)


state 207

    (92) while -> WHILE ( expresion ) DO . { estatutos }

    {               shift and go to state 215


state 208

    (93) for -> FOR expresion TO expresion { . estatutos }
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 216
    empty                          shift and go to state 81

state 209

    (89) condicion -> IF ( expresion ) THEN . { estatutos } condicionp

    {               shift and go to state 217


state 210

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { . vars estatutos } f_endfunc
    (21) vars -> . vars DEF tipo dimension : lista_id ;
    (22) vars -> . vars DEF ID f_varsobj : lista_id ;
    (23) vars -> . empty
    (105) empty -> .

    DEF             reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    vars                           shift and go to state 218
    empty                          shift and go to state 11

state 211

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 219


state 212

    (31) dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .

    :               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    OPFACT          reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    OPTERM          reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    COMP            reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ]               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    )               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    =               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    TO              reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ,               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    ;               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    {               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)
    &               reduce using rule 31 (dimension -> [ expresion f_dim1 ] [ expresion f_dim2 ] f_twodim .)


state 213

    (58) func -> ID f_varobj : ID f_verify_func_composite ( args . )

    )               shift and go to state 220


state 214

    (7) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 7 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 7 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 7 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 7 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)


state 215

    (92) while -> WHILE ( expresion ) DO { . estatutos }
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 221
    empty                          shift and go to state 81

state 216

    (93) for -> FOR expresion TO expresion { estatutos . }
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 222
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 217

    (89) condicion -> IF ( expresion ) THEN { . estatutos } condicionp
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 223
    empty                          shift and go to state 81

state 218

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars . estatutos } f_endfunc
    (21) vars -> vars . DEF tipo dimension : lista_id ;
    (22) vars -> vars . DEF ID f_varsobj : lista_id ;
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 224
    empty                          shift and go to state 81

state 219

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { . vars estatutos } f_endfunc
    (21) vars -> . vars DEF tipo dimension : lista_id ;
    (22) vars -> . vars DEF ID f_varsobj : lista_id ;
    (23) vars -> . empty
    (105) empty -> .

    DEF             reduce using rule 105 (empty -> .)
    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    vars                           shift and go to state 225
    empty                          shift and go to state 11

state 220

    (58) func -> ID f_varobj : ID f_verify_func_composite ( args ) .

    OPFACT          reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPTERM          reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    COMP            reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ]               reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    )               reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    TO              reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ,               reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ;               reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    {               reduce using rule 58 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)


state 221

    (92) while -> WHILE ( expresion ) DO { estatutos . }
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 226
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 222

    (93) for -> FOR expresion TO expresion { estatutos } .

    }               reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)
    CALL            reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)
    WHILE           reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)
    FOR             reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)
    IF              reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)
    ID              reduce using rule 93 (for -> FOR expresion TO expresion { estatutos } .)


state 223

    (89) condicion -> IF ( expresion ) THEN { estatutos . } condicionp
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 227
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 224

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos . } f_endfunc
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 228
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 225

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars . estatutos } f_endfunc
    (21) vars -> vars . DEF tipo dimension : lista_id ;
    (22) vars -> vars . DEF ID f_varsobj : lista_id ;
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 229
    empty                          shift and go to state 81

state 226

    (92) while -> WHILE ( expresion ) DO { estatutos } .

    }               reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)
    CALL            reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)
    WHILE           reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)
    FOR             reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)
    IF              reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)
    ID              reduce using rule 92 (while -> WHILE ( expresion ) DO { estatutos } .)


state 227

    (89) condicion -> IF ( expresion ) THEN { estatutos } . condicionp
    (90) condicionp -> . ELSE { estatutos }
    (91) condicionp -> . empty
    (105) empty -> .

    ELSE            shift and go to state 231
    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    condicionp                     shift and go to state 230
    empty                          shift and go to state 232

state 228

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } . f_endfunc
    (20) f_endfunc -> .

    MAIN            reduce using rule 20 (f_endfunc -> .)
    FUNC            reduce using rule 20 (f_endfunc -> .)
    }               reduce using rule 20 (f_endfunc -> .)

    f_endfunc                      shift and go to state 233

state 229

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos . } f_endfunc
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 234
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 230

    (89) condicion -> IF ( expresion ) THEN { estatutos } condicionp .

    }               reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    CALL            reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    WHILE           reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    FOR             reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    IF              reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)
    ID              reduce using rule 89 (condicion -> IF ( expresion ) THEN { estatutos } condicionp .)


state 231

    (90) condicionp -> ELSE . { estatutos }

    {               shift and go to state 235


state 232

    (91) condicionp -> empty .

    }               reduce using rule 91 (condicionp -> empty .)
    CALL            reduce using rule 91 (condicionp -> empty .)
    WHILE           reduce using rule 91 (condicionp -> empty .)
    FOR             reduce using rule 91 (condicionp -> empty .)
    IF              reduce using rule 91 (condicionp -> empty .)
    ID              reduce using rule 91 (condicionp -> empty .)


state 233

    (15) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 15 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 15 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 15 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)


state 234

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } . f_endfunc
    (20) f_endfunc -> .

    MAIN            reduce using rule 20 (f_endfunc -> .)
    FUNC            reduce using rule 20 (f_endfunc -> .)
    }               reduce using rule 20 (f_endfunc -> .)

    f_endfunc                      shift and go to state 236

state 235

    (90) condicionp -> ELSE { . estatutos }
    (44) estatutos -> . estatutos estatuto
    (45) estatutos -> . empty
    (105) empty -> .

    }               reduce using rule 105 (empty -> .)
    CALL            reduce using rule 105 (empty -> .)
    WHILE           reduce using rule 105 (empty -> .)
    FOR             reduce using rule 105 (empty -> .)
    IF              reduce using rule 105 (empty -> .)
    ID              reduce using rule 105 (empty -> .)

    estatutos                      shift and go to state 237
    empty                          shift and go to state 81

state 236

    (16) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)


state 237

    (90) condicionp -> ELSE { estatutos . }
    (44) estatutos -> estatutos . estatuto
    (46) estatuto -> . asignacion
    (47) estatuto -> . while
    (48) estatuto -> . for
    (49) estatuto -> . condicion
    (50) estatuto -> . CALL call_func ;
    (65) asignacion -> . var = f_oper expresion ;
    (92) while -> . WHILE ( expresion ) DO { estatutos }
    (93) for -> . FOR expresion TO expresion { estatutos }
    (89) condicion -> . IF ( expresion ) THEN { estatutos } condicionp
    (66) var -> . ID f_varobj : ID f_verify_type_composite dimension
    (67) var -> . ID f_verify_type dimension

    }               shift and go to state 238
    CALL            shift and go to state 113
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    IF              shift and go to state 117
    ID              shift and go to state 45

    estatuto                       shift and go to state 108
    asignacion                     shift and go to state 109
    while                          shift and go to state 110
    for                            shift and go to state 111
    condicion                      shift and go to state 112
    var                            shift and go to state 114

state 238

    (90) condicionp -> ELSE { estatutos } .

    }               reduce using rule 90 (condicionp -> ELSE { estatutos } .)
    CALL            reduce using rule 90 (condicionp -> ELSE { estatutos } .)
    WHILE           reduce using rule 90 (condicionp -> ELSE { estatutos } .)
    FOR             reduce using rule 90 (condicionp -> ELSE { estatutos } .)
    IF              reduce using rule 90 (condicionp -> ELSE { estatutos } .)
    ID              reduce using rule 90 (condicionp -> ELSE { estatutos } .)

