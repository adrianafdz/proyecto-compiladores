Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
Rule 2     f_start -> <empty>
Rule 3     f_prog -> <empty>
Rule 4     f_main -> <empty>
Rule 5     f_end -> <empty>
Rule 6     clases -> clases clase
Rule 7     clases -> empty
Rule 8     clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
Rule 9     clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
Rule 10    f_startclass -> <empty>
Rule 11    f_clasepadre -> <empty>
Rule 12    f_cvars -> <empty>
Rule 13    f_endclass -> <empty>
Rule 14    funciones -> funciones funcion
Rule 15    funciones -> empty
Rule 16    funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
Rule 17    funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
Rule 18    f_startfunc -> <empty>
Rule 19    f_nothing -> <empty>
Rule 20    f_tipofunc -> <empty>
Rule 21    f_endfunc -> <empty>
Rule 22    vars -> vars DEF tipo dimension : lista_id ;
Rule 23    vars -> vars DEF ID f_varsobj : lista_id_obj ;
Rule 24    vars -> empty
Rule 25    f_varsobj -> <empty>
Rule 26    cvars -> cvars DEF tipo dimension : lista_id ;
Rule 27    cvars -> empty
Rule 28    lista_id -> ID f_vars
Rule 29    lista_id -> lista_id , ID f_vars
Rule 30    f_vars -> <empty>
Rule 31    lista_id_obj -> ID f_vars_obj
Rule 32    lista_id_obj -> lista_id_obj , ID f_vars_obj
Rule 33    f_vars_obj -> <empty>
Rule 34    dimension -> [ NUM f_dim1 ] f_onedim
Rule 35    dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
Rule 36    dimension -> empty
Rule 37    f_dim1 -> <empty>
Rule 38    f_dim2 -> <empty>
Rule 39    f_onedim -> <empty>
Rule 40    f_twodim -> <empty>
Rule 41    tipo -> NUMBER
Rule 42    tipo -> STRING
Rule 43    params -> pparams
Rule 44    params -> empty
Rule 45    pparams -> tipo ID f_param
Rule 46    pparams -> pparams , tipo ID f_param
Rule 47    f_param -> <empty>
Rule 48    estatutos -> estatutos estatuto
Rule 49    estatutos -> empty
Rule 50    estatuto -> asignacion
Rule 51    estatuto -> while
Rule 52    estatuto -> for
Rule 53    estatuto -> condicion
Rule 54    estatuto -> CALL call_func ;
Rule 55    call_func -> func
Rule 56    call_func -> input
Rule 57    call_func -> write
Rule 58    call_func -> to_num
Rule 59    call_func -> to_str
Rule 60    call_func -> return
Rule 61    func -> ID f_verify_func ( args )
Rule 62    func -> ID f_varobj : ID f_verify_func_composite ( args )
Rule 63    f_verify_func -> <empty>
Rule 64    f_verify_func_composite -> <empty>
Rule 65    args -> args_list
Rule 66    args -> empty
Rule 67    args_list -> expresion
Rule 68    args_list -> args_list , expresion
Rule 69    asignacion -> var = f_oper expresion ;
Rule 70    var -> ID f_varobj : ID f_verify_type_composite indexacion
Rule 71    var -> ID f_verify_type indexacion
Rule 72    indexacion -> [ expresion ]
Rule 73    indexacion -> [ expresion ] [ expresion ]
Rule 74    indexacion -> empty
Rule 75    f_varobj -> <empty>
Rule 76    f_verify_type -> <empty>
Rule 77    f_verify_type_composite -> <empty>
Rule 78    expresion -> exp
Rule 79    expresion -> expresion COMP f_oper exp f_expres
Rule 80    f_expres -> <empty>
Rule 81    exp -> term
Rule 82    exp -> exp OPTERM f_oper term f_exp
Rule 83    f_exp -> <empty>
Rule 84    term -> fact
Rule 85    term -> term OPFACT f_oper fact f_term
Rule 86    f_term -> <empty>
Rule 87    f_oper -> <empty>
Rule 88    fact -> ( lparen expresion ) rparen
Rule 89    fact -> var
Rule 90    fact -> NUM f_fact
Rule 91    fact -> OPTERM NUM
Rule 92    fact -> CALL call_func
Rule 93    lparen -> <empty>
Rule 94    rparen -> <empty>
Rule 95    f_fact -> <empty>
Rule 96    condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
Rule 97    condicionp -> ELSE f_else { estatutos }
Rule 98    condicionp -> empty
Rule 99    f_if -> <empty>
Rule 100   f_endif -> <empty>
Rule 101   f_else -> <empty>
Rule 102   while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
Rule 103   f_while -> <empty>
Rule 104   f_exprwhile -> <empty>
Rule 105   f_endwhile -> <empty>
Rule 106   for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
Rule 107   f_for_start -> <empty>
Rule 108   f_for_to -> <empty>
Rule 109   f_for_end -> <empty>
Rule 110   to_num -> TO_NUMBER ( STR )
Rule 111   to_num -> TO_NUMBER ( var )
Rule 112   to_str -> TO_STRING ( expresion )
Rule 113   input -> INPUT ( var )
Rule 114   write -> PRINT ( write_list )
Rule 115   write_list -> write_list & write_listp
Rule 116   write_list -> write_listp
Rule 117   write_listp -> STR
Rule 118   write_listp -> var
Rule 119   write_listp -> CALL to_str
Rule 120   return -> RET ( expresion )
Rule 121   empty -> <empty>

Terminals, with rules where they appear

&                    : 115
(                    : 1 16 17 61 62 88 96 102 110 111 112 113 114 120
)                    : 1 16 17 61 62 88 96 102 110 111 112 113 114 120
,                    : 29 32 46 68
:                    : 8 16 17 22 23 26 62 70
;                    : 1 1 22 23 26 54 69
=                    : 69
CALL                 : 54 92 119
COMP                 : 79
DEF                  : 22 23 26
DO                   : 102
ELSE                 : 97
END                  : 1
FOR                  : 106
FUNC                 : 16 17
ID                   : 1 8 8 9 16 17 23 28 29 31 32 45 46 61 62 62 70 70 71
IF                   : 96
INPUT                : 113
MAIN                 : 1
NOTHING              : 17
NUM                  : 34 35 35 90 91
NUMBER               : 41
OPFACT               : 85
OPTERM               : 82 91
PRINT                : 114
PROGRAM              : 1
RET                  : 120
STR                  : 110 117
STRING               : 42
THEN                 : 96
TO                   : 106
TO_NUMBER            : 110 111
TO_STRING            : 112
TYPE                 : 8 9
WHILE                : 102
[                    : 34 35 35 72 73 73
]                    : 34 35 35 72 73 73
error                : 
{                    : 1 8 9 16 17 96 97 102 106
}                    : 1 8 9 16 17 96 97 102 106

Nonterminals, with rules where they appear

args                 : 61 62
args_list            : 65 68
asignacion           : 50
call_func            : 54 92
clase                : 6
clases               : 1 6
condicion            : 53
condicionp           : 96
cvars                : 8 9 26
dimension            : 22 26
empty                : 7 15 24 27 36 44 49 66 74 98
estatuto             : 48
estatutos            : 1 16 17 48 96 97 102 106
exp                  : 78 79 82
expresion            : 67 68 69 72 73 73 79 88 96 102 106 106 112 120
f_clasepadre         : 8
f_cvars              : 8 9
f_dim1               : 34 35
f_dim2               : 35
f_else               : 97
f_end                : 1
f_endclass           : 8 9
f_endfunc            : 16 17
f_endif              : 96
f_endwhile           : 102
f_exp                : 82
f_expres             : 79
f_exprwhile          : 102
f_fact               : 90
f_for_end            : 106
f_for_start          : 106
f_for_to             : 106
f_if                 : 96
f_main               : 1
f_nothing            : 17
f_onedim             : 34
f_oper               : 69 79 82 85
f_param              : 45 46
f_prog               : 1
f_start              : 1
f_startclass         : 8 9
f_startfunc          : 16 17
f_term               : 85
f_tipofunc           : 16 17
f_twodim             : 35
f_varobj             : 62 70
f_vars               : 28 29
f_vars_obj           : 31 32
f_varsobj            : 23
f_verify_func        : 61
f_verify_func_composite : 62
f_verify_type        : 71
f_verify_type_composite : 70
f_while              : 102
fact                 : 84 85
for                  : 52
func                 : 55
funcion              : 14
funciones            : 1 8 9 14
indexacion           : 70 71
input                : 56
lista_id             : 22 26 29
lista_id_obj         : 23 32
lparen               : 88
params               : 16 17
pparams              : 43 46
return               : 60
rparen               : 88
start                : 0
term                 : 81 82 85
tipo                 : 16 22 26 45 46
to_num               : 58
to_str               : 59 119
var                  : 69 89 111 113 118
vars                 : 1 16 17 22 23
while                : 51
write                : 57
write_list           : 114 115
write_listp          : 115 116

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    PROGRAM         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PROGRAM . f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (2) f_start -> .

    ID              reduce using rule 2 (f_start -> .)

    f_start                        shift and go to state 3

state 3

    (1) start -> PROGRAM f_start . ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ID              shift and go to state 4


state 4

    (1) start -> PROGRAM f_start ID . f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (3) f_prog -> .

    ;               reduce using rule 3 (f_prog -> .)

    f_prog                         shift and go to state 5

state 5

    (1) start -> PROGRAM f_start ID f_prog . ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;

    ;               shift and go to state 6


state 6

    (1) start -> PROGRAM f_start ID f_prog ; . clases vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> . clases clase
    (7) clases -> . empty
    (121) empty -> .

    TYPE            reduce using rule 121 (empty -> .)
    DEF             reduce using rule 121 (empty -> .)
    MAIN            reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    clases                         shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) start -> PROGRAM f_start ID f_prog ; clases . vars funciones MAIN f_main ( ) { estatutos } END f_end ;
    (6) clases -> clases . clase
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id_obj ;
    (24) vars -> . empty
    (8) clase -> . TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> . TYPE ID f_startclass { cvars f_cvars funciones } f_endclass
    (121) empty -> .

    TYPE            shift and go to state 12
    DEF             reduce using rule 121 (empty -> .)
    MAIN            reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    vars                           shift and go to state 9
    clase                          shift and go to state 10
    empty                          shift and go to state 11

state 8

    (7) clases -> empty .

    TYPE            reduce using rule 7 (clases -> empty .)
    DEF             reduce using rule 7 (clases -> empty .)
    MAIN            reduce using rule 7 (clases -> empty .)
    FUNC            reduce using rule 7 (clases -> empty .)


state 9

    (1) start -> PROGRAM f_start ID f_prog ; clases vars . funciones MAIN f_main ( ) { estatutos } END f_end ;
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id_obj ;
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (121) empty -> .

    DEF             shift and go to state 14
    MAIN            reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    funciones                      shift and go to state 13
    empty                          shift and go to state 15

state 10

    (6) clases -> clases clase .

    TYPE            reduce using rule 6 (clases -> clases clase .)
    DEF             reduce using rule 6 (clases -> clases clase .)
    MAIN            reduce using rule 6 (clases -> clases clase .)
    FUNC            reduce using rule 6 (clases -> clases clase .)


state 11

    (24) vars -> empty .

    DEF             reduce using rule 24 (vars -> empty .)
    MAIN            reduce using rule 24 (vars -> empty .)
    FUNC            reduce using rule 24 (vars -> empty .)
    }               reduce using rule 24 (vars -> empty .)
    CALL            reduce using rule 24 (vars -> empty .)
    WHILE           reduce using rule 24 (vars -> empty .)
    FOR             reduce using rule 24 (vars -> empty .)
    IF              reduce using rule 24 (vars -> empty .)
    ID              reduce using rule 24 (vars -> empty .)


state 12

    (8) clase -> TYPE . ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE . ID f_startclass { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 16


state 13

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones . MAIN f_main ( ) { estatutos } END f_end ;
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    MAIN            shift and go to state 17
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 14

    (22) vars -> vars DEF . tipo dimension : lista_id ;
    (23) vars -> vars DEF . ID f_varsobj : lista_id_obj ;
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    ID              shift and go to state 21
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 20

state 15

    (15) funciones -> empty .

    MAIN            reduce using rule 15 (funciones -> empty .)
    FUNC            reduce using rule 15 (funciones -> empty .)
    }               reduce using rule 15 (funciones -> empty .)


state 16

    (8) clase -> TYPE ID . f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID . f_startclass { cvars f_cvars funciones } f_endclass
    (10) f_startclass -> .

    :               reduce using rule 10 (f_startclass -> .)
    {               reduce using rule 10 (f_startclass -> .)

    f_startclass                   shift and go to state 24

state 17

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN . f_main ( ) { estatutos } END f_end ;
    (4) f_main -> .

    (               reduce using rule 4 (f_main -> .)

    f_main                         shift and go to state 25

state 18

    (14) funciones -> funciones funcion .

    MAIN            reduce using rule 14 (funciones -> funciones funcion .)
    FUNC            reduce using rule 14 (funciones -> funciones funcion .)
    }               reduce using rule 14 (funciones -> funciones funcion .)


state 19

    (16) funcion -> FUNC . ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC . ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    ID              shift and go to state 26


state 20

    (22) vars -> vars DEF tipo . dimension : lista_id ;
    (34) dimension -> . [ NUM f_dim1 ] f_onedim
    (35) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
    (36) dimension -> . empty
    (121) empty -> .

    [               shift and go to state 28
    :               reduce using rule 121 (empty -> .)

    dimension                      shift and go to state 27
    empty                          shift and go to state 29

state 21

    (23) vars -> vars DEF ID . f_varsobj : lista_id_obj ;
    (25) f_varsobj -> .

    :               reduce using rule 25 (f_varsobj -> .)

    f_varsobj                      shift and go to state 30

state 22

    (41) tipo -> NUMBER .

    [               reduce using rule 41 (tipo -> NUMBER .)
    :               reduce using rule 41 (tipo -> NUMBER .)
    ID              reduce using rule 41 (tipo -> NUMBER .)
    {               reduce using rule 41 (tipo -> NUMBER .)


state 23

    (42) tipo -> STRING .

    [               reduce using rule 42 (tipo -> STRING .)
    :               reduce using rule 42 (tipo -> STRING .)
    ID              reduce using rule 42 (tipo -> STRING .)
    {               reduce using rule 42 (tipo -> STRING .)


state 24

    (8) clase -> TYPE ID f_startclass . : ID f_clasepadre { cvars f_cvars funciones } f_endclass
    (9) clase -> TYPE ID f_startclass . { cvars f_cvars funciones } f_endclass

    :               shift and go to state 31
    {               shift and go to state 32


state 25

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main . ( ) { estatutos } END f_end ;

    (               shift and go to state 33


state 26

    (16) funcion -> FUNC ID . f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID . f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (18) f_startfunc -> .

    (               reduce using rule 18 (f_startfunc -> .)

    f_startfunc                    shift and go to state 34

state 27

    (22) vars -> vars DEF tipo dimension . : lista_id ;

    :               shift and go to state 35


state 28

    (34) dimension -> [ . NUM f_dim1 ] f_onedim
    (35) dimension -> [ . NUM f_dim1 ] [ NUM f_dim2 ] f_twodim

    NUM             shift and go to state 36


state 29

    (36) dimension -> empty .

    :               reduce using rule 36 (dimension -> empty .)


state 30

    (23) vars -> vars DEF ID f_varsobj . : lista_id_obj ;

    :               shift and go to state 37


state 31

    (8) clase -> TYPE ID f_startclass : . ID f_clasepadre { cvars f_cvars funciones } f_endclass

    ID              shift and go to state 38


state 32

    (9) clase -> TYPE ID f_startclass { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (121) empty -> .

    DEF             reduce using rule 121 (empty -> .)
    }               reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    cvars                          shift and go to state 39
    empty                          shift and go to state 40

state 33

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( . ) { estatutos } END f_end ;

    )               shift and go to state 41


state 34

    (16) funcion -> FUNC ID f_startfunc . ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc . ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    (               shift and go to state 42


state 35

    (22) vars -> vars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 43

state 36

    (34) dimension -> [ NUM . f_dim1 ] f_onedim
    (35) dimension -> [ NUM . f_dim1 ] [ NUM f_dim2 ] f_twodim
    (37) f_dim1 -> .

    ]               reduce using rule 37 (f_dim1 -> .)

    f_dim1                         shift and go to state 45

state 37

    (23) vars -> vars DEF ID f_varsobj : . lista_id_obj ;
    (31) lista_id_obj -> . ID f_vars_obj
    (32) lista_id_obj -> . lista_id_obj , ID f_vars_obj

    ID              shift and go to state 46

    lista_id_obj                   shift and go to state 47

state 38

    (8) clase -> TYPE ID f_startclass : ID . f_clasepadre { cvars f_cvars funciones } f_endclass
    (11) f_clasepadre -> .

    {               reduce using rule 11 (f_clasepadre -> .)

    f_clasepadre                   shift and go to state 48

state 39

    (9) clase -> TYPE ID f_startclass { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 50
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 49

state 40

    (27) cvars -> empty .

    DEF             reduce using rule 27 (cvars -> empty .)
    }               reduce using rule 27 (cvars -> empty .)
    FUNC            reduce using rule 27 (cvars -> empty .)


state 41

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) . { estatutos } END f_end ;

    {               shift and go to state 51


state 42

    (16) funcion -> FUNC ID f_startfunc ( . params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( . params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (43) params -> . pparams
    (44) params -> . empty
    (45) pparams -> . tipo ID f_param
    (46) pparams -> . pparams , tipo ID f_param
    (121) empty -> .
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    )               reduce using rule 121 (empty -> .)
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    params                         shift and go to state 52
    tipo                           shift and go to state 53
    pparams                        shift and go to state 54
    empty                          shift and go to state 55

state 43

    (22) vars -> vars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 56
    ,               shift and go to state 57


state 44

    (28) lista_id -> ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 58

state 45

    (34) dimension -> [ NUM f_dim1 . ] f_onedim
    (35) dimension -> [ NUM f_dim1 . ] [ NUM f_dim2 ] f_twodim

    ]               shift and go to state 59


state 46

    (31) lista_id_obj -> ID . f_vars_obj
    (33) f_vars_obj -> .

    ;               reduce using rule 33 (f_vars_obj -> .)
    ,               reduce using rule 33 (f_vars_obj -> .)

    f_vars_obj                     shift and go to state 60

state 47

    (23) vars -> vars DEF ID f_varsobj : lista_id_obj . ;
    (32) lista_id_obj -> lista_id_obj . , ID f_vars_obj

    ;               shift and go to state 61
    ,               shift and go to state 62


state 48

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre . { cvars f_cvars funciones } f_endclass

    {               shift and go to state 63


state 49

    (9) clase -> TYPE ID f_startclass { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    funciones                      shift and go to state 64
    empty                          shift and go to state 15

state 50

    (26) cvars -> cvars DEF . tipo dimension : lista_id ;
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 65

state 51

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { . estatutos } END f_end ;
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 66
    empty                          shift and go to state 67

state 52

    (16) funcion -> FUNC ID f_startfunc ( params . ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params . ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    )               shift and go to state 68


state 53

    (45) pparams -> tipo . ID f_param

    ID              shift and go to state 69


state 54

    (43) params -> pparams .
    (46) pparams -> pparams . , tipo ID f_param

    )               reduce using rule 43 (params -> pparams .)
    ,               shift and go to state 70


state 55

    (44) params -> empty .

    )               reduce using rule 44 (params -> empty .)


state 56

    (22) vars -> vars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    MAIN            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    CALL            reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    WHILE           reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    FOR             reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    IF              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)
    ID              reduce using rule 22 (vars -> vars DEF tipo dimension : lista_id ; .)


state 57

    (29) lista_id -> lista_id , . ID f_vars

    ID              shift and go to state 71


state 58

    (28) lista_id -> ID f_vars .

    ;               reduce using rule 28 (lista_id -> ID f_vars .)
    ,               reduce using rule 28 (lista_id -> ID f_vars .)


state 59

    (34) dimension -> [ NUM f_dim1 ] . f_onedim
    (35) dimension -> [ NUM f_dim1 ] . [ NUM f_dim2 ] f_twodim
    (39) f_onedim -> .

    [               shift and go to state 72
    :               reduce using rule 39 (f_onedim -> .)

    f_onedim                       shift and go to state 73

state 60

    (31) lista_id_obj -> ID f_vars_obj .

    ;               reduce using rule 31 (lista_id_obj -> ID f_vars_obj .)
    ,               reduce using rule 31 (lista_id_obj -> ID f_vars_obj .)


state 61

    (23) vars -> vars DEF ID f_varsobj : lista_id_obj ; .

    DEF             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    MAIN            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    FUNC            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    }               reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    CALL            reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    WHILE           reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    FOR             reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    IF              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)
    ID              reduce using rule 23 (vars -> vars DEF ID f_varsobj : lista_id_obj ; .)


state 62

    (32) lista_id_obj -> lista_id_obj , . ID f_vars_obj

    ID              shift and go to state 74


state 63

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { . cvars f_cvars funciones } f_endclass
    (26) cvars -> . cvars DEF tipo dimension : lista_id ;
    (27) cvars -> . empty
    (121) empty -> .

    DEF             reduce using rule 121 (empty -> .)
    }               reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    cvars                          shift and go to state 75
    empty                          shift and go to state 40

state 64

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 76
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 65

    (26) cvars -> cvars DEF tipo . dimension : lista_id ;
    (34) dimension -> . [ NUM f_dim1 ] f_onedim
    (35) dimension -> . [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim
    (36) dimension -> . empty
    (121) empty -> .

    [               shift and go to state 28
    :               reduce using rule 121 (empty -> .)

    dimension                      shift and go to state 77
    empty                          shift and go to state 29

state 66

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos . } END f_end ;
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 79
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 67

    (49) estatutos -> empty .

    }               reduce using rule 49 (estatutos -> empty .)
    CALL            reduce using rule 49 (estatutos -> empty .)
    WHILE           reduce using rule 49 (estatutos -> empty .)
    FOR             reduce using rule 49 (estatutos -> empty .)
    IF              reduce using rule 49 (estatutos -> empty .)
    ID              reduce using rule 49 (estatutos -> empty .)


state 68

    (16) funcion -> FUNC ID f_startfunc ( params ) . : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) . : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    :               shift and go to state 90


state 69

    (45) pparams -> tipo ID . f_param
    (47) f_param -> .

    ,               reduce using rule 47 (f_param -> .)
    )               reduce using rule 47 (f_param -> .)

    f_param                        shift and go to state 91

state 70

    (46) pparams -> pparams , . tipo ID f_param
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 92

state 71

    (29) lista_id -> lista_id , ID . f_vars
    (30) f_vars -> .

    ;               reduce using rule 30 (f_vars -> .)
    ,               reduce using rule 30 (f_vars -> .)

    f_vars                         shift and go to state 93

state 72

    (35) dimension -> [ NUM f_dim1 ] [ . NUM f_dim2 ] f_twodim

    NUM             shift and go to state 94


state 73

    (34) dimension -> [ NUM f_dim1 ] f_onedim .

    :               reduce using rule 34 (dimension -> [ NUM f_dim1 ] f_onedim .)


state 74

    (32) lista_id_obj -> lista_id_obj , ID . f_vars_obj
    (33) f_vars_obj -> .

    ;               reduce using rule 33 (f_vars_obj -> .)
    ,               reduce using rule 33 (f_vars_obj -> .)

    f_vars_obj                     shift and go to state 95

state 75

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars . f_cvars funciones } f_endclass
    (26) cvars -> cvars . DEF tipo dimension : lista_id ;
    (12) f_cvars -> .

    DEF             shift and go to state 50
    }               reduce using rule 12 (f_cvars -> .)
    FUNC            reduce using rule 12 (f_cvars -> .)

    f_cvars                        shift and go to state 96

state 76

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 97

state 77

    (26) cvars -> cvars DEF tipo dimension . : lista_id ;

    :               shift and go to state 98


state 78

    (70) var -> ID . f_varobj : ID f_verify_type_composite indexacion
    (71) var -> ID . f_verify_type indexacion
    (75) f_varobj -> .
    (76) f_verify_type -> .

    :               reduce using rule 75 (f_varobj -> .)
    [               reduce using rule 76 (f_verify_type -> .)
    =               reduce using rule 76 (f_verify_type -> .)
    OPFACT          reduce using rule 76 (f_verify_type -> .)
    OPTERM          reduce using rule 76 (f_verify_type -> .)
    COMP            reduce using rule 76 (f_verify_type -> .)
    TO              reduce using rule 76 (f_verify_type -> .)
    )               reduce using rule 76 (f_verify_type -> .)
    ]               reduce using rule 76 (f_verify_type -> .)
    &               reduce using rule 76 (f_verify_type -> .)
    ;               reduce using rule 76 (f_verify_type -> .)
    ,               reduce using rule 76 (f_verify_type -> .)
    {               reduce using rule 76 (f_verify_type -> .)

    f_varobj                       shift and go to state 99
    f_verify_type                  shift and go to state 100

state 79

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } . END f_end ;

    END             shift and go to state 101


state 80

    (48) estatutos -> estatutos estatuto .

    }               reduce using rule 48 (estatutos -> estatutos estatuto .)
    CALL            reduce using rule 48 (estatutos -> estatutos estatuto .)
    WHILE           reduce using rule 48 (estatutos -> estatutos estatuto .)
    FOR             reduce using rule 48 (estatutos -> estatutos estatuto .)
    IF              reduce using rule 48 (estatutos -> estatutos estatuto .)
    ID              reduce using rule 48 (estatutos -> estatutos estatuto .)


state 81

    (50) estatuto -> asignacion .

    }               reduce using rule 50 (estatuto -> asignacion .)
    CALL            reduce using rule 50 (estatuto -> asignacion .)
    WHILE           reduce using rule 50 (estatuto -> asignacion .)
    FOR             reduce using rule 50 (estatuto -> asignacion .)
    IF              reduce using rule 50 (estatuto -> asignacion .)
    ID              reduce using rule 50 (estatuto -> asignacion .)


state 82

    (51) estatuto -> while .

    }               reduce using rule 51 (estatuto -> while .)
    CALL            reduce using rule 51 (estatuto -> while .)
    WHILE           reduce using rule 51 (estatuto -> while .)
    FOR             reduce using rule 51 (estatuto -> while .)
    IF              reduce using rule 51 (estatuto -> while .)
    ID              reduce using rule 51 (estatuto -> while .)


state 83

    (52) estatuto -> for .

    }               reduce using rule 52 (estatuto -> for .)
    CALL            reduce using rule 52 (estatuto -> for .)
    WHILE           reduce using rule 52 (estatuto -> for .)
    FOR             reduce using rule 52 (estatuto -> for .)
    IF              reduce using rule 52 (estatuto -> for .)
    ID              reduce using rule 52 (estatuto -> for .)


state 84

    (53) estatuto -> condicion .

    }               reduce using rule 53 (estatuto -> condicion .)
    CALL            reduce using rule 53 (estatuto -> condicion .)
    WHILE           reduce using rule 53 (estatuto -> condicion .)
    FOR             reduce using rule 53 (estatuto -> condicion .)
    IF              reduce using rule 53 (estatuto -> condicion .)
    ID              reduce using rule 53 (estatuto -> condicion .)


state 85

    (54) estatuto -> CALL . call_func ;
    (55) call_func -> . func
    (56) call_func -> . input
    (57) call_func -> . write
    (58) call_func -> . to_num
    (59) call_func -> . to_str
    (60) call_func -> . return
    (61) func -> . ID f_verify_func ( args )
    (62) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (113) input -> . INPUT ( var )
    (114) write -> . PRINT ( write_list )
    (110) to_num -> . TO_NUMBER ( STR )
    (111) to_num -> . TO_NUMBER ( var )
    (112) to_str -> . TO_STRING ( expresion )
    (120) return -> . RET ( expresion )

    ID              shift and go to state 109
    INPUT           shift and go to state 110
    PRINT           shift and go to state 111
    TO_NUMBER       shift and go to state 112
    TO_STRING       shift and go to state 113
    RET             shift and go to state 114

    call_func                      shift and go to state 102
    func                           shift and go to state 103
    input                          shift and go to state 104
    write                          shift and go to state 105
    to_num                         shift and go to state 106
    to_str                         shift and go to state 107
    return                         shift and go to state 108

state 86

    (69) asignacion -> var . = f_oper expresion ;

    =               shift and go to state 115


state 87

    (102) while -> WHILE . f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (103) f_while -> .

    (               reduce using rule 103 (f_while -> .)

    f_while                        shift and go to state 116

state 88

    (106) for -> FOR . expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 89

    (96) condicion -> IF . ( expresion ) f_if THEN { estatutos } condicionp f_endif

    (               shift and go to state 126


state 90

    (16) funcion -> FUNC ID f_startfunc ( params ) : . tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> FUNC ID f_startfunc ( params ) : . NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc
    (41) tipo -> . NUMBER
    (42) tipo -> . STRING

    NOTHING         shift and go to state 128
    NUMBER          shift and go to state 22
    STRING          shift and go to state 23

    tipo                           shift and go to state 127

state 91

    (45) pparams -> tipo ID f_param .

    ,               reduce using rule 45 (pparams -> tipo ID f_param .)
    )               reduce using rule 45 (pparams -> tipo ID f_param .)


state 92

    (46) pparams -> pparams , tipo . ID f_param

    ID              shift and go to state 129


state 93

    (29) lista_id -> lista_id , ID f_vars .

    ;               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)
    ,               reduce using rule 29 (lista_id -> lista_id , ID f_vars .)


state 94

    (35) dimension -> [ NUM f_dim1 ] [ NUM . f_dim2 ] f_twodim
    (38) f_dim2 -> .

    ]               reduce using rule 38 (f_dim2 -> .)

    f_dim2                         shift and go to state 130

state 95

    (32) lista_id_obj -> lista_id_obj , ID f_vars_obj .

    ;               reduce using rule 32 (lista_id_obj -> lista_id_obj , ID f_vars_obj .)
    ,               reduce using rule 32 (lista_id_obj -> lista_id_obj , ID f_vars_obj .)


state 96

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars . funciones } f_endclass
    (14) funciones -> . funciones funcion
    (15) funciones -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    FUNC            reduce using rule 121 (empty -> .)

    funciones                      shift and go to state 131
    empty                          shift and go to state 15

state 97

    (9) clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 9 (clase -> TYPE ID f_startclass { cvars f_cvars funciones } f_endclass .)


state 98

    (26) cvars -> cvars DEF tipo dimension : . lista_id ;
    (28) lista_id -> . ID f_vars
    (29) lista_id -> . lista_id , ID f_vars

    ID              shift and go to state 44

    lista_id                       shift and go to state 132

state 99

    (70) var -> ID f_varobj . : ID f_verify_type_composite indexacion

    :               shift and go to state 133


state 100

    (71) var -> ID f_verify_type . indexacion
    (72) indexacion -> . [ expresion ]
    (73) indexacion -> . [ expresion ] [ expresion ]
    (74) indexacion -> . empty
    (121) empty -> .

    [               shift and go to state 135
    =               reduce using rule 121 (empty -> .)
    OPFACT          reduce using rule 121 (empty -> .)
    OPTERM          reduce using rule 121 (empty -> .)
    COMP            reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    )               reduce using rule 121 (empty -> .)
    ]               reduce using rule 121 (empty -> .)
    &               reduce using rule 121 (empty -> .)
    ;               reduce using rule 121 (empty -> .)
    ,               reduce using rule 121 (empty -> .)
    {               reduce using rule 121 (empty -> .)

    indexacion                     shift and go to state 134
    empty                          shift and go to state 136

state 101

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END . f_end ;
    (5) f_end -> .

    ;               reduce using rule 5 (f_end -> .)

    f_end                          shift and go to state 137

state 102

    (54) estatuto -> CALL call_func . ;

    ;               shift and go to state 138


state 103

    (55) call_func -> func .

    ;               reduce using rule 55 (call_func -> func .)
    OPFACT          reduce using rule 55 (call_func -> func .)
    OPTERM          reduce using rule 55 (call_func -> func .)
    COMP            reduce using rule 55 (call_func -> func .)
    TO              reduce using rule 55 (call_func -> func .)
    )               reduce using rule 55 (call_func -> func .)
    ]               reduce using rule 55 (call_func -> func .)
    ,               reduce using rule 55 (call_func -> func .)
    {               reduce using rule 55 (call_func -> func .)


state 104

    (56) call_func -> input .

    ;               reduce using rule 56 (call_func -> input .)
    OPFACT          reduce using rule 56 (call_func -> input .)
    OPTERM          reduce using rule 56 (call_func -> input .)
    COMP            reduce using rule 56 (call_func -> input .)
    TO              reduce using rule 56 (call_func -> input .)
    )               reduce using rule 56 (call_func -> input .)
    ]               reduce using rule 56 (call_func -> input .)
    ,               reduce using rule 56 (call_func -> input .)
    {               reduce using rule 56 (call_func -> input .)


state 105

    (57) call_func -> write .

    ;               reduce using rule 57 (call_func -> write .)
    OPFACT          reduce using rule 57 (call_func -> write .)
    OPTERM          reduce using rule 57 (call_func -> write .)
    COMP            reduce using rule 57 (call_func -> write .)
    TO              reduce using rule 57 (call_func -> write .)
    )               reduce using rule 57 (call_func -> write .)
    ]               reduce using rule 57 (call_func -> write .)
    ,               reduce using rule 57 (call_func -> write .)
    {               reduce using rule 57 (call_func -> write .)


state 106

    (58) call_func -> to_num .

    ;               reduce using rule 58 (call_func -> to_num .)
    OPFACT          reduce using rule 58 (call_func -> to_num .)
    OPTERM          reduce using rule 58 (call_func -> to_num .)
    COMP            reduce using rule 58 (call_func -> to_num .)
    TO              reduce using rule 58 (call_func -> to_num .)
    )               reduce using rule 58 (call_func -> to_num .)
    ]               reduce using rule 58 (call_func -> to_num .)
    ,               reduce using rule 58 (call_func -> to_num .)
    {               reduce using rule 58 (call_func -> to_num .)


state 107

    (59) call_func -> to_str .

    ;               reduce using rule 59 (call_func -> to_str .)
    OPFACT          reduce using rule 59 (call_func -> to_str .)
    OPTERM          reduce using rule 59 (call_func -> to_str .)
    COMP            reduce using rule 59 (call_func -> to_str .)
    TO              reduce using rule 59 (call_func -> to_str .)
    )               reduce using rule 59 (call_func -> to_str .)
    ]               reduce using rule 59 (call_func -> to_str .)
    ,               reduce using rule 59 (call_func -> to_str .)
    {               reduce using rule 59 (call_func -> to_str .)


state 108

    (60) call_func -> return .

    ;               reduce using rule 60 (call_func -> return .)
    OPFACT          reduce using rule 60 (call_func -> return .)
    OPTERM          reduce using rule 60 (call_func -> return .)
    COMP            reduce using rule 60 (call_func -> return .)
    TO              reduce using rule 60 (call_func -> return .)
    )               reduce using rule 60 (call_func -> return .)
    ]               reduce using rule 60 (call_func -> return .)
    ,               reduce using rule 60 (call_func -> return .)
    {               reduce using rule 60 (call_func -> return .)


state 109

    (61) func -> ID . f_verify_func ( args )
    (62) func -> ID . f_varobj : ID f_verify_func_composite ( args )
    (63) f_verify_func -> .
    (75) f_varobj -> .

    (               reduce using rule 63 (f_verify_func -> .)
    :               reduce using rule 75 (f_varobj -> .)

    f_verify_func                  shift and go to state 139
    f_varobj                       shift and go to state 140

state 110

    (113) input -> INPUT . ( var )

    (               shift and go to state 141


state 111

    (114) write -> PRINT . ( write_list )

    (               shift and go to state 142


state 112

    (110) to_num -> TO_NUMBER . ( STR )
    (111) to_num -> TO_NUMBER . ( var )

    (               shift and go to state 143


state 113

    (112) to_str -> TO_STRING . ( expresion )

    (               shift and go to state 144


state 114

    (120) return -> RET . ( expresion )

    (               shift and go to state 145


state 115

    (69) asignacion -> var = . f_oper expresion ;
    (87) f_oper -> .

    (               reduce using rule 87 (f_oper -> .)
    NUM             reduce using rule 87 (f_oper -> .)
    OPTERM          reduce using rule 87 (f_oper -> .)
    CALL            reduce using rule 87 (f_oper -> .)
    ID              reduce using rule 87 (f_oper -> .)

    f_oper                         shift and go to state 146

state 116

    (102) while -> WHILE f_while . ( expresion f_exprwhile ) DO { estatutos } f_endwhile

    (               shift and go to state 147


state 117

    (106) for -> FOR expresion . f_for_start TO expresion f_for_to { estatutos } f_for_end
    (79) expresion -> expresion . COMP f_oper exp f_expres
    (107) f_for_start -> .

    COMP            shift and go to state 149
    TO              reduce using rule 107 (f_for_start -> .)

    f_for_start                    shift and go to state 148

state 118

    (78) expresion -> exp .
    (82) exp -> exp . OPTERM f_oper term f_exp

    COMP            reduce using rule 78 (expresion -> exp .)
    TO              reduce using rule 78 (expresion -> exp .)
    )               reduce using rule 78 (expresion -> exp .)
    ]               reduce using rule 78 (expresion -> exp .)
    ;               reduce using rule 78 (expresion -> exp .)
    ,               reduce using rule 78 (expresion -> exp .)
    {               reduce using rule 78 (expresion -> exp .)
    OPTERM          shift and go to state 150


state 119

    (81) exp -> term .
    (85) term -> term . OPFACT f_oper fact f_term

    OPTERM          reduce using rule 81 (exp -> term .)
    COMP            reduce using rule 81 (exp -> term .)
    TO              reduce using rule 81 (exp -> term .)
    )               reduce using rule 81 (exp -> term .)
    ]               reduce using rule 81 (exp -> term .)
    ;               reduce using rule 81 (exp -> term .)
    ,               reduce using rule 81 (exp -> term .)
    {               reduce using rule 81 (exp -> term .)
    OPFACT          shift and go to state 151


state 120

    (91) fact -> OPTERM . NUM

    NUM             shift and go to state 152


state 121

    (84) term -> fact .

    OPFACT          reduce using rule 84 (term -> fact .)
    OPTERM          reduce using rule 84 (term -> fact .)
    COMP            reduce using rule 84 (term -> fact .)
    TO              reduce using rule 84 (term -> fact .)
    )               reduce using rule 84 (term -> fact .)
    ]               reduce using rule 84 (term -> fact .)
    ;               reduce using rule 84 (term -> fact .)
    ,               reduce using rule 84 (term -> fact .)
    {               reduce using rule 84 (term -> fact .)


state 122

    (88) fact -> ( . lparen expresion ) rparen
    (93) lparen -> .

    (               reduce using rule 93 (lparen -> .)
    NUM             reduce using rule 93 (lparen -> .)
    OPTERM          reduce using rule 93 (lparen -> .)
    CALL            reduce using rule 93 (lparen -> .)
    ID              reduce using rule 93 (lparen -> .)

    lparen                         shift and go to state 153

state 123

    (89) fact -> var .

    OPFACT          reduce using rule 89 (fact -> var .)
    OPTERM          reduce using rule 89 (fact -> var .)
    COMP            reduce using rule 89 (fact -> var .)
    TO              reduce using rule 89 (fact -> var .)
    )               reduce using rule 89 (fact -> var .)
    ]               reduce using rule 89 (fact -> var .)
    ;               reduce using rule 89 (fact -> var .)
    ,               reduce using rule 89 (fact -> var .)
    {               reduce using rule 89 (fact -> var .)


state 124

    (90) fact -> NUM . f_fact
    (95) f_fact -> .

    OPFACT          reduce using rule 95 (f_fact -> .)
    OPTERM          reduce using rule 95 (f_fact -> .)
    COMP            reduce using rule 95 (f_fact -> .)
    TO              reduce using rule 95 (f_fact -> .)
    )               reduce using rule 95 (f_fact -> .)
    ]               reduce using rule 95 (f_fact -> .)
    ;               reduce using rule 95 (f_fact -> .)
    ,               reduce using rule 95 (f_fact -> .)
    {               reduce using rule 95 (f_fact -> .)

    f_fact                         shift and go to state 154

state 125

    (92) fact -> CALL . call_func
    (55) call_func -> . func
    (56) call_func -> . input
    (57) call_func -> . write
    (58) call_func -> . to_num
    (59) call_func -> . to_str
    (60) call_func -> . return
    (61) func -> . ID f_verify_func ( args )
    (62) func -> . ID f_varobj : ID f_verify_func_composite ( args )
    (113) input -> . INPUT ( var )
    (114) write -> . PRINT ( write_list )
    (110) to_num -> . TO_NUMBER ( STR )
    (111) to_num -> . TO_NUMBER ( var )
    (112) to_str -> . TO_STRING ( expresion )
    (120) return -> . RET ( expresion )

    ID              shift and go to state 109
    INPUT           shift and go to state 110
    PRINT           shift and go to state 111
    TO_NUMBER       shift and go to state 112
    TO_STRING       shift and go to state 113
    RET             shift and go to state 114

    call_func                      shift and go to state 155
    func                           shift and go to state 103
    input                          shift and go to state 104
    write                          shift and go to state 105
    to_num                         shift and go to state 106
    to_str                         shift and go to state 107
    return                         shift and go to state 108

state 126

    (96) condicion -> IF ( . expresion ) f_if THEN { estatutos } condicionp f_endif
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 156
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 127

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 157

state 128

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING . f_nothing f_tipofunc { vars estatutos } f_endfunc
    (19) f_nothing -> .

    {               reduce using rule 19 (f_nothing -> .)

    f_nothing                      shift and go to state 158

state 129

    (46) pparams -> pparams , tipo ID . f_param
    (47) f_param -> .

    ,               reduce using rule 47 (f_param -> .)
    )               reduce using rule 47 (f_param -> .)

    f_param                        shift and go to state 159

state 130

    (35) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 . ] f_twodim

    ]               shift and go to state 160


state 131

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones . } f_endclass
    (14) funciones -> funciones . funcion
    (16) funcion -> . FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc
    (17) funcion -> . FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc

    }               shift and go to state 161
    FUNC            shift and go to state 19

    funcion                        shift and go to state 18

state 132

    (26) cvars -> cvars DEF tipo dimension : lista_id . ;
    (29) lista_id -> lista_id . , ID f_vars

    ;               shift and go to state 162
    ,               shift and go to state 57


state 133

    (70) var -> ID f_varobj : . ID f_verify_type_composite indexacion

    ID              shift and go to state 163


state 134

    (71) var -> ID f_verify_type indexacion .

    =               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    OPFACT          reduce using rule 71 (var -> ID f_verify_type indexacion .)
    OPTERM          reduce using rule 71 (var -> ID f_verify_type indexacion .)
    COMP            reduce using rule 71 (var -> ID f_verify_type indexacion .)
    TO              reduce using rule 71 (var -> ID f_verify_type indexacion .)
    )               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    ]               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    &               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    ;               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    ,               reduce using rule 71 (var -> ID f_verify_type indexacion .)
    {               reduce using rule 71 (var -> ID f_verify_type indexacion .)


state 135

    (72) indexacion -> [ . expresion ]
    (73) indexacion -> [ . expresion ] [ expresion ]
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 164
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 136

    (74) indexacion -> empty .

    =               reduce using rule 74 (indexacion -> empty .)
    OPFACT          reduce using rule 74 (indexacion -> empty .)
    OPTERM          reduce using rule 74 (indexacion -> empty .)
    COMP            reduce using rule 74 (indexacion -> empty .)
    TO              reduce using rule 74 (indexacion -> empty .)
    )               reduce using rule 74 (indexacion -> empty .)
    ]               reduce using rule 74 (indexacion -> empty .)
    &               reduce using rule 74 (indexacion -> empty .)
    ;               reduce using rule 74 (indexacion -> empty .)
    ,               reduce using rule 74 (indexacion -> empty .)
    {               reduce using rule 74 (indexacion -> empty .)


state 137

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end . ;

    ;               shift and go to state 165


state 138

    (54) estatuto -> CALL call_func ; .

    }               reduce using rule 54 (estatuto -> CALL call_func ; .)
    CALL            reduce using rule 54 (estatuto -> CALL call_func ; .)
    WHILE           reduce using rule 54 (estatuto -> CALL call_func ; .)
    FOR             reduce using rule 54 (estatuto -> CALL call_func ; .)
    IF              reduce using rule 54 (estatuto -> CALL call_func ; .)
    ID              reduce using rule 54 (estatuto -> CALL call_func ; .)


state 139

    (61) func -> ID f_verify_func . ( args )

    (               shift and go to state 166


state 140

    (62) func -> ID f_varobj . : ID f_verify_func_composite ( args )

    :               shift and go to state 167


state 141

    (113) input -> INPUT ( . var )
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    ID              shift and go to state 78

    var                            shift and go to state 168

state 142

    (114) write -> PRINT ( . write_list )
    (115) write_list -> . write_list & write_listp
    (116) write_list -> . write_listp
    (117) write_listp -> . STR
    (118) write_listp -> . var
    (119) write_listp -> . CALL to_str
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    STR             shift and go to state 171
    CALL            shift and go to state 173
    ID              shift and go to state 78

    write_list                     shift and go to state 169
    write_listp                    shift and go to state 170
    var                            shift and go to state 172

state 143

    (110) to_num -> TO_NUMBER ( . STR )
    (111) to_num -> TO_NUMBER ( . var )
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    STR             shift and go to state 174
    ID              shift and go to state 78

    var                            shift and go to state 175

state 144

    (112) to_str -> TO_STRING ( . expresion )
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 176
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 145

    (120) return -> RET ( . expresion )
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 177
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 146

    (69) asignacion -> var = f_oper . expresion ;
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    var                            shift and go to state 123
    expresion                      shift and go to state 178
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121

state 147

    (102) while -> WHILE f_while ( . expresion f_exprwhile ) DO { estatutos } f_endwhile
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 179
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 148

    (106) for -> FOR expresion f_for_start . TO expresion f_for_to { estatutos } f_for_end

    TO              shift and go to state 180


state 149

    (79) expresion -> expresion COMP . f_oper exp f_expres
    (87) f_oper -> .

    (               reduce using rule 87 (f_oper -> .)
    NUM             reduce using rule 87 (f_oper -> .)
    OPTERM          reduce using rule 87 (f_oper -> .)
    CALL            reduce using rule 87 (f_oper -> .)
    ID              reduce using rule 87 (f_oper -> .)

    f_oper                         shift and go to state 181

state 150

    (82) exp -> exp OPTERM . f_oper term f_exp
    (87) f_oper -> .

    (               reduce using rule 87 (f_oper -> .)
    NUM             reduce using rule 87 (f_oper -> .)
    OPTERM          reduce using rule 87 (f_oper -> .)
    CALL            reduce using rule 87 (f_oper -> .)
    ID              reduce using rule 87 (f_oper -> .)

    f_oper                         shift and go to state 182

state 151

    (85) term -> term OPFACT . f_oper fact f_term
    (87) f_oper -> .

    (               reduce using rule 87 (f_oper -> .)
    NUM             reduce using rule 87 (f_oper -> .)
    OPTERM          reduce using rule 87 (f_oper -> .)
    CALL            reduce using rule 87 (f_oper -> .)
    ID              reduce using rule 87 (f_oper -> .)

    f_oper                         shift and go to state 183

state 152

    (91) fact -> OPTERM NUM .

    OPFACT          reduce using rule 91 (fact -> OPTERM NUM .)
    OPTERM          reduce using rule 91 (fact -> OPTERM NUM .)
    COMP            reduce using rule 91 (fact -> OPTERM NUM .)
    TO              reduce using rule 91 (fact -> OPTERM NUM .)
    )               reduce using rule 91 (fact -> OPTERM NUM .)
    ]               reduce using rule 91 (fact -> OPTERM NUM .)
    ;               reduce using rule 91 (fact -> OPTERM NUM .)
    ,               reduce using rule 91 (fact -> OPTERM NUM .)
    {               reduce using rule 91 (fact -> OPTERM NUM .)


state 153

    (88) fact -> ( lparen . expresion ) rparen
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 184
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 154

    (90) fact -> NUM f_fact .

    OPFACT          reduce using rule 90 (fact -> NUM f_fact .)
    OPTERM          reduce using rule 90 (fact -> NUM f_fact .)
    COMP            reduce using rule 90 (fact -> NUM f_fact .)
    TO              reduce using rule 90 (fact -> NUM f_fact .)
    )               reduce using rule 90 (fact -> NUM f_fact .)
    ]               reduce using rule 90 (fact -> NUM f_fact .)
    ;               reduce using rule 90 (fact -> NUM f_fact .)
    ,               reduce using rule 90 (fact -> NUM f_fact .)
    {               reduce using rule 90 (fact -> NUM f_fact .)


state 155

    (92) fact -> CALL call_func .

    OPFACT          reduce using rule 92 (fact -> CALL call_func .)
    OPTERM          reduce using rule 92 (fact -> CALL call_func .)
    COMP            reduce using rule 92 (fact -> CALL call_func .)
    TO              reduce using rule 92 (fact -> CALL call_func .)
    )               reduce using rule 92 (fact -> CALL call_func .)
    ]               reduce using rule 92 (fact -> CALL call_func .)
    ;               reduce using rule 92 (fact -> CALL call_func .)
    ,               reduce using rule 92 (fact -> CALL call_func .)
    {               reduce using rule 92 (fact -> CALL call_func .)


state 156

    (96) condicion -> IF ( expresion . ) f_if THEN { estatutos } condicionp f_endif
    (79) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 185
    COMP            shift and go to state 149


state 157

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 186


state 158

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing . f_tipofunc { vars estatutos } f_endfunc
    (20) f_tipofunc -> .

    {               reduce using rule 20 (f_tipofunc -> .)

    f_tipofunc                     shift and go to state 187

state 159

    (46) pparams -> pparams , tipo ID f_param .

    ,               reduce using rule 46 (pparams -> pparams , tipo ID f_param .)
    )               reduce using rule 46 (pparams -> pparams , tipo ID f_param .)


state 160

    (35) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] . f_twodim
    (40) f_twodim -> .

    :               reduce using rule 40 (f_twodim -> .)

    f_twodim                       shift and go to state 188

state 161

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } . f_endclass
    (13) f_endclass -> .

    TYPE            reduce using rule 13 (f_endclass -> .)
    DEF             reduce using rule 13 (f_endclass -> .)
    MAIN            reduce using rule 13 (f_endclass -> .)
    FUNC            reduce using rule 13 (f_endclass -> .)

    f_endclass                     shift and go to state 189

state 162

    (26) cvars -> cvars DEF tipo dimension : lista_id ; .

    DEF             reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    }               reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)
    FUNC            reduce using rule 26 (cvars -> cvars DEF tipo dimension : lista_id ; .)


state 163

    (70) var -> ID f_varobj : ID . f_verify_type_composite indexacion
    (77) f_verify_type_composite -> .

    [               reduce using rule 77 (f_verify_type_composite -> .)
    =               reduce using rule 77 (f_verify_type_composite -> .)
    OPFACT          reduce using rule 77 (f_verify_type_composite -> .)
    OPTERM          reduce using rule 77 (f_verify_type_composite -> .)
    COMP            reduce using rule 77 (f_verify_type_composite -> .)
    TO              reduce using rule 77 (f_verify_type_composite -> .)
    )               reduce using rule 77 (f_verify_type_composite -> .)
    ]               reduce using rule 77 (f_verify_type_composite -> .)
    &               reduce using rule 77 (f_verify_type_composite -> .)
    ;               reduce using rule 77 (f_verify_type_composite -> .)
    ,               reduce using rule 77 (f_verify_type_composite -> .)
    {               reduce using rule 77 (f_verify_type_composite -> .)

    f_verify_type_composite        shift and go to state 190

state 164

    (72) indexacion -> [ expresion . ]
    (73) indexacion -> [ expresion . ] [ expresion ]
    (79) expresion -> expresion . COMP f_oper exp f_expres

    ]               shift and go to state 191
    COMP            shift and go to state 149


state 165

    (1) start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .

    $end            reduce using rule 1 (start -> PROGRAM f_start ID f_prog ; clases vars funciones MAIN f_main ( ) { estatutos } END f_end ; .)


state 166

    (61) func -> ID f_verify_func ( . args )
    (65) args -> . args_list
    (66) args -> . empty
    (67) args_list -> . expresion
    (68) args_list -> . args_list , expresion
    (121) empty -> .
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    )               reduce using rule 121 (empty -> .)
    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    args                           shift and go to state 192
    args_list                      shift and go to state 193
    empty                          shift and go to state 194
    expresion                      shift and go to state 195
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 167

    (62) func -> ID f_varobj : . ID f_verify_func_composite ( args )

    ID              shift and go to state 196


state 168

    (113) input -> INPUT ( var . )

    )               shift and go to state 197


state 169

    (114) write -> PRINT ( write_list . )
    (115) write_list -> write_list . & write_listp

    )               shift and go to state 198
    &               shift and go to state 199


state 170

    (116) write_list -> write_listp .

    )               reduce using rule 116 (write_list -> write_listp .)
    &               reduce using rule 116 (write_list -> write_listp .)


state 171

    (117) write_listp -> STR .

    )               reduce using rule 117 (write_listp -> STR .)
    &               reduce using rule 117 (write_listp -> STR .)


state 172

    (118) write_listp -> var .

    )               reduce using rule 118 (write_listp -> var .)
    &               reduce using rule 118 (write_listp -> var .)


state 173

    (119) write_listp -> CALL . to_str
    (112) to_str -> . TO_STRING ( expresion )

    TO_STRING       shift and go to state 113

    to_str                         shift and go to state 200

state 174

    (110) to_num -> TO_NUMBER ( STR . )

    )               shift and go to state 201


state 175

    (111) to_num -> TO_NUMBER ( var . )

    )               shift and go to state 202


state 176

    (112) to_str -> TO_STRING ( expresion . )
    (79) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 203
    COMP            shift and go to state 149


state 177

    (120) return -> RET ( expresion . )
    (79) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 204
    COMP            shift and go to state 149


state 178

    (69) asignacion -> var = f_oper expresion . ;
    (79) expresion -> expresion . COMP f_oper exp f_expres

    ;               shift and go to state 205
    COMP            shift and go to state 149


state 179

    (102) while -> WHILE f_while ( expresion . f_exprwhile ) DO { estatutos } f_endwhile
    (79) expresion -> expresion . COMP f_oper exp f_expres
    (104) f_exprwhile -> .

    COMP            shift and go to state 149
    )               reduce using rule 104 (f_exprwhile -> .)

    f_exprwhile                    shift and go to state 206

state 180

    (106) for -> FOR expresion f_for_start TO . expresion f_for_to { estatutos } f_for_end
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 207
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 181

    (79) expresion -> expresion COMP f_oper . exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    exp                            shift and go to state 208
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 182

    (82) exp -> exp OPTERM f_oper . term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    term                           shift and go to state 209
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 183

    (85) term -> term OPFACT f_oper . fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    fact                           shift and go to state 210
    var                            shift and go to state 123

state 184

    (88) fact -> ( lparen expresion . ) rparen
    (79) expresion -> expresion . COMP f_oper exp f_expres

    )               shift and go to state 211
    COMP            shift and go to state 149


state 185

    (96) condicion -> IF ( expresion ) . f_if THEN { estatutos } condicionp f_endif
    (99) f_if -> .

    THEN            reduce using rule 99 (f_if -> .)

    f_if                           shift and go to state 212

state 186

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id_obj ;
    (24) vars -> . empty
    (121) empty -> .

    DEF             reduce using rule 121 (empty -> .)
    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    vars                           shift and go to state 213
    empty                          shift and go to state 11

state 187

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc . { vars estatutos } f_endfunc

    {               shift and go to state 214


state 188

    (35) dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim .

    :               reduce using rule 35 (dimension -> [ NUM f_dim1 ] [ NUM f_dim2 ] f_twodim .)


state 189

    (8) clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .

    TYPE            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    DEF             reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    MAIN            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)
    FUNC            reduce using rule 8 (clase -> TYPE ID f_startclass : ID f_clasepadre { cvars f_cvars funciones } f_endclass .)


state 190

    (70) var -> ID f_varobj : ID f_verify_type_composite . indexacion
    (72) indexacion -> . [ expresion ]
    (73) indexacion -> . [ expresion ] [ expresion ]
    (74) indexacion -> . empty
    (121) empty -> .

    [               shift and go to state 135
    =               reduce using rule 121 (empty -> .)
    OPFACT          reduce using rule 121 (empty -> .)
    OPTERM          reduce using rule 121 (empty -> .)
    COMP            reduce using rule 121 (empty -> .)
    TO              reduce using rule 121 (empty -> .)
    )               reduce using rule 121 (empty -> .)
    ]               reduce using rule 121 (empty -> .)
    &               reduce using rule 121 (empty -> .)
    ;               reduce using rule 121 (empty -> .)
    ,               reduce using rule 121 (empty -> .)
    {               reduce using rule 121 (empty -> .)

    indexacion                     shift and go to state 215
    empty                          shift and go to state 136

state 191

    (72) indexacion -> [ expresion ] .
    (73) indexacion -> [ expresion ] . [ expresion ]

    =               reduce using rule 72 (indexacion -> [ expresion ] .)
    OPFACT          reduce using rule 72 (indexacion -> [ expresion ] .)
    OPTERM          reduce using rule 72 (indexacion -> [ expresion ] .)
    COMP            reduce using rule 72 (indexacion -> [ expresion ] .)
    TO              reduce using rule 72 (indexacion -> [ expresion ] .)
    )               reduce using rule 72 (indexacion -> [ expresion ] .)
    ]               reduce using rule 72 (indexacion -> [ expresion ] .)
    &               reduce using rule 72 (indexacion -> [ expresion ] .)
    ;               reduce using rule 72 (indexacion -> [ expresion ] .)
    ,               reduce using rule 72 (indexacion -> [ expresion ] .)
    {               reduce using rule 72 (indexacion -> [ expresion ] .)
    [               shift and go to state 216


state 192

    (61) func -> ID f_verify_func ( args . )

    )               shift and go to state 217


state 193

    (65) args -> args_list .
    (68) args_list -> args_list . , expresion

    )               reduce using rule 65 (args -> args_list .)
    ,               shift and go to state 218


state 194

    (66) args -> empty .

    )               reduce using rule 66 (args -> empty .)


state 195

    (67) args_list -> expresion .
    (79) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 67 (args_list -> expresion .)
    )               reduce using rule 67 (args_list -> expresion .)
    COMP            shift and go to state 149


state 196

    (62) func -> ID f_varobj : ID . f_verify_func_composite ( args )
    (64) f_verify_func_composite -> .

    (               reduce using rule 64 (f_verify_func_composite -> .)

    f_verify_func_composite        shift and go to state 219

state 197

    (113) input -> INPUT ( var ) .

    ;               reduce using rule 113 (input -> INPUT ( var ) .)
    OPFACT          reduce using rule 113 (input -> INPUT ( var ) .)
    OPTERM          reduce using rule 113 (input -> INPUT ( var ) .)
    COMP            reduce using rule 113 (input -> INPUT ( var ) .)
    TO              reduce using rule 113 (input -> INPUT ( var ) .)
    )               reduce using rule 113 (input -> INPUT ( var ) .)
    ]               reduce using rule 113 (input -> INPUT ( var ) .)
    ,               reduce using rule 113 (input -> INPUT ( var ) .)
    {               reduce using rule 113 (input -> INPUT ( var ) .)


state 198

    (114) write -> PRINT ( write_list ) .

    ;               reduce using rule 114 (write -> PRINT ( write_list ) .)
    OPFACT          reduce using rule 114 (write -> PRINT ( write_list ) .)
    OPTERM          reduce using rule 114 (write -> PRINT ( write_list ) .)
    COMP            reduce using rule 114 (write -> PRINT ( write_list ) .)
    TO              reduce using rule 114 (write -> PRINT ( write_list ) .)
    )               reduce using rule 114 (write -> PRINT ( write_list ) .)
    ]               reduce using rule 114 (write -> PRINT ( write_list ) .)
    ,               reduce using rule 114 (write -> PRINT ( write_list ) .)
    {               reduce using rule 114 (write -> PRINT ( write_list ) .)


state 199

    (115) write_list -> write_list & . write_listp
    (117) write_listp -> . STR
    (118) write_listp -> . var
    (119) write_listp -> . CALL to_str
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    STR             shift and go to state 171
    CALL            shift and go to state 173
    ID              shift and go to state 78

    write_listp                    shift and go to state 220
    var                            shift and go to state 172

state 200

    (119) write_listp -> CALL to_str .

    )               reduce using rule 119 (write_listp -> CALL to_str .)
    &               reduce using rule 119 (write_listp -> CALL to_str .)


state 201

    (110) to_num -> TO_NUMBER ( STR ) .

    ;               reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    OPFACT          reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    OPTERM          reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    COMP            reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    TO              reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    )               reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    ]               reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    ,               reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)
    {               reduce using rule 110 (to_num -> TO_NUMBER ( STR ) .)


state 202

    (111) to_num -> TO_NUMBER ( var ) .

    ;               reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    OPFACT          reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    OPTERM          reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    COMP            reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    TO              reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    )               reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    ]               reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    ,               reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)
    {               reduce using rule 111 (to_num -> TO_NUMBER ( var ) .)


state 203

    (112) to_str -> TO_STRING ( expresion ) .

    ;               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    OPFACT          reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    OPTERM          reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    COMP            reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    TO              reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    )               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    ]               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    ,               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    {               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)
    &               reduce using rule 112 (to_str -> TO_STRING ( expresion ) .)


state 204

    (120) return -> RET ( expresion ) .

    ;               reduce using rule 120 (return -> RET ( expresion ) .)
    OPFACT          reduce using rule 120 (return -> RET ( expresion ) .)
    OPTERM          reduce using rule 120 (return -> RET ( expresion ) .)
    COMP            reduce using rule 120 (return -> RET ( expresion ) .)
    TO              reduce using rule 120 (return -> RET ( expresion ) .)
    )               reduce using rule 120 (return -> RET ( expresion ) .)
    ]               reduce using rule 120 (return -> RET ( expresion ) .)
    ,               reduce using rule 120 (return -> RET ( expresion ) .)
    {               reduce using rule 120 (return -> RET ( expresion ) .)


state 205

    (69) asignacion -> var = f_oper expresion ; .

    }               reduce using rule 69 (asignacion -> var = f_oper expresion ; .)
    CALL            reduce using rule 69 (asignacion -> var = f_oper expresion ; .)
    WHILE           reduce using rule 69 (asignacion -> var = f_oper expresion ; .)
    FOR             reduce using rule 69 (asignacion -> var = f_oper expresion ; .)
    IF              reduce using rule 69 (asignacion -> var = f_oper expresion ; .)
    ID              reduce using rule 69 (asignacion -> var = f_oper expresion ; .)


state 206

    (102) while -> WHILE f_while ( expresion f_exprwhile . ) DO { estatutos } f_endwhile

    )               shift and go to state 221


state 207

    (106) for -> FOR expresion f_for_start TO expresion . f_for_to { estatutos } f_for_end
    (79) expresion -> expresion . COMP f_oper exp f_expres
    (108) f_for_to -> .

    COMP            shift and go to state 149
    {               reduce using rule 108 (f_for_to -> .)

    f_for_to                       shift and go to state 222

state 208

    (79) expresion -> expresion COMP f_oper exp . f_expres
    (82) exp -> exp . OPTERM f_oper term f_exp
    (80) f_expres -> .

    OPTERM          shift and go to state 150
    COMP            reduce using rule 80 (f_expres -> .)
    TO              reduce using rule 80 (f_expres -> .)
    )               reduce using rule 80 (f_expres -> .)
    ]               reduce using rule 80 (f_expres -> .)
    ;               reduce using rule 80 (f_expres -> .)
    ,               reduce using rule 80 (f_expres -> .)
    {               reduce using rule 80 (f_expres -> .)

    f_expres                       shift and go to state 223

state 209

    (82) exp -> exp OPTERM f_oper term . f_exp
    (85) term -> term . OPFACT f_oper fact f_term
    (83) f_exp -> .

    OPFACT          shift and go to state 151
    OPTERM          reduce using rule 83 (f_exp -> .)
    COMP            reduce using rule 83 (f_exp -> .)
    TO              reduce using rule 83 (f_exp -> .)
    )               reduce using rule 83 (f_exp -> .)
    ]               reduce using rule 83 (f_exp -> .)
    ;               reduce using rule 83 (f_exp -> .)
    ,               reduce using rule 83 (f_exp -> .)
    {               reduce using rule 83 (f_exp -> .)

    f_exp                          shift and go to state 224

state 210

    (85) term -> term OPFACT f_oper fact . f_term
    (86) f_term -> .

    OPFACT          reduce using rule 86 (f_term -> .)
    OPTERM          reduce using rule 86 (f_term -> .)
    COMP            reduce using rule 86 (f_term -> .)
    TO              reduce using rule 86 (f_term -> .)
    )               reduce using rule 86 (f_term -> .)
    ]               reduce using rule 86 (f_term -> .)
    ;               reduce using rule 86 (f_term -> .)
    ,               reduce using rule 86 (f_term -> .)
    {               reduce using rule 86 (f_term -> .)

    f_term                         shift and go to state 225

state 211

    (88) fact -> ( lparen expresion ) . rparen
    (94) rparen -> .

    OPFACT          reduce using rule 94 (rparen -> .)
    OPTERM          reduce using rule 94 (rparen -> .)
    COMP            reduce using rule 94 (rparen -> .)
    TO              reduce using rule 94 (rparen -> .)
    )               reduce using rule 94 (rparen -> .)
    ]               reduce using rule 94 (rparen -> .)
    ;               reduce using rule 94 (rparen -> .)
    ,               reduce using rule 94 (rparen -> .)
    {               reduce using rule 94 (rparen -> .)

    rparen                         shift and go to state 226

state 212

    (96) condicion -> IF ( expresion ) f_if . THEN { estatutos } condicionp f_endif

    THEN            shift and go to state 227


state 213

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id_obj ;
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 228
    empty                          shift and go to state 67

state 214

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { . vars estatutos } f_endfunc
    (22) vars -> . vars DEF tipo dimension : lista_id ;
    (23) vars -> . vars DEF ID f_varsobj : lista_id_obj ;
    (24) vars -> . empty
    (121) empty -> .

    DEF             reduce using rule 121 (empty -> .)
    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    vars                           shift and go to state 229
    empty                          shift and go to state 11

state 215

    (70) var -> ID f_varobj : ID f_verify_type_composite indexacion .

    =               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    OPFACT          reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    OPTERM          reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    COMP            reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    TO              reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    )               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ]               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    &               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ;               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    ,               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)
    {               reduce using rule 70 (var -> ID f_varobj : ID f_verify_type_composite indexacion .)


state 216

    (73) indexacion -> [ expresion ] [ . expresion ]
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 230
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 217

    (61) func -> ID f_verify_func ( args ) .

    ;               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    OPFACT          reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    OPTERM          reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    COMP            reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    TO              reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    )               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    ]               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    ,               reduce using rule 61 (func -> ID f_verify_func ( args ) .)
    {               reduce using rule 61 (func -> ID f_verify_func ( args ) .)


state 218

    (68) args_list -> args_list , . expresion
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    expresion                      shift and go to state 231
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 219

    (62) func -> ID f_varobj : ID f_verify_func_composite . ( args )

    (               shift and go to state 232


state 220

    (115) write_list -> write_list & write_listp .

    )               reduce using rule 115 (write_list -> write_list & write_listp .)
    &               reduce using rule 115 (write_list -> write_list & write_listp .)


state 221

    (102) while -> WHILE f_while ( expresion f_exprwhile ) . DO { estatutos } f_endwhile

    DO              shift and go to state 233


state 222

    (106) for -> FOR expresion f_for_start TO expresion f_for_to . { estatutos } f_for_end

    {               shift and go to state 234


state 223

    (79) expresion -> expresion COMP f_oper exp f_expres .

    COMP            reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    TO              reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    )               reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    ]               reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    ;               reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    ,               reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)
    {               reduce using rule 79 (expresion -> expresion COMP f_oper exp f_expres .)


state 224

    (82) exp -> exp OPTERM f_oper term f_exp .

    OPTERM          reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    COMP            reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    TO              reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    )               reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    ]               reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    ;               reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    ,               reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)
    {               reduce using rule 82 (exp -> exp OPTERM f_oper term f_exp .)


state 225

    (85) term -> term OPFACT f_oper fact f_term .

    OPFACT          reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    OPTERM          reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    COMP            reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    TO              reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    )               reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    ]               reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    ;               reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    ,               reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)
    {               reduce using rule 85 (term -> term OPFACT f_oper fact f_term .)


state 226

    (88) fact -> ( lparen expresion ) rparen .

    OPFACT          reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    OPTERM          reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    COMP            reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    TO              reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    )               reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    ]               reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    ;               reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    ,               reduce using rule 88 (fact -> ( lparen expresion ) rparen .)
    {               reduce using rule 88 (fact -> ( lparen expresion ) rparen .)


state 227

    (96) condicion -> IF ( expresion ) f_if THEN . { estatutos } condicionp f_endif

    {               shift and go to state 235


state 228

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos . } f_endfunc
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 236
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 229

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars . estatutos } f_endfunc
    (22) vars -> vars . DEF tipo dimension : lista_id ;
    (23) vars -> vars . DEF ID f_varsobj : lista_id_obj ;
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    DEF             shift and go to state 14
    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 237
    empty                          shift and go to state 67

state 230

    (73) indexacion -> [ expresion ] [ expresion . ]
    (79) expresion -> expresion . COMP f_oper exp f_expres

    ]               shift and go to state 238
    COMP            shift and go to state 149


state 231

    (68) args_list -> args_list , expresion .
    (79) expresion -> expresion . COMP f_oper exp f_expres

    ,               reduce using rule 68 (args_list -> args_list , expresion .)
    )               reduce using rule 68 (args_list -> args_list , expresion .)
    COMP            shift and go to state 149


state 232

    (62) func -> ID f_varobj : ID f_verify_func_composite ( . args )
    (65) args -> . args_list
    (66) args -> . empty
    (67) args_list -> . expresion
    (68) args_list -> . args_list , expresion
    (121) empty -> .
    (78) expresion -> . exp
    (79) expresion -> . expresion COMP f_oper exp f_expres
    (81) exp -> . term
    (82) exp -> . exp OPTERM f_oper term f_exp
    (84) term -> . fact
    (85) term -> . term OPFACT f_oper fact f_term
    (88) fact -> . ( lparen expresion ) rparen
    (89) fact -> . var
    (90) fact -> . NUM f_fact
    (91) fact -> . OPTERM NUM
    (92) fact -> . CALL call_func
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    )               reduce using rule 121 (empty -> .)
    (               shift and go to state 122
    NUM             shift and go to state 124
    OPTERM          shift and go to state 120
    CALL            shift and go to state 125
    ID              shift and go to state 78

    args                           shift and go to state 239
    args_list                      shift and go to state 193
    empty                          shift and go to state 194
    expresion                      shift and go to state 195
    exp                            shift and go to state 118
    term                           shift and go to state 119
    fact                           shift and go to state 121
    var                            shift and go to state 123

state 233

    (102) while -> WHILE f_while ( expresion f_exprwhile ) DO . { estatutos } f_endwhile

    {               shift and go to state 240


state 234

    (106) for -> FOR expresion f_for_start TO expresion f_for_to { . estatutos } f_for_end
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 241
    empty                          shift and go to state 67

state 235

    (96) condicion -> IF ( expresion ) f_if THEN { . estatutos } condicionp f_endif
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 242
    empty                          shift and go to state 67

state 236

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 243

state 237

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos . } f_endfunc
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 244
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 238

    (73) indexacion -> [ expresion ] [ expresion ] .

    =               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    OPFACT          reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    OPTERM          reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    COMP            reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    TO              reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    )               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    ]               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    &               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    ;               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    ,               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)
    {               reduce using rule 73 (indexacion -> [ expresion ] [ expresion ] .)


state 239

    (62) func -> ID f_varobj : ID f_verify_func_composite ( args . )

    )               shift and go to state 245


state 240

    (102) while -> WHILE f_while ( expresion f_exprwhile ) DO { . estatutos } f_endwhile
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 246
    empty                          shift and go to state 67

state 241

    (106) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos . } f_for_end
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 247
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 242

    (96) condicion -> IF ( expresion ) f_if THEN { estatutos . } condicionp f_endif
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 248
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 243

    (16) funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 16 (funcion -> FUNC ID f_startfunc ( params ) : tipo f_tipofunc { vars estatutos } f_endfunc .)


state 244

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } . f_endfunc
    (21) f_endfunc -> .

    MAIN            reduce using rule 21 (f_endfunc -> .)
    FUNC            reduce using rule 21 (f_endfunc -> .)
    }               reduce using rule 21 (f_endfunc -> .)

    f_endfunc                      shift and go to state 249

state 245

    (62) func -> ID f_varobj : ID f_verify_func_composite ( args ) .

    ;               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPFACT          reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    OPTERM          reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    COMP            reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    TO              reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    )               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ]               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    ,               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)
    {               reduce using rule 62 (func -> ID f_varobj : ID f_verify_func_composite ( args ) .)


state 246

    (102) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos . } f_endwhile
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 250
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 247

    (106) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } . f_for_end
    (109) f_for_end -> .

    }               reduce using rule 109 (f_for_end -> .)
    CALL            reduce using rule 109 (f_for_end -> .)
    WHILE           reduce using rule 109 (f_for_end -> .)
    FOR             reduce using rule 109 (f_for_end -> .)
    IF              reduce using rule 109 (f_for_end -> .)
    ID              reduce using rule 109 (f_for_end -> .)

    f_for_end                      shift and go to state 251

state 248

    (96) condicion -> IF ( expresion ) f_if THEN { estatutos } . condicionp f_endif
    (97) condicionp -> . ELSE f_else { estatutos }
    (98) condicionp -> . empty
    (121) empty -> .

    ELSE            shift and go to state 253
    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    condicionp                     shift and go to state 252
    empty                          shift and go to state 254

state 249

    (17) funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .

    MAIN            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    FUNC            reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)
    }               reduce using rule 17 (funcion -> FUNC ID f_startfunc ( params ) : NOTHING f_nothing f_tipofunc { vars estatutos } f_endfunc .)


state 250

    (102) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } . f_endwhile
    (105) f_endwhile -> .

    }               reduce using rule 105 (f_endwhile -> .)
    CALL            reduce using rule 105 (f_endwhile -> .)
    WHILE           reduce using rule 105 (f_endwhile -> .)
    FOR             reduce using rule 105 (f_endwhile -> .)
    IF              reduce using rule 105 (f_endwhile -> .)
    ID              reduce using rule 105 (f_endwhile -> .)

    f_endwhile                     shift and go to state 255

state 251

    (106) for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .

    }               reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    CALL            reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    WHILE           reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    FOR             reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    IF              reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)
    ID              reduce using rule 106 (for -> FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end .)


state 252

    (96) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp . f_endif
    (100) f_endif -> .

    }               reduce using rule 100 (f_endif -> .)
    CALL            reduce using rule 100 (f_endif -> .)
    WHILE           reduce using rule 100 (f_endif -> .)
    FOR             reduce using rule 100 (f_endif -> .)
    IF              reduce using rule 100 (f_endif -> .)
    ID              reduce using rule 100 (f_endif -> .)

    f_endif                        shift and go to state 256

state 253

    (97) condicionp -> ELSE . f_else { estatutos }
    (101) f_else -> .

    {               reduce using rule 101 (f_else -> .)

    f_else                         shift and go to state 257

state 254

    (98) condicionp -> empty .

    }               reduce using rule 98 (condicionp -> empty .)
    CALL            reduce using rule 98 (condicionp -> empty .)
    WHILE           reduce using rule 98 (condicionp -> empty .)
    FOR             reduce using rule 98 (condicionp -> empty .)
    IF              reduce using rule 98 (condicionp -> empty .)
    ID              reduce using rule 98 (condicionp -> empty .)


state 255

    (102) while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .

    }               reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    CALL            reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    WHILE           reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    FOR             reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    IF              reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)
    ID              reduce using rule 102 (while -> WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile .)


state 256

    (96) condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .

    }               reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    CALL            reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    WHILE           reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    FOR             reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    IF              reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)
    ID              reduce using rule 96 (condicion -> IF ( expresion ) f_if THEN { estatutos } condicionp f_endif .)


state 257

    (97) condicionp -> ELSE f_else . { estatutos }

    {               shift and go to state 258


state 258

    (97) condicionp -> ELSE f_else { . estatutos }
    (48) estatutos -> . estatutos estatuto
    (49) estatutos -> . empty
    (121) empty -> .

    }               reduce using rule 121 (empty -> .)
    CALL            reduce using rule 121 (empty -> .)
    WHILE           reduce using rule 121 (empty -> .)
    FOR             reduce using rule 121 (empty -> .)
    IF              reduce using rule 121 (empty -> .)
    ID              reduce using rule 121 (empty -> .)

    estatutos                      shift and go to state 259
    empty                          shift and go to state 67

state 259

    (97) condicionp -> ELSE f_else { estatutos . }
    (48) estatutos -> estatutos . estatuto
    (50) estatuto -> . asignacion
    (51) estatuto -> . while
    (52) estatuto -> . for
    (53) estatuto -> . condicion
    (54) estatuto -> . CALL call_func ;
    (69) asignacion -> . var = f_oper expresion ;
    (102) while -> . WHILE f_while ( expresion f_exprwhile ) DO { estatutos } f_endwhile
    (106) for -> . FOR expresion f_for_start TO expresion f_for_to { estatutos } f_for_end
    (96) condicion -> . IF ( expresion ) f_if THEN { estatutos } condicionp f_endif
    (70) var -> . ID f_varobj : ID f_verify_type_composite indexacion
    (71) var -> . ID f_verify_type indexacion

    }               shift and go to state 260
    CALL            shift and go to state 85
    WHILE           shift and go to state 87
    FOR             shift and go to state 88
    IF              shift and go to state 89
    ID              shift and go to state 78

    estatuto                       shift and go to state 80
    asignacion                     shift and go to state 81
    while                          shift and go to state 82
    for                            shift and go to state 83
    condicion                      shift and go to state 84
    var                            shift and go to state 86

state 260

    (97) condicionp -> ELSE f_else { estatutos } .

    }               reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)
    CALL            reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)
    WHILE           reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)
    FOR             reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)
    IF              reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)
    ID              reduce using rule 97 (condicionp -> ELSE f_else { estatutos } .)

